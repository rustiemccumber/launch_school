{
  "title": "Ls 180: study guide",
  "cells": [
    {
      "type": "markdown",
      "data": "## SQL\n### []- idenitfy the different types of `JOINS` and explian their differences.\n\n|JOIN TYPE | NOTES|\n|--|--|\n|`INNER`| combines rows from tow tables whenver the join condition is met, this can just be made by `JOIN`|\n|`LEFT`| Same as an inner join, except rows form the first table are added to the join table, regardless of the evaulation of the join condition.|\n|`RIGHT`| same as inner join, except rwos from the second table are added to the join table, regardless of the evaulation of the join condition|\n|`FULL`|  A combination of Left join and right join|\n|`CROSS`|  Doesn't use a join condition.  The join table is th eresult of matching every row from the first table with the second table, the cross product of all rows acrosss both tables|\n\n#### INNER JOIN\n\nAN `INNER JOIN` (`JOIN`) returns a result set that contains the common elements for the tables, i.e. the inersection where they match on the joined condition.  INNER JOINS are the most frequently used JOINS.\n\nexample of `INNER JOIN`\n\n```\nSELECT users.*, addresses.*\n\nFROM users\nINNER JOIN addresses\nON (users.id = addresses.user_id)\n```\n\n#### LEFT JOIN\n\nA LEFT JOIN or LEFT OUTER JOIN takes all the rows form on table defined as the `LEFT` table, and joins it with a second table.  THe `JOIN` is based on the conditions supplied in parentheses. A `LEFT JOIN` will always include the rows from the `LEFT` table, even if there are not matching rows in the table it is joined with. \n\n```\nSELECT users.*, addresses.*\nFROM users\nLEFT JOIN addresses\nON (users.id = addresses.user_id);\n```\n\n![Screen Shot 2021-01-07 at 2.05.35 PM.png](quiver-image-url/79748946B18A462F94D43B9BB889520F.png =451x112)\n\n\n#### RIGHT JOIN\n\nA `RIGHT JOIN` is similar to a `LEFT JOIN` except that the roles between the two tables are reversed and all the rows on the second table are included alogn with any matching rows from the first table. \n\n![Screen Shot 2021-01-07 at 2.06.23 PM.png](quiver-image-url/9434492E7CBE8F67AD009B76B778318E.png =453x108)\n\n####FULL JOIN \n\nA `FULL JOIN` or `FULL OUTER JOIN` is essentially a combination of `LEFT JOIN` and `RIGHT JOIN`.  This type of join contains all of the rows form both of the table.s  WErhe the join condition is met, the rows of the two tables are joined, just as in the previous examples we've seen. For any rows on either side of the join where the join condition i9s not met, the columns for hte other table have `NULL` values for that row. \n\n####CROSS JOIN \n\nA `CROSS JOIN` also known as a Cartesian JOIN, returns all rows from one table crossed with every row from the second table. \n\n![Screen Shot 2021-01-07 at 2.20.28 PM.png](quiver-image-url/C1E92DF692FF75649CFCCBB13103111C.png =447x257)\n\n####Multiple Joins\n\nIt is possible, to join more than just two tables together.  This is done by adding additional `JOIN` clauses to your `SELECT` statements.  TO join multiple tables in this way, there must be a logical relationship between the tables invovled. \n\nEXAMPLE: \n\n```\nSELECT users.full_name, books.title, checkouts.checkout_date FROM users\nINNER JOIN checkouts ON (users.id = checkouts.user_id)\nINNER JOIN books on (books.id = checkouts.book_id);\n```\n\n### []- Name and define the three sublanguages of SQL and be able to classify different statements by sublanguage.\n\n| sub-language | controls | SQL Constructs|\n|--|--|--|\n|DDL or data definition language| relation structure and rules | `CREATE`, `DROP`, `ALTER`|\n|DML or data manipulation language | values stored within relations |  `SELECT`, `INSERT`, `UPDATE`, `DELETE`|\n|*DCL* or data control language | who can do what | `GRANT`|\n\n### []-WRITE sQL statments using INSERT, UPDATE, DELETE, CREATE/ALTER/DROP TABLE, ADD/ALTER/DROP COLUMN.\n\n#### DML\n\n##### INSERT (DML)\n\n```\nINSERT INTO table_name (column1_name, column2_name)  VALUES (data_for_column1, data_for_column2 ); \n```\n\n##### UPDATE \n\n```\nUPDATE table_name SET [column_name1 = value1, ...] WHERE (expression);\n```\n\n##### DELETE\n\n```\nDELETE FROM table_name WHERE (expression);\n```\n\n####DDL\n\n|*SQL Statment*|*NOTES*|\n|--|--|\n|CREATE DATABASE sql_book| creates a new database called sql_book|\n|DROP DATABASE my_database | permanently declets the database named *my_database and all its data|\n\n#####CREATE\n\n```\nsql_book=#  CREATE DATABASE users;\n```\n\n```\nCREATE TABLE users (\n  id serial UNIQUE NOT NULL,\n  username char(25),\n  enabled boolean DEFAULT TRUE\n  );\n```\n  \n#####ALTER\n\n\nThese update existing data in a database table\n\n\n\n\n\n\n#### DDL Commands\n\n### []- Understand how to use GROUP BY, ORDER BY, WHERE And HAVING.\n\n### []- Be familiar with using usbqueries: \n\n\n\n## PostgreSQL\n\n###[]- Describe what a sequence is and what they are used for.\n\nIt turns out the serial columns in PostgreSQL are actually a shorthand for a column defintion that is much longer:\n\n```\n---This statement: ---\nCREATE TABLE colors (id serial, nae=me text);\n\n-- is actually interpreted as if it were this:\nCREATE SEQUENCE colors_id_seq;\nCREATE TABLE colors (\n  id integer NOT NULL DEFAULT nextval('colors_id_seq'),\n  name text\n); \n```\n\na sequence is a special kind of relation that generates a series of numbers.  A sequence will remember the last number is generated, so it will generate numbers in a predetermined sequence automatically. \n\nyou can see from the expanded example above that the sequence's value is used as the `id` column's default value.  The next value of a sequence is accessed using `nextval` and can be done in any SQL statement:\n\n```\n\nsql-course=# SELECT nextval('colors_id_seq');\n  nextval\n------------\n     4\n(1 row) \n\n```\n\nOnce a number is returned by `nextval` for a standard sequence, it will not be returned again, regardless of wheter the value was stored in a row or not.  If we insert another row into the colors table, the `id` value for the rwo will skip `4` and move on to the next value in the sequence:\n\n```\nsql-course=# INSERT INTO colors (name) VALUES\n  ('yellow');\nINSERT 0 1\nsql-course=# SELECT * FROM colors;\n id |  name\n----+--------\n  1 | red\n  2 | green\n  3 | blue\n  5 | yellow\n(4 rows)\n\n```\n\n\n###[]- Create an auto-incrementing column. \n\n*serial* go back to this to break down to `nextval` etc.\n\n**serial** columns in PostgreSQL are actually a short hand for a column definition tht is much longer:\n\n```\n--- This statement: ---\nCREATE TABLE colors (id serial, name text);\n\n-- is actually interpreted as if it were this one:\nCREATE SEQUENCE colors_id_sq;\nCREATE TABLE colors (\n  id integer NOT NULL DEFAULT nextval nextval('colors_id_seq'),\n  name text\n);\n```\n\n###[]- Define default value for a column.\n\nWhen creating a table you can define a default value in the following way.\n\n```\nsql_book=# CREATE TABLE users ( \n  id serial UNIQUE NOT NULL,\n  username char(20),\n  enabled boolean DEFAULT TRUE\n);\n```\nYou can add a default value into a pre-existing table by doing the following. \n\n```\nALTER TABLE employees ALTER COLUMN vacation_remaining SET DEFAULT 0;\n```\n\n###[]- Be able to describe what primary, foreign, natural, and surrogate keys are.\n\n#### surrogate key\n\nA **surrogate key** is a value tht is created solely for the prupose of identifying a row of data in a database table. Because it is created specifically for that purpose, it can avoid many of the problmes associated with natural keys.\n\nPerhaps the most common surrogate key is use today is an autoincrementing integer.  This is a values that is added to each row in a table as it is created.  With each row this value increases in order to remain unique in each row.\n\nhere is an example:\n\n```\nCREATE TABLE colors (id serial, name text);\n```\n\nit's common to call the surrogate key created for a table **id**(short of *identifier*).\n\n####primary key\n\nA *Primary Key* is a unique identifier for a row of data.  \n\nIn order to act as a unique identifier a column must contain some data, and that data should be unique to each row.\n\n`PRIMARY KEY` is the same as adding a UNIQUE and a NOT Null constraint to a column. \n\n#### FOREIGN Keys\n\nA Foreign Key allows us to associate a row in one table to a a row in another table.  This is done by setting a column in one table as a Foreign Key and having that column reference another table's Primary Key column.\n\n```FOREIGN KEY (fk_col_name) REFERENCES target_table_name (pk_col_name)```\n\nThe specific way in which a Foreign Key is used as part of a table's schema depends on the type of realtionship we want to define between our tables.  In order to implement that schema correctly it is useful to formally describe the relationships we need to model between our entities:\n\n1. A User can have ONE address. An address has only ONE user. (one-to-one)\n2. A review can only be about ONE Book.  A Book can have MANY review.  (one-to-many).\n3. A User can have Many books that he/she may have checked out or returned.  a Book can be/have  been checked out by Many users (many-to-many). \n\n#### natural key\n\nA natural key is an existing value in a dataset that can be used to uniquely identify each row of data in that dataset.  On the surface there appear to be a lot of values that might be satisfactory for this use:  a person's phone numer, email addreees, social secureity number, or a product umber.\n\nHowever, in reality most values that seem likey they are good candidates for natural keys turn out to not be.  A phone number and email address can change hands.  A social security number shouldn't change but only some pople have them. And prodcuts often go through multiple revisions while retaining the same product number.\n\nThere are a varity of solutions to these problems, including using more than one existing value together as a **composite key**. But instead of solving the problems associated with natural keys, this will often just defer the problem until later without actually addressing it. \n\n\n\n###[]- Create and remove CHECK constrains from a column.\n\nwhile creating a table\n\n```\nCREATE TABLE employees (\n  id serial PIMARKY KEY,\n  first_name VARCHAR (50),\n  last_name VARCHAR (50),\n  birth_date DATE CHECK (birth_date > '1900-01-01'),\n  joined_date DATE CHECK (joined_date > birth_date),\n  salary numeric CHECK (salary > 0)\n);\n\n```\n\nadding check to a prexisting table\n\n```\nALTER TABLE table_name\nADD CHECK(expression);\n```\n\nanother syntax for addding a check to a pre-existing table\n\n```\nALTER TABLE table_name\nADD CONSTRAINT check_name CHECK (expression);\n\n```\n\n\n###[]- Create and remove foreign key constraints from a column\n\nsimultaneously with the creation of a table you can add a foreign key in two ways.  At the bottonw of the table you can do the following\n\n```FOREIGN KEY (fk_col_name) REFERENCES target_table_name (pk_col_name)```\n\ninline with a column information you can do \n\n```\nCREATE TABLE table(\n  id serial PRIMARY KEYl\n  other_id int REFERENCES other_table(pk_col_name)\n);\n```\n\nAfter creating on a table you can declare a pre-existing column a Foreign Key like such:\n\n```\nALTER TABLE child_table\nADD CONSTRAINT constraint_name\nFOREIGN KEY (fk_columns)\nREFERENCES parent_table (parent_key_columns);\n```\n\nREMOVING a foreign key: \n\n```\nALTER TABLE child_table\nDROP CONSTRAINT constraint_fkey\n```\nwhen you add a foreign key constraint with `ON DELETE CASCADE` option to an existing table, you need to follow these steps:\n\nfirst drop existing foreign keys:\n\n```\nALTER TABLE child_table\nDROP CONSTRAINT constraint_fkey;\n```\n\nThen add a new foreign key constaint with `ON DELETE CASCADE` action:\n\n```\nALTER TABLE child_table\nADD CONSTRAINT constraint_fk\nFOREIN KEY (fk_columns)\nREFERENCES parent_table(parent_key_columns)\nON DELETE CASCADE; \n```\n\n## Database Diagrams\n\n**relational databases** are called relational because they persist data in a set of **relations** or they are more commonly called, tables. \n\nA **relationship** is a connection between entity instances, or rows of data, usually resulting form what these rows of data represent.\n\n\n###[]- Talk about the different levels of schema\n\nThe three levels of schema are **conceptual**, **logical** and **physical**. \n\n**conceptual schema** High-level design focused on identifying entities and their relationships.  **entity relationship** model (diagram) (erd)\n\n**physical schema** low-level database-specific design focused on implementation. \n\nbelow is an example of a conceptual schema (using crow's foot notation) on the left, and a phsyical schema on the right. \n\n![Screen Shot 2021-01-07 at 12.15.15 PM.png](quiver-image-url/C8D3E41CEEE3BFD274695E3A10EAC6BD.png =643x322)\n\n\n\n\n###[]- Define cardinality and modality \n\n*cardinality* is the number of objects on each side of the relationship\n(1:1, 1:M, M:M)\n\n*modality* of a relationship indicates if that relationship is required (1) or not (0).\n\nmodality is represented in a diagram like this:\n\n![Screen Shot 2021-01-07 at 12.30.35 PM.png](quiver-image-url/4E0CC7325E2FF4725E4A9EFC30AB18E6.png =432x194)\n\nbelow is an example of a conceptual schema using modality. which shows that a books has to have an author and an author has to have at least one book.  It then says that a category can have 0 or more books and a book can be in 0 or more categories (its optional). a seat can belong to on and only one section (required), and a section must have 1 or more seats (required).  \n\n\n![Screen Shot 2021-01-07 at 12.32.05 PM.png](quiver-image-url/46581FAFA5C4C82A644EA5D567D6C6F2.png =395x247)\n\nLooking at the diagram below, a TICKET must have 1 (and only one) customer (required) and \n\n![Screen Shot 2021-01-07 at 12.42.38 PM.png](quiver-image-url/673B113939B872A179B64EA474ED64A3.png =442x259)\n\n*Refrential Integrity* is data that requires all refrences to be valid.  That is if a value in a column references a value in another column (usually in another table), then that value must exist in the referenced column.  But a customer can have 0- many tickets (optional).  A ticket can belong to 1 and only one event (required) an event can have 0 or more tickets (optional).  A ticket can have one and only one seat. and a Seat can have 0 or more tickets (optional). \n\n\n###[]- Be able to draw databse diagrams using crow's foot notation\n\n"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}