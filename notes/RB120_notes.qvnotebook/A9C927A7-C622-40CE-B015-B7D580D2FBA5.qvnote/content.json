{
  "title": "RB129 Notes for Interview assignment",
  "cells": [
    {
      "type": "markdown",
      "data": "### Modules\n\nA **module** is a colleciton of behaviors that is usable in other classes via **mixins**\n\nmodules are a manner of grouping behaviors. modules are ruby's way of supporting mulitple inheritance.  With class inheritance, or building a heriarchy of a parent class and sub classes\neach subclass can only inherit from one parent class. This creates issues, say if you had several of the subclasses that you did want to inhert a behavior, but several others that you did, you could not put the behavior in the parent class because all of the subclasses would inherit that behavior.  For this reason you would look to modules\n\nso say for example you wanted to model a heriarchy starting with an animal class\n\n```ruby\nmodule Runnable\n  def run\n    \"I'm running\"\n  end\nend\n\nmodule NOTEATINGFISHFOOD\n  \nend\n\n\nclass Animal\n  def breath \n   \"I can breath\"\n  end\n  \n  def swim\n    \"i can swim\"\n  end\n  \nend\n\nclass Dog < Animal\n  include Runnable\n\nend\n\nclass Cat  < Animal\n  include Runnable \nend\n\nclass Fish < Animal\n\nend\n\n```\n\n**Encapsulation:** Hiding pieces of functionality and making it unavailable to the rest of the code base. It is a form of data protection, so that data cannot be maipulated or changed withou obvious intention. It is what defines the boundaries in your application and allows your code to ahieve new levels of complexity. Ruby, like many other OO laguages, accomplishes this task by creating objects, and exposing interfaces (i.e. methods) to interact with those objects.\n Another benefit of creating objects is that they allow the programmer to think on a new level of abstraction. Objects are represented as real-world nouns and can be given mehtods that describe the behavior the programmer is trying to represent.\n \n**Polymorphism:**\nPolymorphism refers to the ability of different objects to respond in different ways to the same message \n\nis the ability for data to be represented as many different types. \"Poly\" stands for \"many\" and \"morph\" stands for \"forms\". OOP gives us flexibility in using pre-wrtten code for new purposes.\n\none form of polymorphism is to **subclasses** which inherit from **superclasses**. This gives Ruby progreammers toe power to define the basic classes with large reusability and smaller **subclasses** for more fine-grained, detailed behariouss\n\n`modules` are also used to apply polymorphic structures to ruby.\n\nanother example of polymorphism:\n\n```\nclass Animal\n  def eat\n    # generic eat method\n  end\nend\n\nclass Fish < Animal\n  def eat\n    #eat specific to fishe\n  end\nend\n\nclass Cat < Animal\n  def eat\n     # eat implementation for cat\n  end\nend\n\ndef feed_animal(animal)\n  animal.eat\nend\n\narray_of_animals = [Animal.new, Fish.new, Cat.new]\n\nArray_of_animals.each do |animal|\n  feed_animal(animal)\nend\n\n```\n\nLooking at the above example, we can see that every object in the array is a different animal, but the client code cna treat them all as a generic animal, i.e., an object tat can eat. Thus the public interface lets us work with all of htese types in the same way even though the implemenations can be dramatically different.\n\n#### namespacing with modules\n\nnamespacign means orgainzing similar classes under a module. The first advantage of using modules for namespacing is that it becomes easy for us to recognize related classes in our code. Secondly it reduces the likelihood of our classes colliding with other simiarly named classes in our codebase. Here's how we do it:\n\n```\nmodule Mammal\n  class Dog\n    def speak(sound)\n      p \"#{sound}\"\n    end\n  end\n\n  class Cat\n    def say_name(name)\n      p \"#{name}\"\n    end\n  end\nend\n\n```\n\nwe call classes in a module by appending the class name to the module name with two coons(`::`)\n\n```\nbuddy = Mammal::Dog.new\nkitty = Mammal::Cat.new\nbuddy.speak('Arf!')  # => \"Arf!\"\nkitty.say_name('kitty') # => \"kitty\"\n\n```\n\nThe second use case for modules is using modules as a **container** for methods, called module methods. This involuves using modules to house other mehtods. Which is very useful for using mehtods that seem out of place within your code, example:\n\n```\nmodule Mammal\n  def self.some_out_of_place_method(num)\n    num ** 2\n  end\nend\n\n```\n\nDefining methods this way means that you can call them directly form the module:\n\n```\nvalue = Mammal.some_out_of_place_method(4)\n\n```\n\nor\n\n```\nvalue = Mammal::some_out_of_place_method(4)\n\n```\n\nalthough the former is preferred.\n\n\n Objects that are stored as state within another object are also called **collaborator objects**.\n \n the relationship that a collaboration creates is called **association**: which can be thought of as a has-a relatiohsip. For example, a library has books, so there is an ssoicative relationsip between objects of class Library and objects of class Book."
    }
  ]
}