{
  "title": "RB129 Study Notes",
  "cells": [
    {
      "type": "markdown",
      "data": "### Specific Topics of Interest\n\n### [] Classes and Obje=cts\n\n**Objects:** Anyyhing that can be said to have a value is an object: includingL numbers, strings, arrays, and even classes and modules. However there are a few things that are not objects: methods and blocks are tow that stand out.\n\nObjects are created from classes. Thin of classes as molds and objects as the things hyou produce out of those models. Individual objects will contain different information for other objects, yet they are instances of the same class.\n\n**classes:**\\* are used in ruby to define the attributes and behaviors of its objects. You can think of classes as basic outlines of what an objects should be made of and what is should be able to do.\n\n***instantiation:*** creating a new object of instance from a class. In the below example we can say that we'ved **instantiated** instanited an object called `sparky` from the class `GoodDog`.\n\nAn object is return by calling the class method `new`. Take a look at Figure 3.\n\n```\nclass GoodDog\nend\n\nsparky = GoodDog.new \n\n```\n\n#### states and behaviors\n\nWhen defining a class we typically focus on two things: **states** and **behaviors**. States track attributes for individual objects. Behaviors are what objecst are capable of doing.\n\nSay we want to create two `GoodDog` objects: one named \"Fido\" and one named \"Sparky\". They are both `GoodDog` objects, but may contain different informartion, such as name, wight , and height. We would use instance variables to track this information. \\*\\*This should tell you that instance variables are scoped at the object (or instance) level, and are how objects keep trackm of their states.\n\nEven though they're tow different objects, both are still objects (or instances) of class `GoodDog` and contain indentical behaviors. both `GoodDog` objects should be able to bark, run, fetch, and perform other common behaviors of good dogs. We define these behaviors as \\***instance methods** in a class. Instance methods defined in a class are available to objects (or instances) of that class.\n\n### [] Use `attr_*` to create setter and getter methods\n\nyou'll notice in examples below that getter and setter methods take up a lot of room in our program. If we had other states we wanted to track, the class would be even longer. Refactoring of the code in other examples below looks like this:\n\n```\nclass GoodDog\n  attr_accessor :name\n\n  def initialize(name)\n    @name = name\n  end \nend \n\nsparky = GoodDog.new(\"Sparky\")\nputs sparky.speak\nputs sparky.name            # => \"Sparky\"\nsparky.name = \"Spartacus\"\nputs sparky.name            # => \"Spartacus\"\n\n```\n\nThe `attr_accessor` method takes a symbol as an argument, which it uses to create the method name for the `getter` and `setter` methods.\n\nWhat if we want the `getter` method withoud the `setter` method. Then we would want to use the `attr_reader` method. If you only want the `setter` method you would use the `attr_reader` method.\n\n### [] How to call setter and getters\n\n#### getter methods\n\nIf we want to acess the object's name, which is stored in the `@name` instance variable, we have to create a mehtod that will return the name. We can call it `get_name`, and its ounly job is to return the value in the `@name` instance variable\n\n```\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end\n\n  def get_name\n    @name\n  end\nend\n\nsparky = GoodDog.new(\"Sparky\")\nputs sparky.get_name  #=> Sparky\n\n```\n\n#### setter methods\n\nwhat if we wanted to change `sparky's` name? That's when we reach for a setter method.\n\n```\nClass GoodDog\n  def initialize(name)\n    @name = name\n  end\n\n  def get_name\n    @name\n  end \n\n  def set_name = (name)\n    @name = name \n  end\nend\n\nsparky = GoodDog.new(\"Sparky\")\nputs sparky.get_name #=> Sparky\nputs sparky.set_name = \"Spartacus\"\nputs sparky.get_name #=> Spartacus\n\n```\n\nAs you can see, we've sucesfully changed `sparky`'s name to the string \"spartacus\". You should notice that ruby gives us a special syntax to us it. To use the `set_name=` method normally, we would expect to do this: `sparky.set_name=(\"Spartacus\")`. Ruby however recognizes that this is a *setter* method and allows us to use the more natural assignment syntax: `sparky.set_name = \"Spartacus\"` When we use this code, just realize there's a method called `set_name=` working behind the scenes, and we're just seeing some Ruby syntactical sugar.\n\nAs a convention Rubyists typically want to name thoe **getter** and \\**setter* methods using the same name as the instance variable they are exposing and setting. We'll make the change to our code as well:\n\n```\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end\n\n  def name\n    @name\n  end\n\n  def name=(n)\n    @name = n\n  end\nend\n\n```\n\n### [] Instance methods vs. class methods\n\n`initalize`: The `initialize` method gets called every time you creat a new object. That's odd, don't we call the `new` method when we creat and object? Yes calling the `new` class method eventually leads us to the initialize instance method. We refere to the `initialize` method as a ***constructor*** because it gets triggered whenver we create a new object.\n\nlet's create a new object and **instantiate** it with some state, like a name.\n\n```\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end\nend\n\n```\n\n`@name` is an **instance variable**, which can be differentiated by the `@` symbol in front. This is a variable that exists as long as the object instance exits and it is one of th ways we tie data to objects. In the above example, our `initalize` method takes a parameter called `name`. You can pass arguments into the `initialize` method through the `new` method. Let's creat an object using the `GoodDog` class form above:\n\n```\nsparky = GoodDog.new(\"Sparky\")\n\n```\n\nHere, the string \"Sparky\" is being passed from the `new` method through to the initalize method, and is assigned to the local variable `name`. Within the constructor (i.e., the `initialize` method), we then set the instance variable `@name` to `name`, which results in assigning the string \"Sparky\" to the `@name` instance variable.\n\nFrom the example, we see the instance variables are responsible for keeping track of information about the *state* of an object. In the above line of code, the name of the `sparky` object is the string \"Sparky\". This state for the object is tracked in the instance variable, `@name`. If we create another `GoodDog` object, for example, with `fido = GoodDog.new('Fido'), then the`@name`instance variable for the`fido` object would contain the string \"Fido\". Every objcet's state is unique, and instance variables are how we keep track.\n\n#### Instance Methods\n\n**Instance methods:** we define the behaviors of an object using instance methods. Instance methods defined in a class are availabel to objects (or instances) of that class. they are how we can expose information about the state of the object using instance methods.\n\n#### Class Methods\n\nclass methods are methods we can call directly on the class itself, without having to instantiate any objects.\n\nwhen defining a class mehtod, prepend the method name with the reserved word `self.`\n\n```\n\ndef self.what_am_i\n  \"I'm a GoodDog class!\"\nend\n\n```\n\nThen when we call the class mehtod, we us the class name `GoodDog` followed by the method name, without even having to instantiate any objects\n\n```\nGoodDog.what_am_i  #=>  I'm a GoodDog class!\n\n```\n\nClass methods are where we put functionality that does not pertain to individual objects. Objects contain state, and if we have a metod that does not need to deal with states, then we can just use a class method, like oour simple exampl.\n\n### [] Referencing and setting instance variables vs. using getters and setters\n\nwith getter and setter methods, we have a way to expose and cahnge an object's state. we can also use theses methods from within teh class as well. In th\u0010e previous section, the `speak` mehtod referenced the @name` isntace variable, like below:\n\n```\ndef speak\n  \"#{@name} says arf!\"\nend\n\n```\n\nInstead of we can called the `name` getter method\n\n```\ndef speak\n  \"3{name}  says arf!\"\nend\n\n```\n\nwhy do this? why not just reference the `@name` instance variable? Technically, you could, but it's generally a goood idea to call the *getter* method instead.\n\nan example of why it is better to reference the getter method is below, if you only want expose part of the instance variable that you are exposing for security reasons and you don't want to continuesly rewrite the thing such as below:\n\n```\ndef ssn\n  # converst '123-45-6789' to 'xxx-xx-6789'\n  'xxx-xx-' + @ssn.split('-').last\nend\n\n```\n\nAdditionally wherever we're changing the instance variable directly in our class, we should instead use the setter method. But there's a gotcha.\n\n```\nattr_accessor :name, :height, :weight\n\n```\n\nThis line of code gives us six getter/setter instance methods: `nam`, `name=`, `height`, `height=`, `weight`, `weight=`. It also gives us three instance variables: `@name`, `@height`, `@weight`. Now suppose we want to create a new method that allows us to change several states at once, called `change_info(n, h, w)`. The three arguments to the method correspond to the new name, height, and weight, respectively. We could implement it like this:\n\n```\ndef change_info(n, h, w)\n  @name = n\n  @height = h\n  @ weight = w\nend\n\n```\n\nwe can use the `change_infor` method like this:\n\n```\nsparky = GoodDog.new('Sparky', '12 inches', '10 lbs')\nputs sparky.info # => Sparky weights 10 lbs and is 12 incehs tall\n\nsparky.change_info('Spartacus', '24 inches', '45 lbs')\nputs sparky.infor   #=>  Spartacus weighs 45 lbs and is 24 inches tall\n\n```\n\nbut if we try to do this like we did with the getter method.\n\n```\ndef change_info(n, h, w)\n  name = n\n  height = h\n  weight = w\nend\n\n```\n\nThe above doesn't work because ruby thinks you are initialzing a local variable to point to the arguments being passed in. You will have to prepend each variable with `self` (ex, `self.name`, `self.weight`, `self.height`)\n\n### [] Class inhertiance\n\n\\***Inheritance:** The concept of inheritance is used in ruby where a class inherits the behaviours of another class, referred to as the **superclass**. This gives ruby programmers the power to define basic classes with large reusability and smaller **sublcasses** for more fine-grained, detailed behaviors.\n\n```\nclass Animal\n  def speak\n    \"Hello!\"\n  end\nend\n\nclass GoodDog < Animal\nend\n\nclass Cat < Animal\nend\n\nsparky =  GoodDog.new\npaws = Cat.new\nputs sparky.speak  # => Hello!\nputs paws.speak  # => Hello!\n\n```\n\nAbove we're extracting the `Speak` mehtod to a superclass `Animal`, and we use inheritance to make that behavior available to `GoodDog` and `Cat` classes.\n\nnote: If we add a `speak` instance method into any of the subclasses this will override the `speak` instance method defined in the `Animal` super class. This is because Ruby checks the object's class first for the method before it looks into the superclass.\n\nInheritance is a great way to remove duplicaiton in your code, there is an acronym \"Dry\" this stands for \"don't repeat yourself\". Which means that if you find yourself writing the logic over and over again in your programs, ehter are ways to extract the logic to one place for reuse.\n\n### Super\n\nRuy provides a built-in function called `super` that allows us to call methods up the inheritance hierarchy. Whne you call `super` from within a method, it seraches the inheritance hierarchy for a method by the same name and then invokes it.\n\nexample:\n\n```\nclass Animal\n  def speak\n    \"Hello!\"\n  end\nend\n\nclass GoodDog < Animal\n  def speak\n    super + \" from GoodDog class\"\n  end\nend \n\nsparky = GoodDog.new\nsparky.speak   # =>  \"Hello!  From GoodDog class\"\n\n```\n\nAnother more common way of using `super` is with `initailize`.\n\n```\nclass Animal\n  attr_accessor :name\n\n  def intialize(name)\n    @name = name\n  end\nend \n\nclass GoodDog < Animal\n   def initalize(color)\n     super\n     @color = color\n    end \nend\n\nbruno = GoodDog.new(\"brown\")  # => #<GoodDog:0x007fb40b1e6718 @color=\"brown\", @name=\"brown\">\n\n```\n\nIn above example `super` is used with no arguments. However, the `initalize` method, where `super` is being used, takes an argumetn. `super` automatically forwards the arguments that were passed to the method from which `super` is called (`initalize` method in `GoodDog` class). After this, `super` passes the `color` argument in the `initalize` defined in the subclass to that `animal` superclass and invokes it. which explains `@name = \"bronw\"` when the `bruno` instance is created.\n\nwhen called with specific arguments, eg. `super(a,b)` the specified arguements will be sent up the method lookup chain.\n\n```\nclass BadDog < Animal\n  def initalize(age, name)\n    super(name)\n    @age = age\n  end\nend\n\nBadDog.new(2, \"bear\")  # => #<BadDog:0x007fb40b2beb68 @age=2, @name=\"bear\">\n\n```\n\n### [encapsulation](https://launchschool.com/books/oo_ruby/read/the_object_model#whyobjectorientedprogramming)\n\n**Encapsulation:** Hiding pieces of functionality and making it unavailable to the rest of the code base. It is a form of data protection, so that data cannot be maipulated or changed withou obvious intention. It is what defines the boundaries in your application and allows your code to ahieve new levels of complexity. Ruby, like many other OO laguages, accomplishes this task by creating objects, and exposing interfaces (i.e. methods) to interact with those objects.\n Another benefit of creating objects is that they allow the programmer to think on a new level of abstraction. Objects are represented as real-world nouns and can be given mehtods that describe the behavior the programmer is trying to represent.\n\nEncapsulaiton lets us hide the internal represnation of an object from the outsidea nd only expose the methods and properties that users of the object need. We Expose these properties and methods through the public interface of a class: It's public mehtods\n\n### [polymorphism](https://launchschool.com/books/oo_ruby/read/the_object_model#whyobjectorientedprogramming)\n\n**Polymorphism:** is the ability for data to be represented as many different types. \"Poly\" stands for \"many\" and \"morph\" stands for \"forms\". OOP gives us flexibility in using pre-wrtten code for new purposes.\n\none form of polymorphism is to **subclasses** which inherit from **superclasses**. This gives Ruby progreammers toe power to define the basic classes with large reusability and smaller **subclasses** for more fine-grained, detailed behariouss\n\n`modules` are also used to apply polymorphic structures to ruby.\n\nanother example of polymorphism:\n\n```\nclass Animal\n  def eat\n    # generic eat method\n  end\nend\n\nclass Fish < Animal\n  def eat\n    #eat specific to fishe\n  end\nend\n\nclass Cat < Animal\n  def eat\n     # eat implementation for cat\n  end\nend\n\ndef feed_animal(animal)\n  animal.eat\nend\n\narray_of_animals = [Animal.new, Fish.new, Cat.new]\n\nArray_of_animals.each do |animal|\n  feed_animal(animal)\nend\n\n```\n\nLooking at the above example, we can see that every object in the array is a different animal, but the client code cna treat them all as a generic animal, i.e., an object tat can eat. Thus the public interface lets us work with all of htese types in the same way even though the implemenations can be dramatically different.\n\n### Polymorphism through duck typing:\n\nDuck typing in ruby cerns itself with what methods are available on the object. If an object \"quacks\" like a duck, then we can treat it like a duck.\n\nsee example [here](https://launchschool.com/lessons/dfff5f6b/assignments/8c6b8604) for duck typing.\n\n### [] Modules\n\n`Module`:\n\n**modules** are another way to apply polymorphic structure to Ruby programs. Modules are similar to classes in that they contain shared behavior. However, you cannot create an object with a module. A module must be mixed in with a class using the `include` method invocation. This is called a`mixin`. After mixing in a module, the behaviors declared in that module are available to the class and its objects.\n\nA **module** is a colleciton of behaviors that is usable in other classes via **mixins**. A module is \"mixed in\" to a class using the `include` method invocation. Let's say we wanted our `GoodDog` class to have a `speak` method but we have other classes that we want to use a speak method with too.\n\nA module allows us to group reusable code into one place. We use modules in our classes by using the `include` method invocation, followed by the module name. Modules are also used as a namespace.\n\nyou use modules when you want to add behaviors to only certain members of a hierarchy. For example if you have an `Animal` super class, and a variety of animals which subclass from that, only some of the can swim so instead putting a swim method into the `Animal` superclass you will want to create a `Swimable` module with a method `swim` which you can mix in with all individual sub classes that can swim. Note, a common naming convention for Ruby is to use the \"able\" suffix on whatever verb descirbes the behavior that the module is modeling. (`Swimmable`, `Walkable` etc).\n\n**a class can only sub-class from one parent but it can mix in as many doules as it likes**\n\n### [] inheritance vs Modules\n\nTwo primary ways Ruby implemetns inheritance are **Class inheritance** and **interface inheritance**. Interface inheritance is where one class doesn't inherit form anohter, but istead iherits the interface provided by the mixin module.\n\nHere are a couple things to consider when evaluating between using a **class inheritance** or **interface inheritance**:\n\n* you can only subclass (class inheritance) from one class. You can mix in as many modules as you'd like\n* If there's an \"Is-a\" rlationship, class inheritance is usually the correct choice. If there's a \"has-a\" relationship, interface inheriticance is gernearlly bette. Exampl, ad dog \"is an\" animal and it \"has an\" ability to swim.\n* you cannot instantiate modules (no object can be created from a module). Modules are only used for namespacing and grouping common methods together.\n\n### - [] Method lookup path\n\nWe can use the `ancestors` method on any class to find out the method lookup chain:\n\n```\nmodule Speak\n  def speak(sound)\n    puts \"#{sound}\"\n  end \nend\n\nclass GoodDog\n  include Speak\nend\n\nclass HumanBeing\n  include Speak\nend\n\nputs  \"---GoodDog ancestors---\"\nputs GoodDog.ancestors\nputs ''\nputs \"---HumanBeing ancestors---\"\nputs HumanBeing.ancestors\n\n```\n\nThe output looks like this\n\n```\n---GoodDog ancestors---\nGoodDog\nSpeak\nObject\nKernel\nBasicObject\n\n---HumanBeing ancestors---\nHumanBeing\nSpeak\nObject\nKernel\nBasicObject\n\n```\n\n#### Method look up path inheritance, and modules\n\nlets take a look at the below example:\n\n```\nmodule Walkable\n  def walk\n    \"I'm walking.\"\n  en\nend\n\nmodule Swimmable\n  def swim\n    \"I'm swimming.\"\n  end\nend\n\nmodule Climable\n  def climb\n    \"i'm climing.\"\n  end\nend\n\nclass Animal\n  include Walkable\n\n  def speak\n    \"i'm an animal, and i speak!\"\n  end\nend \n\n```\n\n```\nputs \"---Animal method lookup---\"\nputs Animal.ancestors\n\n```\n\noutput will look like this:\n\n```\n---Animal method lookup---\nAnimal\nWalkable\nObject\nKernal\nBasicObject\n\n```\n\nlets add another class to the code above.\n\n```\nclass GoodDog < Animal\n  include Swimmable\n  include Climable\nend\n\nputs \"---GoodDog mehtod lookup---\"\nputs GoodDog.ancestors\n\n```\n\noutput looks like:\n\n```\n---GoodDog method lookup---\nGoodDog\nClimmable\nSwimmable\nAnimal\nWalkable\nObject\nKernel\nBasicObject\n\n```\n\nTjos shows us that **the order in which we include modules is important** Ruby actually looks at the last module we included *first*. this means that in the rare occurrence that the modules we mix in contain a method with the same name, the last module included will be consulted first. Second interesting thing, is that the module included in the superclass made it on the method lookup path. That means that all `GoodDog` objects will have access to not only `Aniaml` mehtods, but also methods defined in modules mixed in to the animal class (`walkable` module)\n\n#### namespacing with modules\n\nnamespacign means orgainzing similar classes under a module. The first advantage of using modules for namespacing is that it becomes easy for us to recognize related classes in our code. Secondly it reduces the likelihood of our classes colliding with other simiarly named classes in our codebase. Here's how we do it:\n\n```\nmodule Mammal\n  class Dog\n    def speak(sound)\n      p \"#{sound}\"\n    end\n  end\n\n  class Cat\n    def say_name(name)\n      p \"#{name}\"\n    end\n  end\nend\n\n```\n\nwe call classes in a module by appending the class name to the module name with two coons(`::`)\n\n```\nbuddy = Mammal::Dog.new\nkitty = Mammal::Cat.new\nbuddy.speak('Arf!')  # => \"Arf!\"\nkitty.say_name('kitty') # => \"kitty\"\n\n```\n\nThe second use case for modules is using modules as a **container** for methods, called module methods. This involuves using modules to house other mehtods. Which is very useful for using mehtods that seem out of place within your code, example:\n\n```\nmodule Mammal\n  def self.some_out_of_place_method(num)\n    num ** 2\n  end\nend\n\n```\n\nDefining methods this way means that you can call them directly form the module:\n\n```\nvalue = Mammal.some_out_of_place_method(4)\n\n```\n\nor\n\n```\nvalue = Mammal::some_out_of_place_method(4)\n\n```\n\nalthough the former is preferred.\n\n### - [] self\n\n#### [calling methods with self](https://launchschool.com/books/oo_ruby/read/classes_and_objects_part1#callingmethodswithself)\n\n#### [More about self](https://launchschool.com/books/oo_ruby/read/classes_and_objects_part2#moreaboutself)\n\n`self` can refer to different things depending on where it is used.\n\nFor example, so far we've seen two clear use clases for `self`:\n\n1. Ue `self` when calling setter methods from within the class. In our earlier eaxmple we showed that `self` was necessary in order for our `change_info` mehtod tow work, allowing ruby to disambiguate between initializing a local variable and calling a setter mehtod.\n2. us `self` for class method definitiosn.\n\n```\n\nclass GoodDog\n\n# ... rest of code omitted for brevity\n\n  def what_is_self\n    self\n  end\nend\n\n```\n\nNowe we can instatiate a new `GoodDog` object.\n\n```\n\nsparky = GoodDog.new ('Sparky', '12 inches', '10 lbs')\n\np sparky.what_is_self\n# => #<GoodDog:0x007f83ac062b38 @name=\"Sparky\", @height=\"12 inches\", @weight=\"10 lbs\">\n\n```\n\nfrom within the class, when an instance method uses `self`, it references the *calling object*. Therefore, from within the `change_info` method, calling `self.name=` acts the same as calling `sparky.name=` from oustide the class ( you can't call `sparky.name=` inside the class, thoguh since it sin't in scope`.\n\nthe other place we use `self` is when we're defining class methods, like this:\n\n```\nclass MyAwesomeClass\n  def self.this_is_a_class_method\n  end\nend \n\n```\n\n`self` inside a class but outside an instance method refers to the class itself. Therfore, a method def prefixed with `self` is the same as defining the method on the class. `def self.a_method` is equivalent to `def GoodDog.a_method`\n\nto clarify, from within a class...\n\n1. `self`, inside of an instance method, references the instance (object) that called the method - the calling object. Therefore, `self.weight=` is the same as `sparky.weight=`, in our example.\n2. `self`, outside of an instance method, references the class and can be used to define class methods. There `def self.name=(n)` is the same as `def GoodDog.name=(n)`, in our example.\n\nThus we can see that `self` is a way of being explicit about what our program is referencign adn what our intentions are as far as behavior. `self` changes depending on the scope it is used in, so pay attention to see if yoou're inside an instance method or not.\n\n* [] Readding OO code\n\n\n### INSPECT (LOOK UP DEFINITION OF THIS)\n\n### [] Fake operators and equality\n\n#### Fake Operators\n\n![fake_operators.png](quiver-image-url/36C773E313D16AB760536DB2DA4E736E.png =919x611)\n\n\n***equivalence***\n\n#### Summary\n\n`==`\n\n* for most objects, the `==` operator compares the values of the objects, and is frequently used.\n* the `==` operator is actually a method. Most built-in Ruby classes, like `Array`, `String`, `Integer`, etc override the `==` mehtod to specify how to compare objects of those classes.\n* by defauls, `BasicObject#==` does not peform an equality check; instead, it returns true if two objects are the same object. This is why other classes often override the behavoir of `#==`.\n* if you need to compare custom objects, you should override the `==` method.\n\n`equal?`\n\n* the `equal?` method goes one level deeper than `==` and determines whether two variables not only have the same value, but also whether they point to the same object\n* do not override `equal?`\n* the `equal?` method is not used very often\n* calling `object_id` on an object will return the object's unique numerical value. Comparing two objects' `object_id` has the same effect as comparing them with `equal?`\n\n`===`\n\n* used implicitly in `case` statements.\n* like `==` the `===` operator is actually a method\n* you rearely need to call this mehtod explicitly, and only need to implement it in your custom classes if you anticipate your objects will be used in `case` statemetns, which is probably pretty rare.\n\n`eql?`\n\n* used implicity by `Hash`\n* very rarely used explicity.\n\nwith equivalence comparision `==` we are asking \"are the values within the two objects the same?\" and not \"are the two objects the same?\" \\*\\*the `==` method is not an operator, but is actually an instance method available on all objects. however ruby gives it special syntax to make it look like a noraml operator.\n\nexample:\n\n```\nstr1 = \"something\"\nstr2 = \"something\"\n\nstr1 == str1   # => true \n\n```\n\nhowever\n\n```\nstr1 = str1 + \" else\"\nstr1\n\nstr1 == str2  # => false \n\n```\n\nnow you can comapre the actual string objects, not just the values using the `equal?` method\n\nin summary, the `==` mehtod compares the two variables' values wheras the `equal?` method determines whether the two variabls point to the same object.\n\nSicne it's and instance method, Ruby knows what value to use for comparison based on its class.\n\nThe orginal `==` method is defined in `BasicObject` which is the parent class for all classes in ruby.\n\nThe default implemenation for `==` is the same as `equal?`, it compares the two object ids, so if you make a custom class you need to overide the default implementation.\n\n`<` and `>` are also instance methods and can be overriden similarly to `==`.\n\nRuby core library classs will come with its own `==` method. You can safely use `==` to compare `Array`, `Hash`, `Integer` and `String`.\n\nunlike `Array`, `string`, `hash`, `symbol`s and `integer`s if two symbols or two integers have the same value, they are also the same object. This is a performance optimization in Ruby, because you can't modify a symbol or integer. This is also why Rubyists prefer symbols over strings to act as hash key, it's a slight optimization and saves on memory. example:\n\n```\narr1 = [1, 2, 3]\narr2 = [1, 2, 3]\n\nsym1 = :something\nsym2 = :something \n\nsym1.object_id == sym2.object_id   # => true\n\nint1 = 5\nint2 = 5\nint1.object_id == int2.object_id  # => true \n\n```\n\n#### `===` instance method\n\n`===` is used implicitly by the `case` statement\n\nThe `===` method does not compare two objects the same way that `==` does. basically the `===` takes a look at the calling object and compares it to the argument being passed in, and says does this argument belong to the same group ex:\n\n```\n\n(1..5) === 3   # => true\nString === \"hello\"  # => true\nString === 14 # => false\n\n```\n\n#### `eql?`\n\n`eql?` compares if tow objects contain the same value and if they're of the same class.\n\n* [] truthy\n\nruby has to decide wheteher values count as true or false. If the value isn't literally \"ture\" but evaluates as true, we call it \"turthy\".  Likewise, if the values isn't literally \"false\" but evaluates as false, we call it \"falsey\".  A truthy value is truthy, evaulates to true, but you can't say \"is true\" unless it is literally 'true'.  All values are truthy, or evaluate to true, other than `nil` an `0`\n\n### [] Working with collaborator objects\n\nInstance variables can be set to anyy object, even an object of a custom class we've greated.\n Objects that are stored as state within another object are also called **collaborator objects**.\n\ncollaborator objects play an important role in object oriented design, since they also represent the connections between various actors in your pgrogram.\n\nthe relationship that a collaboration creates is called **association**: which can be thought of as a has-a relatiohsip. For example, a library has books, so there is an ssoicative relationsip between objects of class Library and objects of class Book.\n\n# NOT ASSESMENT SPECFIC TOPICS\n\n### Class Variables\n\nJust as instance variables capture inforamtion related to specific instances of classes (i.e., objects), we can create variables for and entire class that are apporiately called **class vairables**, which are created using two `@` symbols (`@@`). Let's create a class variable and a class method to view that variable.\n\n```\nclass  GoodDog\n  @@number_of_dogs = 0\n\n  def intialize \n    @@number_of_doges += 1\n  end\n\n  def self.total_number_of_dogs\n    @@number_of_dogs\n  end\nend\n\nputs GoodDog.total_number_of_dogs # => 0\n\ndog1 = GoodDog.new\ndoge2 = GoodDog.new\n\nputs GoodDog.total_number_of_dogs # => 2\n\n```\n\nabove we have a class variable called `@@number_of_dogs`, which we initalize to 0\\. Then in our constructor (the `initalize` method), we increment the the number by 1\\. Rememeber that `initalize` gets called every time we instantiate a new object via the `new` mehtod. This also demonstrates that we can access class variables from within a instance method (`initialize` is an instance method). Finally, we just return the value of the calss variable in the class mehtod `self.total_number_of_dogs`. This is an example of using a class varialbe and a class mehtod to keep track of a class level detail that pertains only to the class, and not to individual objects.\n\n### Constants\n\nWhen creating classes there may be vairables that you never want to change. This can be done by creating **constants**.\n\nWhile technically constants just need to begin with a capital letter, most Rubyist will make the entire variable uppercase.\n\n### Variable scope\n\n#### Instance Variable Scope\n\nInstance variables are variables that start with `@` and are scoped at the object level. They are used to track individual object state, and do not cross over between objects.\n\nBecause the scope of instance variables is ath the object level, this means that the instance variable is acessible in an object's instance method, even if it's intialized outside of that instance method.\n\nexample:\n\n```\nclass Person\n  def initialize(n)\n    @name = ne\n  end \n\n  def get_name\n    @name    # is the @name instance variable accessible here?\n  end\nend\n\nbob = Person.new('bob')\nbob.get_name   # => \"bob\"\n\n```\n\nUnlike local variables, instance variables are accessible within an instance method even if htey are not initialized or passed in to the method. Remember, their scope is at the **object level**.\n\nwhat if we try to acess an instance variable that is not yet initlized anywhere?\n\n```\nclass Person\n  def get_name\n    @name\n  end\nend\n\nbob = Person.new\nbob.get_name # => nil \n\n```\n\nthis shows another distinction form local variables. If you try to reference and uninitialized local variable, you'd get a `NameError`. But if you try to reference an uninitialized instance variable, you get `nil`.\n\nwhat happens if you accidentally put an instanve varialble at the class level?\n\n```\nclass Person\n  @name = \"bob\"\n\n  def get_name\n     @name\n  end\nend\n\nbob = Person.new\nbob.get_name   # => nil \n\n```\n\nthe short answer is: don't do that for now. The long ansewr is that instanve varialbles intialized at the class level are an entirely different thign called class instanve variables. You shouldn't worry about that yet, but just remember to initialize instance variables wiithin instance methods.\n\n#### Class Variable Scope\n\nClass variables start with `@@` and are scoped at the class level. They exhibit two main behaviors:\n\n* all objects share 1 copy of the class variable. (This also impolies objects can access class variables by way of instance methods.)\n* class methods can access class variables, regardless of where it's initialzed.\n\n```\n\nclass Person\n  @@total_people = 0   # initialized at the class leve\n\n  def self.total_people \n    @@total_people      # accesible from class method\n  end\n\n  def intialize\n    @@total_people += 1    # mutable form instance method\n  end\n\n  def total_people\n    @@total_people    # acessible from instance method \n  end\nend\n\nPerson.total_people   # => 0\nPerson.new\nPerson.new\nPerson.total_people   # => 2\n\nbob = Person.new\nbob.total_people   # => 3\n\njoe = Person.new\njoe.total_people     #=> 4\n\nPerson.total_people    #=> 4\n\n```\n\n### Constant Variable Scope\n\nconstants are usually created in all caps. within one class the rules for constants are pretty easy: It's available in class methods or instance methods (which implies it's acessible form objects)\\_. When inheritance is involved COnstants behave unlike other variables because of the lexical scope.\n\n### inheritance and variable scope\n\nSUMMARY:\n\n**Instance Variables:** behave the way we'd expect, the only thing to watch out for is to make sure the instance variable is initalized before referencing it\n\n**Class Variables** have a very insiduious behavior of allowing sub-classes to override super-class class variables. Further the change will affect all other sub-classes of the super class. This is unituitive and some poepl don't use\n\n**Constnats** have lexical scope which makes their scope resolution rules very unique compared to other vairable types. If RUby doens't find the constnat using lexical scope, it'll then look at the inheritance hierarchy.\n\n#### inheritance and Instance Variable scope\n\nfirst, we'll look at how sub-classing affects instance variables.\n\n```\nclass Animal\n  def initialize(name)\n    @name = name\n  end \nend\n\nclass Dog < Animal\n  def dog_name\n   #{@name}   # @name CAN be referenced here\n  end\nend\n\n```\n\ninscatance varialbels don't really exhibit any surprising behavior. They behave very similar to how instance methods would.They behave very similare ot how instance methods would, with the seception that we must first call the method that initializes the instance variable.\n\n#### inhertiance and Class Variable scope\n\n```\nclass Animal\n  @@total_animals = 0\n\n  def intialize\n    @@total_animals += 1\n  end\nend\n\nclass Dog < Animal\n  def total_animals\n    @@total_animals\n  end\nend\n\nspike = Dog.new\nspiek.total_animals    # => 1\n\n```\n\n#### inheritance and Constant scope\n\n```\n\nclass Dog\n  LEGS = 4\nend\n\nclass Cat\n  def legs\n    LEGS\n  end\nend\n\nkitty = Cat.new\nkitty.legs   # => NameError:  Unitiaalized constant Cat::LEGS\n\n```\n\nThe errror occures here because RUby is lookinf for `LEGS` within the `Car` class. This is expected, since this is the same behavior as class or instance variables (\u0010except, referecning an uninitalized instance variable will return `nil`).\n\nbut you can acess Constants form other classes\n\n```\nclass Dog\n  LEGS = 4\nend\n\nclass Cat\n  def legs\n    Dog::LEGS\n  end\nend \n\nkitty = Cat.new\nkitty.legs    # => 4\n\n```\n\nsidenote: you can use `::` on classes, modules or constants. We'll talk more about namespacing calasses and modules in the future.\n\npretty expected behavior, class variabls are accesible to sub-classes.\n\nBecause there is one copy of hte calss variable across all sub-classes, working with class variables can be dangerious in the context of inheritiances. This is because you can reassigned the class variable in a sub class and it will reassign it for all classes (super and other sub classes)\n\n**For this reason, avoid using calss variables when working with inheritance, come rubyist recommend avoiding class variables all together**\n\n#### Constants\n\nCan we reference a constant defined in a different class?\n\n```\nclass Dog\n   LEGS = 4\nend\n\nclass Cat\n  def legs\n    LEGS\n  end\nend\n\nkitty = Cat.new\nkitty.legs   #=> NameError: unitialized constant Cat::LEGS\n\n```\n\nBut unlike instance variables, we can actually reach into the `Dog` class and reference the `LEGS` contant. using `::` which is hte namespace resolution operator\n\n```\nclass Dog\n  LEGS = 4\nend\n\nclass Cat\n  def legs\n    Dog::LEGS\n  end\nend\n\nkitty = Cat.new\nkitty.legs    # => 4\n\n```\n\nsidenote: you can use `::` on classes modules or constants.\n\nA sontant initialized in a super-class is inherited by the sub-class, and can be accessed by both classes adn instance methods. However it changes abit when you mix in modules:\n\n```\nmodule  Maintenance\n  def change_tires\n    \"Changing #{WHEELS} tires.\"\n  end\nend\n\nclass Vehicle\n  WHEELS = 4\nend\n\nclass Car < Vehicle\n  include Maintenance\nende\n\na_car = Car.new\na_car.change_tires   # =>  NameError:  uninitialized constant Maintenance:: WHEELS\n\n```\n\nruby doesn't know where to look for the `WHEELS` contant so you can fix like this\n\n```\nmodule Maintenace\n  def change_tires\n    \"Changing #{Vehicle::WHEELS} tires.\"\n  end \nend\n\n```\n\nor\n\n```\nmodule Maintenace\n  def change_tires\n    \"changing #{Car::WHEELS} tires.\"  \n  end\nend\n\n```\n\nConstant resoltion will look at lexical scope first, and the look at the inheritance hierarchy.\n\n### puts vs p\n\nputs calls the intance method `to_s` on the object it is being called on. the `to_s` instance method comes built in to every class in RUBY. By default, `to_s` method returns the name of the object's class and an encondoing of the object ID.\n\n`puts` method calls `to_s` for any arguement that is not an array. For an array, it writes on separate lines the results of calling `to_s` on each element of the array.\n\n`p` is very simlar to `puts` except it doesn't call `to_s` on its argument, it calls another built-in Ruby instance called `inspect`. The `inspect` method is very helpful for debugging purposes, so we dont' override it. `p sparky` is equivalent to `puts sparky.inspect`\n\nanother important attribute of the `to_s` method is that it's automatically called in string interpolation. \"\\#{instance\\_method}\"\n\nSummary: the `to_s` method is called automatically on the object when we use it with `puts` or when used with strign interpoaltion.\n\n### private, Protected and public\n\n#### private\n\nsomtimes you'll have methods taht are doing work in a class but do not need to be avilable to the rest of the program. These methods can be defined as **private**. to do these we use the `priavt` method call in our program and anything below it is private (unlless another method , like `protected` is called after it to negate it).\n\nnote that you cannot use `self.private_method` within a class because it is equivalent to `object.private_method` which is not allowed, it would just have to be called like `private_method`. In suammary, private methods are not acessible outside of hte calss defintion at all, and are only accessible from inside the class when called without `self`. (but apparently this is now legal since ruby 2.7)\n\n### protected\n\nthe easises way to understand protuect methods is to follow these two rules:\n\n* form insdie the class, `protected` methods are accessible just like `public` methods\n* from outsdie the classe, `protected` methods act just like `private` methods\n\nexample:\n\n```\nclass Animal\n  def a_public_method\n    \"Will this work?\"  + self.a_protected_method\n  end\n\n  protected\n\n  def a_protected_method\n    \"Yes, I'm protected!\"\n  end\nend\n\n```\n\n### Precision of Language\n\nsome questions require that you explain code or concepts with words.  I'ts important to explain hbow code works using precise vocabulary and to pinpoint the causal mechanism at work. In other words, us the righ words and don't be vague.\n\nFor example, let's take the following piece of code.\n\n```ruby\n\nclass Dog\n  def initialzie(name)\n    @name = name\n  end\n\n  def say_hello\n    puts \"Woof! My name is #{@name}.\"\n  end\nend\n\n```\n\nIf we ask you to describe this code, you may say that \"It defins a `Dog` class with two methods: an initializer and a mehtod that has a message as a result.\" This description isn't wrong, but it's imprecise and lcaks some essential details. An answer like this may receive a score of 5/10 on a 10-point question; 50% is not a passing score.\n\nA more precise answer says that \"This code defines a `Dog` class with two methods:\n\n* the `#initialize` method that initializes a new `Dog` object, which is does by assigning the instance variable `@name` to the do's name specified by the argument.\n* The `#say_hello` instance method which prints a message that includes the dog's name in place of `#{@name}`. `#say_hello` returns `nil`.\n\nIn programing, we must always concern ourselves with outputs, return value, and object mutations. we must use the right terms when we speak, and not use vague words like \"results\". Furhtermore, we need to be explicit about even the smallest details.\n\nWhen writing answers to test questions, make sure you're as precise as poissible, and that you use the proper vocabulary. Doing this helps you debug and understand more complex code later in your journey. If your definations are imprecise, you can't use them to decompose a complicated mehtod or program. Also, you may be unable to pass the test.\n\n### Additional tips\n\nThis assesment has a different style thant the RB109 written assessment, so you should expect severl open-ended questions where you will need to explain certain OOP concepts using code examples.\n\nWhile working through the assessment questions it is useful to run your code often to check it, so make sure to have either ruby document/terminal or oline repl prepared beforehand."
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}