{
  "title": "RB120 Notes masterÂ ",
  "cells": [
    {
      "type": "markdown",
      "data": "##Lesson 2 Object Oriented Programming \n\n###Polymorphism \n**Polymorphism** refers to the ability of different objects to respond in different ways to the same message (or method invocation).\n\nThere are several ways to implement polymorphism \n\n####Polymorphism through inheritance \n\n```ruby\n\nclass Animal\n  def eat\n    # generic eat method\n  end\nend \n\nclass Fish < Animal\n  def eat\n    # eating specific to fish\n  end \nend\n\nclass Cat < Animal \n  def eat\n    # eat implementation for cat\n  end\nend \n\ndef feed_animal(animal)\n  animal.eat \nend\n\narray_of_animals = [Animal.new, Fish.new, Cat.new]\n\narray_of_animals.each do |animal|\n  feed_animal(animal)\nend\n\n```\n\n####Polymorphism through ducking type \n\nwe can implement polymorphism through **duck typing**.  \n\n*Duck typing* doesn't concern itself with the class of an object; instead, it concerns itself with what methods are available on the object.  If an object \"quacks\" like a duck, then we can treat it like a duck.\n\nthe example below attmepts to implemetn polymorphic behavior without using duck typing. **this is how not to do it**. \n\n```ruby\n\nclass Wedding \n  attr_readr :guests, :flowers, :songs\n  \n  def prepare(preparers)\n    prepares.each do |preparer|\n      case preparer\n      when Chef\n        preparer.prepare_food(guests)\n      when Decorator\n        preparer.decorate_place(flowers)\n      when Musician\n        preparer.prepare_performance(songs)\n      end \n    end\n  end\nend \n\nclass Chef\n  def prepare_food(guests)\n    # implementation \n  end \nend \n\nclass Decorator\n  def decorate_place(flowers)\n    #implementation\n  end \nend \n\nclass Musician\n  def prepare_performance(songs)\n    #implementation\n  end\nend \n```\n\nThe problem with this approach is that the `prepare` method has too many dependencies.  It relies on specific classes and their names.  It also needs to know which method it should call on each of the objects, as well as the argument that those methods require. If you change anything within those classes that impaces `Wedding#prepare` you need to refactor the method. \n\nnow refactored this code using `duck typing`.\n\n\n```ruby \nclass Wedding\n  attr_reader :guests, :flowers, :songs \n  \n  def prepare(preparers)\n    preparers.each do |preparer|\n      preparer.prepare_wedding(self)\n    end \n  end\nend\n\nclass Chef\n  def prepare_wedding(wedding)\n    prepare_food(wedding.guests)\n  end\n  \n  def prepare_food(guests)\n    #implementation \n  end\nend\n\nclass Decorator \n\n  def prepare_wedding(wedding)\n    decorate_place(wedding.flowers)\n  end\n  \n  def decoreate_place(flowers)\n    #implementation\n  end\nend\n\nclass Musician\n  def prepare_wedding(wedding)\n    prepare_performnace(wedding.songs)\n  end\n  \n  def prepare_performance(songs)\n    #implementation\n  end\nend \n      \n```\n\nWe can see that there is no inheritance in this example but we can still have polymoprhism. Each class must define a `prepare_wedding` method and implement it in its own way.  If we must add another preparer, we can create another class and just implement `prepare_wedding` to perform the appropriate actions. \n\n####Encapsulation \n\nEncapsulation lets us hide the internal representation of an object from the outside and only expose the methods and properties that the users of the object need. We expose these properties and methods through the public interface of a class: its public methods.\n\nexample:\n\n```ruby\n\nclass Dog\n\n  attr_reader :nickname\n  \n  def initialize(n)\n    @nickname = n\n  end \n  \n  def change_nickname(n)\n    self.nickname = n\n  end \n  \n  def greeting\n    \"#{nickname.capitalize} says Woof Woof!\"\n  end \n  \n  private \n    attr_writer :nickname \nend \n\ndog = Dog.new(\"rex\")\ndog.change_nickname(\"barny\") # changed nickname to \"barny\"\nputs dog.gretting #Displays: Barny says Woof Woof!\n\n```\n\nIn this example, we can change the nickname of a dog by calling the `change_nickname` method without needing to know how the `Dog` class and this method are implemented. \n\nNote that the `setter` method for `nickname` is private: it is not available outside of the class and `dog.nicknae = \"barny\" would raise an erro.\n\nHowever, even though the setter method for `nickname` is private we are still calling it with `self` prepended on line `9`, `self.nickname = n`.  **This is an exception in Ruby.  You need to use `self` when calling private setter methods as if you didn't use `self` Ruby would think you are creating a local variable**. \n\nkeep in mind, that the as class should have as few public methods as possible.\n\n####collaborator_objects\n\nInstance variables can hold any object, not only strings and integers.  It can hold data structures, like arrays or hashes.  Here's an example. \n\n```ruby \n\nclass Person\n  def initialize \n    @heros = ['Superman', 'Spiderman', 'Batman']\n    @cash = {'ones' => 12, 'fives' => 2, 'tens' => 0, 'twenties' =>, 'hundreds' =>0}\n  end \n  \n  def cash_on_hand\n     # this method will use @cash to calculate total cash value \n     # we'll skip the implementation \n  end\n  \n  def heroes \n    heroes.jion(', ')\n  end \nend \n\njoe = Person.new \njoe.cash_on_hand # => \"62.00\"\njoes.heroes  # => \"Superman, Spiderman, Batman\"\n\n```\n\nInstance variables can be set to any object, even an object of a custom class we've created.  Suppose we have a `Person` that has a `Pet`. We could have a class like this:\n\n\n``` ruby \nclass Person \n attr_accesor :name, :pet\n \n def initialize(name)\n   @name = name \n end \nend\n\nbob = Person.new(\"Robert\")\nbud = Bulldog.new #assume Bulldog class from previous assignment \n\nbob.pet = bud \n \n```\n\nThis last line is something new and we haven't seen that yet, but it's perfectly valid OO code.  We've essentially set `bob`'s `@pet` instance variable to `bud`, which is a `Bulldog` object.  This means that when we call `bob.pet`, it is returning a `Bulldog` object. \n\n```ruby\nbob.pet                       # => #<Bulldog:0x007fd8399eb920>\nbob.pet.class                 # => Bulldog\n```\nbecause `bob.pet` returns a `Bulldog` object, we can then chain any `Bulldog` methods at the end as well:\n\n```ruby\n  bob.pet.speak   # => \"bark!\"\n  bob.pet.fetch  # => \"fetching!\" \n```\n\nObjects that are stored as state within another object are also called \"collaborator objects\".  We call such objects collaborators because they work in work in conjunction (or collaboration) with the class they are associated with.  For instance, `bob` has a collaborator object stored in the `@pet` variable.  When we need the `BullDog` object to perform some action (i.e. we want to acess some behavior of @pet), then we can go through `bob` and call the method on the object stored in `@pet`, such as `speak` or `fetch`. \n\nWhen we work with collaborator objects, they are usually custom objects (e.g. defined by the programmer and not inherited from the Ruby core library); `@pet` is an example of a custom object.  Yet, collaborator objects aren't strictly custom objects.  Even the string object xtored in `@name` within `bob` in the code above is technically a collaborator object. \n\nCollaborator objecst play an important role in object oriented design, since they also reporesnt the connections between various actors in your program.  When working on an object oriented program be sure to consider what collaborators your classes will have and if those associations make sense, both form a tehcnicall stanpoint and in terms of modeling the problem your program aims to solve. \n\nNext, let's develop our program some more and change the impolementation a bit to allow a person to have many pets. How should we implement this?  How about an array of pets -- that is an array of `Pet` objects\n\n\n```ruby\nclass Person \n  attr_accessor :name, :pets\n  \n  def initialize(name)\n    @name = name\n    @pets = []\n  end \nend\n\nbob = Person.new(\"Robert\")\n\nkitty = Cat.new \nbud = Bulldog.new \n\nbob.pets << kitty\nbob.pets << bud \n\nbob.pets  # => [#<Cat:0x007fd839999620>, #<Bulldog:0x007fd839994ff8>]\n```\n\nnotice the opending and closing square brackets -- that means this is an array.  YOu can see that the first element in the array is a `Cat` object while the second element is a `Bulldog` object.   Because it's an array, you cannot just call `Pet` methods on `pets`:\n\n```ruby \nbob.pets.jump # NoMethodError: undefined method `jump' for [#<Cat:0x007fd839999620>, #<Bulldog:0x007fd839994ff8>]:Array\n```\n\nThere is no `jump` method in the `Array` class, so we get an error.  if we want to make each individual pet jump, we'll have to parse out the elements in the array and operate on the individual `Pet` object.  HEre' well just iterate throug the array. \n\nbob.pets.each do |pet|\n  pet.jump\nend \n\n####lecture modules \n\n##Coding Tips \n\n- Explore the problem before design.\n  Take time to explore the problem doamin with a *spike* - exploratory code to play around with the problem.  Spikes and help validate intial hunches and hypotheses. you don't have to worry about code quality, becasue the idea of as spikes is to throw away the code.   As you start to understand the probelm better and get a feel for possible solutions, start to organize your code into coherent classes and methods. \n\n- repetivie nouns in method names is a sign that you're missing a class. \n\n- when naming methods, don't include the class name\n\n```ruby\n\nclass Player \n  def player_info \n   # return players name, move and other data\n  end\nend \n\n```\n\nhowever it would be better if we just named the method `info` because for example \n\n```ruby\n\nplayer1 = Player.new\nplayer2 = Player.new \n\nputs player1.player_info\nputs player2.player_info \n\n```\nabove reads alot worse than below\n\n```ruby \nplayer1 = Player.new\nplayer2 = Player.new \n\nputs player1.info\nputs player2.info \n```\n\n- Avoid long method invocation chains:\n\nwhen working with OOP its tempting to keep calling methods on collaborator objects. Take the following code:\n\n```ruby\nhuman.move.display.size\n```\nThis is a 3 chain method invocation, and is very fragile. For example if `human.move` returns `nil` then the entire method invocation chain blows up and its hard to debug the error. \n\nThere are many strategies to deal with this type of thing, for now try to think about the smell of the code, and the possibility of `nil` or other unexpected return values in the middle of the chain. you could put in a guard clause to help to help with this.  If you've identified that that human.move could possibly return `nil` you could puts some guard expression in like this. \n\n``` ruby\nmove = human.move\nputs move.display.size if move\n```\n\n-avoid design patterns for now \n \n##CRC cards\n\nClass Responsibility Collaborator cards started out as a teaching tool to design classes and map interactions between classe. but is now a real world tool.\n\nHow to use:\n\n1. write a description of the problem and extract major nouns and verbs.\n\n2. make an initial guess at organizing the verbs and nouns into methods and classes/modules, then do a spike to explore the problem ith temporary code.\n\n3. when you have a better idea of ther problem, model your thoughts in CRC cards. \n\nhere's a component of CRC card:\n\n![IMAGE](quiver-image-url/BEF14F3C08543EE920CCEF44A36DE457.jpg =390x230)\n\nBelow is an example of the CRC card for the `Human` card: \n\n![IMAGE](quiver-image-url/B446EB10D952FD071FBAA0C6144D672B.jpg =391x234)\n\nif we create a CRC card for all classes in the RPS game we have a CRC model:\n\n![IMAGE](quiver-image-url/4541780EB56502DA97EA95F911ACA7CE.jpg =1215x552)\n\nfinally we have CRC card for the `RPSGame` class:\n\n![IMAGE](quiver-image-url/4541780EB56502DA97EA95F911ACA7CE.jpg =1215x552)\n\n## Lesson 3 Notes\n\n### Equivalence\n\nwhen you compare using `==`\n\n``` ruby \nstr1 = \"something\"\nstr2 = \"somehting\"\n\nstr1 == str2   # => true\n```\n\nhowever these are two different objects, somehow the `==` knows how to compare their values even though they are different objects. What we're asking is \"are the values within the two objects the same?\" and not \"are the two objects the same?\"\n\nin the case of `String` objects, it knows we're asking the first question and not the second.  But what if we wanted to ask the second question?  That's where another method comes in: the `equal?`. \n\n```ruby\nstr1 = \"something\"\nstr2 = \"somthing\"\nstr1_copy = str1\n\n# comparing the string objects' values\nstr1 == str2     # => true\nstr1 == str1_copy  #=> true\nstr2 == str1_copy  #=> true \n\n# comparing the acutal objects\nstr1.equal? str2  #=> false\nstr2.equal? str1_copy #=> true\nstr2.equal? str1_copy #=> false\n```\n\nNotice if we use `==` to compare all evaluate to true.  However the story changes when we use the `equal?` this is because they check to see if the object is the same.\n\nIn summary, the `==` method comapres the two vairable's wheras the `equal?` determines wheterh the two vairables point to the same object. \n\n#### The `==` method\n\nThe `==` is not an operator in Ruby, like the `=` assinment operator.  Instead, it's acutally and instance method avilable on all objects.  It's the same as `str1. == (str2)`.\n\nsince iit's an instance method, the answer to \"how does `==` know what value to use for comparison\" is : it's determined by the class.\n\nThe original `==` method is defined in the `BasicObject` class, which is the parent class for **all* classes in Ruby. Thies implies every object in Ruby has a `==` method.  However each class should overrided the `==` method to specify the value to compare.\n\nfor example, suppose there is a `Person` class:\n\n```ruby\nclass Person\n  attr_accessor :name\nend \n\nbob = Person.new\nbob.name = \"bob\"\n\nbob2 = Person.new\nbob2.name = \"bob\"\n\nbob == bob2  # => false \n\nbob_copy = bob\nbob == bob_copy   #=> true \n```\n\nThis implies that the default implemenation for `==` is the same as `equal?` (which is also in the `BasicObject` class). This isn't very useful.  To tell ruby what \"the same\" means for a `Person` object, we need to override the `==` method.\n\n```ruby\nclass Person\n  attr_accessor :name\n\ndef ==(other)\n  name == other.name   # relying on String #== here \n  end\nend \n\nbob = Person.new\nbob.name = \"bob\"\n\nbob == bob2\n\n```\n\nBy defining a `==` method in our `Person` class, we're overriding the dfault `BasicObject#==` behavior, and providing a much more meaningful way to compare tow `Person` objects.  Incidentally, you can do this with `<` and `>` as well, as those are also instance methods, and not built-in Ruby operators.\n\nNote that the `Person#==` method we just wrote uses the `String#==` for comparison.    You can safely use `==` to compare `Array`, `Hash` and `Integer` and `String` and many other objects. \n\none final note: when you define a `==` method, you also the `!=` for free. \n\n#### `object_id`\n\nevery object has a method called `object_id`, which returns a numerical value that uniquely identifies the object. \n\nplaying with object_id\n\n```ruby\n\narr1 = [1, 2, 3]\narr2 = [1, 2, 3]\narr1.object_id == arr2.object_id # => false\n\nsym1 = :something\nsym2 = :something\nsym1.object_id == sym2.object_id  # => true\n\nint1 = 5\nint2 = 5\nint1.object_id == int2.object_id  # => true\n\n\n```\n\nTThis shows that symbols and integers behave slightly differently in RUby than other objects.  If two symbols or two integers have the same value, they are also the same object.  This is a performance optimization in Ruby, because you can't modify a symbol or iteger.  This is also why Rubyists prefer symbols over strings to act as hash keys:  it's a slight performance optimization adn saves on memory. \n\n#### `===`\n\n`===` is an instance method, used implicity by the `case` statement\n\nA good example of seeing `===` in action is when we have ranges in a `when` clause.\n\n```ruby\nnum = 25\n\ncase num 1..50\n  puts \"small number\"\nwhen 51...100\n  puts \"large number\"\nelse \n  puts \"not in ragne\"\nend\n\n```\n\nBehind the scense, the `case` statement is using the `===` method to compare each `when` clause with `num`.  In this example, the `when` clauses contain only ranges, so `Range#===` is used for each clause.  Typically you don not have to overrid the default `===` behavior, as you likely wouldn't use your cutom classes in a `case` statement.  It's sometimes useful to remember that `===` is used for comparison in `case` statemetns, though.\n\nin order to visualize how the `case` statement uses `===`, consider the following interpretation using an `if` statement:\n\n```ruby\n\nnum = 25\n\nif (1..50) === num\n  puts \"small number\"\nelsif (51..100) === num\n  puts \"large number\"\nelse\n  puts \"not in range:\nend\n```\n\nIn this example, the `===` method is invoked on a range and passes in the argument `num`.  Now, `===` doesn't compare tow objects the same way that `==` compares two objects.  When `===` compares two objcets, such as `(1..50)` and `25`, its' asking \"if `(1..50)` is a group, would `25` belong in that group?\"  In this case the answer is yes.\n\nmore examples. \n\n```ruby\n\nOn line 1, `true` is returned becasue `\"hello\"` is an instance of `String`, even though `\"Hello\"` doesn't equal `String`.   Similarly , `false` is returned on line 2 because `15` is an integer, which doesn't equal `String` and isn't an instance of the `Strign` class. \n\n```\n\n#### 'eql?'\n\nFinally, the last eauality comparison method: `equl?`.  The `equl?` method determines if two objects contain the same value and if they're of the same class.   This method is used most often by `Hash` to determine equality among its members.  I'ts not used very often.\n\n### Summary \n\n`==`\n\n- for most objects, the `==` operator compares the values of the objects, and it is frequenty used.\n- the `==` operator is actually a method.  Most built in Ruby classes, like `Array`, `String`, `Integer`, etc override the `==` method to specify how to compare objects of those classes.\n- by defual, `BasicObject#==` does not perform and equality check; instead, it returns true if two objects are the same object, This is why other classes often override the behavior of `#==`\n- if you need ot compare custom objecst, you should override the `==` method.\n- understanding how this method works is the most important part of this assignment.\n\n##### Less Important\n\n`equal?`\n\n- the `equal?` method goes one level deeper than `==` and determines whether two variables not only have the same value, but also whether they point to the same object.\n- do not override `equal?`.\n- the `equal?` method is not used very often. \n- calling `object_id` on an object will return the object's unique numerical value.  Comparing two objects' `object_id` has the same effect as comparing them with `equal?`\n\n`===`\n\n- used implicitly in `case` statements\n- like `==`, the `===` operator is actually a method. \n- you rarely need to call this method explicityly, and only need to implement it in your custom classes if you anticipate your objects will be used in `case` statemetns, which is probably pretty rare.\n\n`eql?`\n\n- used implicitly in `Hash`.\n- very rarely used explicitly.\n\n\n## Variable Scope\n\nWhen we talked about variable scopoing rules in the past, we always talked about *local variables*.  In this assignment, we'll talk about variable scopoing rules for *instance* and *class* variables and *constants*.  We'll aslo talk about how inheritance affects these variable scopoing rules. \n\n### Instance Variable Scope\n\nInstance variables are variables that start with `@` and are scoped at the object level.  They are used to track individual object state, and do not cross over between objects.  FOr exampe, we can us a `@name` variable to separate the state of `Person` objects. \n\n```ruby\n\nclass Person\n  def initialize(n)\n    @name = n   # is the @name instance variable acessible here?\n  end \nend \n\nbob = Person.new('bob')\njoe = Person.new('joe')\n\nputs bob.inspect # => => #<Person:0x007f9c830e5f70 @name=\"bob\">\nputs joe.inspect  # => #<Person:0x007f9c830e5f20 @name=\"joe\">\n \n```\n\nBecause the scope of instance variabels is at the object level, this means that the instance variable is accesible in an object's instance methods, even if it's initilized outside of that istance method. Remeber, their scope is at the *object level*.\n\nwhat if we try to access an instance variable that is not yet initialized anywhere?\n\n```ruby\n\nclass Person\n  def get_name\n    @name      # the @name instance variable is not initilized \n  end\nend\n\nbob = Person.new\nbob.get_name   # => niol  \n\n``` \n\nThis shows another distinction from local variabls.  If you try to reference and uninitialized local variable, you'd get a `NameError`.  But if you try to reference and unitialize instance variable, you get `nil`\n\nSidenote:  what happens if you accidentally put and instance variable at the *class* level?\n\n```ruby\n\nclass Person\n  @name = \"bob\"  # class level initialization\n  \n  def get_name\n    @nname\n  end\nend\n\nbob = person.new\nbob.get_name   #=> nil \n\n```\n\nThe short answer is: don't do that for now.  The long answer is that instance variables initialized at the class level are an entirely different thing called *class instance variables*.  You shouldn't worry about that yet, but just remember to initialize instance variables within instance methods.\n\n\n### Class Variable Scope\n\nclass variables start with `@@` and are scoped at the class level.  They exhibit two main behaviours:\n\n- all objects share 1 copy of the class variable.  (This also implies objects can access class variables by way of instance methods.)\n- class methods can access class variabls, regardless of where it's initialized.\n\nExample:\n\n```ruby\nclass Person\n  @@total_people = 0   # initialized at the class level \n  \n  def self.total_people\n    @@total_people    # accessible from class method \n  end \n  \n  def initalize\n    @@total_people += 1  #mutable from instance method \n  end \n  \n  def total_people\n    @@total_people  # accessible from instance method\n  end\nend\n\nPerson.total_people   # => 0\nPerson.new \nPerson.new \nperson.total_people   # => 2\n\nbob = Person.new\nbob.total_people   # => 3\n\njoe = Person.new\njoe.total_people    # => 4\n\nPerson.total_people  # => 4\n```\n\nFrom the above, you can see that even when we have two different `Person` obejcts in `bob` and `joe` we're effecitely accessing and moifying one copy of the `@@total_people` class variable.  We can't do this with instance variabls or local variabls; only class variabls can share state between objecst.  (we're going to ignore globals.)\n\n*lexical Scope* : examples\n\n```ruby\nclass Car\n  WHEELS =4\n  \n  def wheels \n    WHEELS\n  end\nend\n\nclass Motorcycle < Car\n  WHEELS = 2\nend \n\ncivic = Car.new \nputs civic.wheels  # => 4\n\nbullet = Motorcycle.new\nputs bullet.wheels # => 4, when you expect 2\n\n\n```\nin order to solve the above problem you have to a define a method `Motorcycle#wheels`\n\n```ruby\ndef wheels\n  Wheels\nend \n``` \nor you need to explicitly specify the scope of the constant.  by using `self.class::WHEELS` in the `Car` class\n\n```ruby\nself.class::WHEELS\n```\n\n\nConstant Variable Scopre \n\nConstant variables are usually just called constants, because you're not supposed to re-assign them to a different value.  If you do re-assgin a constant, Ruby will warn you (but won't generate an error).  Constants begin with a capital letter and have *lexical scope*.  Let's play around wtih constant scope.\n\n\n\n```ruby\nclass Person\n  TITLES = ['Mr', 'Mrs', 'Ms', 'Dr']\n  \n  att_reader :name \n  \n  def self.titiles\n    TITLES.join(', ')\n  end \n  \n  def initialize(n)\n    @name = \"#{TITLES.sample}  #{n}\"\n  end \nend \n\nPerson.titles    # =>  \"Mr, Mrs, Ms, Dr\"\n\nbob = Person.new('bob')\nbob.name     # => \"Ms bob\"   (output may vary)\n```\nAs you can see from the example above, within one class, the rules for acessing constants is pretty easy:  It's avilable in class mehtods or istance methods (which implies it's accessible from objects).  Where contstant resolution gets really tricky is when inheritance is involved, and that's when we need to remember that unlike other vairbls, constants have lexical scope.  \n\nreturen to read [this](https://cirw.in/blog/constant-lookup.html) articla about constant lookput path \n\n\n## Inheritance and Vairable Scopre\n\n\nyou already know how inheritance affects methods, but what about variables?  \n\n### Instance variables\n\nfirst, we'll look at how sub-clasing affects instance variabls. \n\n```ruby\nclass Animal\n  def initialize(name)\n    @name = name\n  end\nend \n\nclass Dog < Animal\n  def dog_name\n    :bark! bark! #{@name} bark! bark!\"  # can @name be referenced here?\n  end\nend\n\nteddy = Dog.new(\"Teddy\")\nputs teddy.dog_name    # => bark! bark! Teddy bark! bark!\n\n```\n\nLooks like it!  when we instantiated `teddy`, we called `Dog.new`.  Since the `Dog` class doesn't have an `initalize` instance method, the method lookup path went ot the super classe, `Aniaml`, and executed `Animal#intialize`.  That's when the `@name` instance variable was initialized,  wand that's why we can acess it from `teddy.dog_name`.\n\none small tweak though and the story cahgnes. \n\n```ruby\nclass Animal\n  def initialize(name)\n    @name = name\n  end \nend \n\nclass Dog < Animal \n  def iniitalize(name); end\n  \n  def dog_name\n    \"bark! bark! #{@name} bark! bark!\"  #can @name be reference here?\n  end \nend \n\nteddy = Dog.new(\"Teddy\")\nputs teddy.dog_name    # => bark! bark! bark!\n\nteddy = Dog.new(\"Teddy\")\nputs teddy.dog_name   #=> bark! bark! bark!\n```\nIn this case, `@name` is `nil`, bceasue it was never initialized. The `Animal#initilize` method was never executed.  REmember that unitialized instance variabls return `nil`.\n\nok, what about mixing in modules?  How does tha ffect instance variabls?\n\n```ruby\nmodule Swim\n  def enable_swimming\n    @can_swim = true\n  end \nend \n\nclass Dog\n  include Swim \n  \n  def swim\n    \"swming!\" if @can_swim\n  end\nend \n\nteddy = Dog.new\nteddyin.swim    # => nil\n```\n\nWhat happened?  Since we didn't call the `Swim#enable_swimming` method, the `@can_swim` instance variable was never initialized.  Assuming the same module and class from above, we need to do the following: \n\n```ruby\nteddy = Dog.new\nteddy.enable_swimming\nteddy.swim    # => Swimming!\n\n```\n\nFrom teh examples above, instance variables dont' really exhibit any surprsi9ng behavior.  They behave similar to how istance methods would, with the exceptoin that we must first call the method that initilizes the instance variables.  Once we've don that, the instance can acess the instance variable.\n\n## Class Variables\n\nLet's now run a few experiments with class  varibles\n\n```ruby\nclass Animal\n  @@total_animals = 0\n  \n  def initialize\n     @@total_animals +=1 \n  end\nend\n\nclass Dog < Animal \n  def total_animals\n    @@total_animals\n  end\nend\nspike = Dog.new\nspike.total_animals    # => 1\n  \n```\n\n\nGreat, it looks like calss variables are acessible to sub-classes.  Note that since this class variable is initilzed ithe the `Animal` class, there is no method toe explicityly invoke to initialize it.  The vlass variable is loaded when the class is evaluated by Ruby.  This is pretty expected behaviour. \n\nBut there's a potentially huge problem.  It can be dangerous whne working with cklass variables wihtin the context of inheritance, because there is only one copy of the class variable across all sub-classes.  Here's and example:\n\n``` ruby\n\nclass Vehilce\n  @@wheels = 4\n  \n  def self.wheels\n    @@wheels\n  end\nend \n\nVehicle.wheels   # => 4\n\n```\n\nTha't spretty straight forward:  we initialize a valss variable, then expose a class mehtod to return the value of the class variable.  Now let's add a sub-class that overrides this class variable.\n\n\nThat's pretty staright forward: we intialize a vlass variable, then expose a class method to returen the value fo the class variable.  Now let's add a sub-class that overrides this class variable. \n\n```ruby\nclass Motorcyle < Vehicle \n  @@wheels = 2\nend\n\nMotorcycle.wheels    #=> 2\nVehicle.wheels       #=> 2 Yikes!\n\n```\nFor some odd reason,  the class variable in the sub-class affected the class variable in the super class.  Worse still, this change will affect all other sub-classes of Vehicle!\n\n```ruby\nclass Car < Vehicle\nend\n\nCar.wheels    #=>  2 Not what we expected!\n\n```\n\nIf we're wrigint a new class called `Car`, it'll be pretty natural to look at what we can inherit from the `Vehicle` super-class.  We'd notice the `@@wheeels = 4` in the `Vehicle` super-class, and in the spirit of avoid repetition, we would assume that class variable would be inherited by out `Car` sub-class. The fact that an entirely different sub-class of `Vehicle` can somehow modify this class variable throws a wrench into the way we think about class inheritance. \n\nFor this reason, avoid using class variables when working with inheritanc.  In fact, som rubyest would go as far as recommending avoiding class variables altogether.  The solution si usually to us class instance varibles, but that's a topic not covered. \n\n### Contants\n\nWe already saw that constants can be accessed from instance or class methods when defined within a class.  But can we reference a constant defined in a different class?\n\n```ruby\nclass Dog\n  LEGS = 4\nend \n\nclass Cat\n  Def legs\n    LEGS\n  end\nend\n\nkity = Cat.new\nkitty.legs     #=>  NameError:  unitialized constant Cat::LEGS\n```The error occurs here because Ruby is looking for `LEGS` within the `Cat` class. This is expected, since this is the same behaviour as class or instance variables (except, referencing an d unitilized instance variable will return `nil`).\n\n\nBut unlike class or instance variables, we can actually reach into the `Dog` class and reference the `LEGS` constant.  In order to do so, we have to tell Ruby where the `LEGS` constant is using `::`, which is the namspace resolution operator.\n\n```ruby\nclass Dog\n  LEGS = 4\nend\n\nclass Cat\n  def legs\n    Dog::LEGS    # added the :: namespace resoltuion \n  end\nend\n\nkitty = Cat.new\nkitty. legs    # => 4\n\n```\n\nSidenote: you can use `::` on classes, modules or constants.  We'l talk more about namespacing classes and module sin the future. \n\nLets take a look at how constants behave in a sub-class.\n\n```ruby\nclass Vehicle\n   WHEELS = 4\nend\n\nclass Car < Vehicle\n  def self.wheels\n    WHEELS\n  end \n  \n  def wheels\n    WHEELS\n  end \nend \n\nCar.wheels    # =>  4\n\na_car = Car.new\na_car.wheels   #=> 4\n\n```\n\nThat looks like expected behavioru.  A constant initialized in a super-class is inherited by the sub-clas, and can be accessed by both class and instance methods.\n\nHowever, things get a little hairy when we mix in modules.  Suppose we have a module that we want to mix in to differnt vehicles.\n\n\n```ruby\n\nModule Maintenance \n  def change_tires\n    \"Chaing #{WHEELS} tires.\"\n  end\nend\n\nclass Vehicle\n  WHEELS = 4\nend \n\nclass Car < Vehilce\n  Include Maintenance\nend\n\na_car =  Car.new\na_car.change_tires      #+> NameERROR: unitialzed constant Maintenance::WHEELS\n```\n\nUnlike instancemethos or insatnce cariables, constants are not evaluated at runtime, so their lexical scope - or where htey are used in teh code - is very important.  In this case, the line `\"changing #{WHEELS}  tires.\"`  Is in the `Maintenance` module, which is where Ruby will look for the 'WHEELS' constant.  Even though we call teh `chagne_tires` method from the `a_car` object, Ruby is not able to find the constant. \n\nsuprissingly, the fix can be either:\n\n```ruby\n\nmodule Maintenace\n  def change_ties\n    \"Ching  #{Vehicle::WHEELS}  tires.\"  #this fix works\n  end\nend\n\n```\n\nor\n\n```ruby\nmodlue Maintenance \n  def change_tires\n    \"Chaing #{car::WHEELS} tires.\" #surprsingly, this also works\n  end\nend \n```\n\nThe reason `Car:: WHEELS` works is becahse we're telling RUby to look for `WHEELS` in the `Car` class, which can acess `Vehicle::WHEELLS` through iheritance.\n\nConstant resolution will look at the lexical scope first, and then look at the inheritance hieracryh.  It can get very tricky when there are nested modules, each seeting the same consants to different values.  Be minful that sontant resoltion rules are diferent from method lookup path or instance variables.\n\n### Summary\n\n- **instance Variables** behave the way we'd expect.  The only thing to watch out for is to make sure the instance variable is initialized before referencing it.\n- **Clas Variables** have a very insidious behavoir of allowing sub-cllases to override super-class class variables.  Futher the change will affect all other sub-class.  This is extremly unintuitive behaviour, forcing some rubyists to not use class variables altogther.\n- **Constants** have *lexical scope* which meakes their scope resoltuion rules very unique compared to other vairable types. If Ruby doens't fine the constant using lexical scope, it'll then look at the inheritance hierarchy.\n\n**WHAT IS LEXICAL SCOPE**\n\n## Fake Operators \n\nBelow is a table that shows which operators are real operators, and which are methods disquises as operators (listed by order of precedence; highest first).\n\n| Method |   Operator  | Description |\n| ---   | --- | ---| \n|  yes | `[]`, `[]=` |  Collection elemetn getter and setter.|\n| yes | `**` | exponential opeator \nyes | `!`, `~` , `+`, `-`| Not, a complement, unary plus and minus (method names for the last two are +@ and -@)\nyes | `*`, `/`, `%` | multiply, divide and modulo\nyes | `+`, `-` | Plus, minus\nyes | `>>`, `<<` | right and left shift \nyes | `&` |  Bitwise \"and\"\nyes |  `^`, `|` | Bitwise exlcusive \"or\" and regular \"or\" (inlusive \"or\")\nyes | `<=`, `<`, `>`, `>=` | less than/equal to, less than, greater than, greater than/equal to \nyes | `<=>`, `==`, `===`, `!=`, `=~`, `!~` | eaulity and pattern maching ( != and !~ cannot be directly defined)\nno |   `&&` | Logical \"and\"\nno | `||` | logical \"or\"\nno | `..`, `...`\t| Inclusive range, exclusive range\nno |\t`?` , `:`\t| Ternary if-then-else\nno |\t`=`, `%=`, `/=`, `-=`, `+=`, `|=`, `&=`, `>>=`, `<<=`, `*=`, `&&=`, `||=`, `**=`, `{`\tAssignment (and shortcuts) and block delimiter |\n\nThe operators marked with a \"yes\" in the \"Method\" column means that these operators are in fact methods, which means we can override their functionality.  This appears to be a useful feature, but the other side is that since any class can override these fake operators, reading code like this: `obj` + obj2` opoens up a world of possibility as to what that can mean.  There are alot of fake operators, making ruby both powerful and dangerous.\n\n#### Comparison mehtods\n\nImplementing the comparison methods gives us a really nice syntax for comparing objects.Take for example the following class.\n\n```ruby\nclass  Person\n  attr_accessor :name,  :age\n  \n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\nend\n\n```\n\nWe could then instantiate a few `Person` objects.\n\n```ruby\n\n  bob = Person.new(\"Bob\", 49)\n  kim = Person.new(\"Kim\", 33)\n```\n\nwhat happens if we try to compare them?\n\n```\nputs \"bob is older than kim\" if bob > kim\n```\n\nIf we run the code, we get a NoMethodError.  Ruby can't find the `>` method for `bob`.  Let's fix that by adding a `>` method to the `Person` class. \n\n```ruby\nclass Person\n  # ... rest of code omitted for brevity\n  \n  def >(other_person)\n    age > other_person.age\n  end\nend \n\n```\n\nThe above implementation will reutrn `true` if the current object's age is greater than the `other_person`'s age, and `flase` otherwise.  Notice that we are pushing the comparison functionality to the `Integer#>` mehtod.  Now we can use the `Person#>` method in conditionals\n\n\n```ruby\nputs \"bob is older\" if bob > kim     # =>  \"bob is older\"\nputs \"bob is older\" if bob.>(kim)    # =>  \"bob is older\"\n```\nNote that defining `>` doesn't give us `<`.\n\n\nthe `<<` and `>>` shift mehtods\n\nBy now, you've likely already encountered the `<<` method when working with arrays.  I'ts pretty standard to wrte the following:\n\n```ruby\nmy_array = %w(hello world)\nmy_array << \"!!\"\nputs my_array.inspect          # =>  [\"hello\", \"world\", \"!!\"]\n\n```\n\nUp to now, you may have thought that the `<<` was a standard Rubyt operator, bit is is actually calling the `Array#<<` method, which is why you can't do the same for hashes because `Hash` doesn't contain this method.\n\nwhen implementing fake operatos, choose some functionality that makes sense when used with the special operator-like syntax.  For example, using the `<<` method fits well when working with a class that represents a collection.\n\n\n```ruby\nclass Team\n  attr_accessor :name, :members\n  \n  def initialize(name)\n    @name = name\n    @members = []\n  end\n  \n  def <<(person)\n    members.push person\n  end\nend\n\ncowboys = Team.new(\"Dallas Cowboys\")\nemmitt = Person.new(\"Emmit Smith\", 46)  # suppose we're using the Person class from earlier\n\ncowboys << emmitt      # will this work?\n\ncowboys.members        # =>   [#<Person:0x007fe08c209530>]\n\n```\n\nWe provided a clean interface for adding new members to a team object.  We could even build in a guard clause. \n\n```ruby\ndef <<(person)\n  return if person.not_yet_18?\n  members.push person\nend\n```\n\nAddig the shift operators can result in very clean code, but they make the most sense when working with classes that represent a collection.\n\n\n#### The plus method\n\nOne of the first examples in programming is often `1 + 1 == 2` \n\nBut even this simple line of code has hidden depth.  We're finally able to reveal the hidden secret:  That's actually a mehtod call.\n\n```ruby\n\n` + 1     # => 2\n1+(1)     # => 2\n\n```\n\nIntegers are objects of the `Integer` classe, they have access to the `Integer` instance methods.  Ithe case of `1.+(1)` the integer we're using is `Integer#+`\n\nso when should we write a `+` mehtod for our own objecst?  Let's look at the standard library for some inspiration:\n\n- `Integer#+`: increments the value by the value of the argument, returning a new integer\n- `String#+`:  concatenates with argument, returning a new string\n- `Array#+`:  concatenates with argument, returning a new array\n- `Date#+`:  increments the date in days by value of the argument, returning a new date\n\nThe functionality of the `+` should be either incrementing or concatenation with the argument.  You are, of course, free to implement it however you wish, Buit it's probably a good idea to follow the general usage of the standard libraries.  Here's an example:\n\n```ruby\nclass Team\n  attr_accessor :name, :members\n  \n  def initialize(name)\n    @name = name\n    @members = []\n  end\n  \n  def <<(perosn)\n    members.push person\n  end\n  \n  def +(ohter_team)\n    members + other_team.members\n  end\nend \n\n# we'll use the same Person class from earlier\n\ncowboys = Team.new(\"Dallas Cowboys\")\ncowboys << Person.new(\"Troy Aikman\", 48)\ncowboys << Person.new(\"Emmit Smith\", 46)\ncowboys << Person.new(\"Michael Irvin\",  49)\n\nniners = Team.new(\"San Francisco 49ers\")\nniners << Person.new(\"Joe Montana\", 59)\nniners << Person.new(\"Jerry Rice\", 52)\nniners << Person.new(\"Deion Sanders\", 47)\n\n```\n\nwe haven't actually used the `Team#+` method yet, we just set it up to use it.  Lets take a shot a using it\n\n\n```ruby\ndream_team = cowboys + niners     # what is dream_team?\n```\n\nLets study `Team#+`, if we look at the implementation, we can see that it returns a new `Array` object.  Therefore, `dream_team`  form the above example is an array of `Person` objects.\n\n\nNow, that may be what you meant to implement, and from a technical standpoint, that is valid.  But it doesn't match the patter from teh standard library (above).  The `Integer#+` method returns a new `Integer` object;  the `Strign#+` mehtod returns a new `String` object;  the `Date#+` method returns a new `Date` object.\n\nOur `Team#=` method should return a new `Team` Object.  The `Team#initalize` method, however, requires a name, which makes it a little awkward.  we could refactor but to stay on topic we'll just initialize the team namr to \"Temporary Team\"  for now.\n\n``` ruby\n\nclass Team\n# ... rest of class omited for brvity\n\n def +(other_team)\n   temp_team = Team.new(\"Temporary Team\")\n   temp_team.members = members + other_team.members\n   temp_team\n end\nend \n```\n\nAssume we set up the `cowboys` and `niners` teams again like before, we can now do this:\n\n```ruby\ndream_team = niners + cowboys \nputs dream_team.inspect    # => #<Team:0x007fac3b9eb878 @name=\"Temporary Team\" ... \n```\n\nNow, `dream_team` is no longer and aray, but a `Team` object, which is what we'd expect when we use `Team#+`\n\n### Element setter and getter methods\n\nAt this point, you've likely used element getter methods a lot already, pprobably mostly by way of working with arays.  OUt of all the fake operators, perhaps `[]` and `[]=` are the most surprising.  Part of the reason is because the syntatical sugar given to these two methods is so extre. for Example:\n\n```ruby\nmy_array = %w(first second third fourth)  #[\"first\", \"second\", \"third\", \"fourth\"]\n\n# element reference\nmy_array[2]          # =>  \"third\"\nmy_array.[](2)       # =>  \"third\"\n\n```\n\nThe above two examples of using `Array#[]` to reference an element are identical, yet they look dramatically different.  How did the 2 get in between the square brackets?  That's Ruby giving us a nice syntax.\n\nBut Ruby goes even one step farther for `Array#[]`.\n\n```ruby\n# element assignment\n\nmy_array[4] = \"fifth\"\nputs my_array.inspect      # => [\"first\", \"second\", \"third\", \"fourth\", \"fifth\"]\n\n\nmy_array.[]=(5, \"sixth\")  \nputs my_array.inspect      # => [\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\"]\n\n```\n\nI think we can agree that `my_array[4] = \"fifth\"` syntax reads much more naturally, but this syntax manipulation is also why sometimes it's hard to understand where certain code comes from.\n\nif we want to use the element setter and getter methods in our class, we first have to make sure w're working with a classs that represnets a colleciton.  Agaom. theses are normal instance methods, so we can make them do anything.  But let's follow the lead of Ruby standard library and build them as simple getter (reference) and setter (assignment) methods for elements in our collection.\n\n```ruby\nclass Team\n  # ... rest of code omitted for brevity \n  \n  def [](idx)\n    members[idx]\n  end\n  \n  def []=(idx, obj)\n    members[idx] = obj\n  end\nend \n\n```\n\n\nHere we're just taking advatnage of thee fact that `@members` is an array, so we can push the real owrk to the `Array#[]` and `Array#[]=` methods.  After writing tehse two methods, we can:\n\n```ruby\n# assume set up from earlier\ncowboys.members     # => ... array of 3 Person objects\n\ncowboys[1]    # => #<Person:0x007fae9295d830 @name=\"Emmitt Smith\", @age=46>\ncowboys[3] = Person.new(\"JJ\", 72)\ncowboys[3]    # => #<Person:0x007fae9220fa88 @name=\"JJ\", @age=72>\n\n```\n\nNotice that we can now do both element reference and assignment using `Team#[]` and `Team#[]` respecitvely.  This syntactical sugar adds a new readabilty aspect to our code. \n\n\n## Execptions\n\n### What is an dException?\n\nAn exception is simpy and exceptional state in your code.  It is not necessarily a bad thing, but is is Ruby's way of letting you know that your code is behaving unexpectudly.  If an exception is raised and your codee does not handle the exeception, your program will crash and Ruby will provide a message telling you what type of error was encountered.\n\n```ruby\n3 + \"z\"\n# program execution stops\n#=>  String can't be coerced into Integer (TypeError)\n\n```\n\nRuby provides a hierarchy of built-in classes to simplify excecption handling.  In fact, the exception names that you see when youcrashes, such as `TypeError`, are actually class names.  The class at the very top of the hierarchy is teh `Exception` class.  Exsception has several subclassses, many of which have descendents of their own. \n\n\n### The exception Class Hierarchy\n\nBelow is the complete hierarcy of Ruby's exception classes\n\n```ruby\n\nException\n  NoMemoryError\n  ScriptError\n    LoadError\n    NotImplementedError\n    SyntaxError\n  SecurityError\n  SignalException\n    Interrupt\n  StandardError\n    ArgumentError\n      UncaughtThrowError\n    EncodingError\n    FiberError\n    IOError\n      EOFError\n    IndexError\n      KeyError\n      StopIteration\n    LocalJumpError\n    NameError\n      NoMethodError\n    RangeError\n      FloatDomainError\n    RegexpError\n    RuntimeError\n    SystemCallError\n      Errno::*\n    ThreadError\n    TypeError\n    ZeroDivisionError\n  SystemExit\n  SystemStackError\n  fatal\n```\n\nbrief examination of some of the classes.\n\n- have you ever pressed `ctrl-c` to exit out of a program?  Doing so actuallly raises an exception via the `Interrupt` class.\n- A `SyntaxError`, as its name suggets, will be raised when Ruby tries to execute code containing invalid syntax.\n- a `SystemStacError` is raised in the case of a stack overflow.  comes from infinite loop.\n-\n\n### When Should You Handle and Exception?\n\nMost often, the errors you want to handle are descendents of the `StandardError` class that was introduced above.  Generally it is realtively safte to handle these exceptions and continue running the program.\n\nHowever there are some errors that we should allow to crash our program.  Important errors such as `NoMemorryError`, `SyntaxError`, and `LoadError` must be addresed in order for our program to operate properly.  \n\n### How to Hanlde an Exceptional State\n\n#### The begin/rescue Block\n\nusing a `begin/rescu` block to handle errors can keep your program from crashing if the exception you have specified is raised.  Let's see a simple example.\n\n\n```ruby\nbegin\n  # put code at risk of failing here\nrescue TypeError\n  # take action\nend \n\n```\n\nThe above example will execute the code int the `rescue` clause rather than exiting the program if the code on line 2 raises a `TypeError`.  If no exception is raised, the `rescue` clause will not be executed at all and the program will continue to run normally.  You can see that on line 3 we specified what type of excepion to rescue.what type of exception to rescue.  If no exception type is specified, all `StandardError` exeptions will be rescued and handled.  Remember not to tell ruby to rescue `Exception` class exceptions. Doing so will rescue all exceptions down the `Exception` class hierarchy and is very dangerous,as explained previously.\n\nIt is possible to include mutiple `resuce` clauses to handle various types \n\n```ruby\n\nbegin\n  # some code at risk of failing\nrescue TypeError\n  #take action\nrescue Arugment Error\n #take a different action\nend \n```\n\nIf you would like to take the same action for more than one type of exceptio, you can use the syntax on line 3 below.\n\n```ruby\nbegin\n  # some code at risk of failing\nrescue  ZeroDivisionError, TypeError\n  # take action\nend \n```\n\n#### Exception Objects and Built-in Methods\n\nhow do you use and exception object?\n\n```ruby\nrescue TyperError => e\n```\nThe syntax in the above code rescues any `TypeError`, adn stores the exception object in `e`.  Some usedful instance mehtods that Ruby provides are `Exception#message` and `Exception#backtrace`, which return an error message and a backtrace association with the exception, respecitvely.Let's look at an example of this in a `begin/rescue` block.\n\n```ruby\nbegin\n  # code at risk of failing here\nrescue StandardError =>  E # storing the exception object in e\n  puts e.message   # output error message\nend\n\n```\n\nThe code above will rescure any type of `StandardError` excetption (including all of its descendents) and output the message associated with the exception object.  Code like this can be useful when you are buggign and need to narrow down the type of casue of the error.  You may always choose to be more specific about which type of exception ot handle, but remember to never rescue the `Exception`  class.\n\nBecause exception objects are just normal RUby objects adn the different exception types, therefore you can even call `Object#class` on an exception object ot return its class name.\n\n```ruby\ne.class\n#=> Type Error\n\n```\n\n#### ensure\n\n\nYou may also choose to include an `ensure` clause in your `begin`/`rescue` block after the last `rescue` clause.  This branch will always execute, whether an exception was raised or not.  A simple example is resource management;  the code below demonstrates working with a file.  whether or not an exception was raised when working with the file, this code ensures that it will always be closed.\n\n```ruby \nfile = opne(fiie_name, 'w')\n\nbegin\n  # do soemthi with file\nresuce\n # handle exception\nrescue\n  # handle a different excepiton\nensure\n flise.close\n #executes every time\nend \n\n```\nOne imoprtant thing to remember about `ensure` is that it is critical that this code does not raise and exception itself.  If the code within the `ensure` clause raises and eception, any exception raised earlier in the execution of the `begin/rescue` blcok will be masked and debugging can become very difficult. \n\n#### retry\n\nWe will introduce `retry` breifely, but it is unlikely that you will use it often.  Using `retry` in your `begin/rescue` block redirects your program back to the `begin` statement.  hiss allows your program to make another attempt to execute the code that raised and exception.  You may find `retry` useful when connecting to a remote server, for example.  Bewware that if your code continually fails, you risk ending up in an infinite loop.  In order to aviod this, i'ts a good idea to set a limit on the number of times you want `retry` to execute.  `retry` must be called within the `rescue` blcok, as seen below on line 8..   using `retry` elsewhere will raise a `SyntaxError`\n\n\n```ruby\nRetry_LIMIT = 5\n\nbegin\n  attempts = attempts | 0\n  # do something\nrescue\n  attempts += 1\n  retry if attempts < RETRY_LIMIT\nend \n```\n\n\n### Raising Exceptions Manually\n\nso far, this article has discussed how to handle eceptions raised by Ruby.  IN the previous code examples, we have had no control over when to raise an exception or which error type to use; it has all been decided for us.  Handling an exception is a reaction to an exception that has already been raised.\n\nNow let's switch gears and explore how you can exert more control when working with excetpions in a program.  You can do this manually by calling `Kernal#raise`.  This allows you to choose what type of exception ot raise and even set your own error message.   If you do not specify what type of exception to raise, Ruby will default to `RuntimeError` (subclass of `StandardError`).  There are a few different syntax options you may use when working with `raise` as seen below.\n\n\n```ruby\n\nrasi TypeError.new(\"Somethidn went Wrogn!\")\n```\n\n```ruby \nraise TypeError, \"Somehting wen Wrong!\"\n```\n\nIn the following example, the exception type will default to a `RuntimeError`, because none other is specified.  The error message specified is `\"invalid agge\"`.\n\n```ruby\ndef validate_age(age)\n  raise(\"invalid age\") unless (0..105).include?(age)\nend \n```\n\nIt is important to understand that exceptions you raise manually in your program can be handled in the same manner as execptions RUby raises automatically.\n\n\n```ruby\n\nbegin\n  validate_age(age)\nrescue RuntimeError => e\n  puts e.message     #=>  \"invalid age\"\nend \n```\n\nAbove, we place the `validate_age` method in a `begin/resuce` block.  If an invalid age is passed in to the mehtod, a `RuntiemError` withe the error message `\"invalide age\"` will be raised and the `rescue` clause of our `begin/resuce` block will be executed.\n\n### Raising Custom Exceptions \n\nIn addition to providing many built- in exceptions classes, Ruby allows us the flexibilty to creat oour own custom exception classes.\n\n```ruby\nclass ValidateAgeError < StandardError; end\n```\n\nNotice that our custom exception class `ValidateAgeError` is a subclass of an existing exception.  This means that `ValidateAgeError` has acess to all of the built-in exception object behaviours Ruby provides, inlcuidng `Exception#message` and `Exception#backtrace`.  as discussed eariler in this article, you should always aviod maksing exceptions from the `Excepiton` class itself and other sytem-level execption classes.  Concelaing theese exceptions is dangers these exception is dangerous.  Most often you will want to inheriit form `StandardError`.\n\nWhen using a custom exception class, you can be specific about the error you program encountered by giving the calsss a very descriptive name. Doing so may aide in debugging. lets alter our previous code example and use our more descptivie cusotm excetpion class.\n\n```ruby\ndef validate_age(age)\n  raise ValidateAgeError, \"invalid age\" unless (0...105).include?(age)\nend\n\nbegin\n  validate_age(age)\nresuce ValidateAgeError => e\n  # take action\nend \n\n```\n\nas demonstared in the example above yo\u0010u can rais and handle custom execptions just like any built in exception that ruby provides.\n\nlexical scope:  \n\n"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}