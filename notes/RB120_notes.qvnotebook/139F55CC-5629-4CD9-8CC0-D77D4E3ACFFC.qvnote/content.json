{
  "title": "RB120 Notes masterÂ ",
  "cells": [
    {
      "type": "markdown",
      "data": "##Lesson 2 Object Oriented Programming \n\n###Polymorphism \n**Polymorphism** refers to the ability of different objects to respond in different ways to the same message (or method invocation).\n\nThere are several ways to implement polymorphism \n\n####Polymorphism through inheritance \n\n```ruby\n\nclass Animal\n  def eat\n    # generic eat method\n  end\nend \n\nclass Fish < Animal\n  def eat\n    # eating specific to fish\n  end \nend\n\nclass Cat < Animal \n  def eat\n    # eat implementation for cat\n  end\nend \n\ndef feed_animal(animal)\n  animal.eat \nend\n\narray_of_animals = [Animal.new, Fish.new, Cat.new]\n\narray_of_animals.each do |animal|\n  feed_animal(animal)\nend\n\n```\n\n####Polymorphism through ducking type \n\nwe can implement polymorphism through **duck typing**.  \n\n*Duck typing* doesn't concern itself with the class of an object; instead, it concerns itself with what methods are available on the object.  If an object \"quacks\" like a duck, then we can treat it like a duck.\n\nthe example below attmepts to implemetn polymorphic behavior without using duck typing. **this is how not to do it**. \n\n```ruby\n\nclass Wedding \n  attr_readr :guests, :flowers, :songs\n  \n  def prepare(preparers)\n    prepares.each do |preparer|\n      case preparer\n      when Chef\n        preparer.prepare_food(guests)\n      when Decorator\n        preparer.decorate_place(flowers)\n      when Musician\n        preparer.prepare_performance(songs)\n      end \n    end\n  end\nend \n\nclass Chef\n  def prepare_food(guests)\n    # implementation \n  end \nend \n\nclass Decorator\n  def decorate_place(flowers)\n    #implementation\n  end \nend \n\nclass Musician\n  def prepare_performance(songs)\n    #implementation\n  end\nend \n```\n\nThe problem with this approach is that the `prepare` method has too many dependencies.  It relies on specific classes and their names.  It also needs to know which method it should call on each of the objects, as well as the argument that those methods require. If you change anything within those classes that impaces `Wedding#prepare` you need to refactor the method. \n\nnow refactored this code using `duck typing`.\n\n\n```ruby \nclass Wedding\n  attr_reader :guests, :flowers, :songs \n  \n  def prepare(preparers)\n    preparers.each do |preparer|\n      preparer.prepare_wedding(self)\n    end \n  end\nend\n\nclass Chef\n  def prepare_wedding(wedding)\n    prepare_food(wedding.guests)\n  end\n  \n  def prepare_food(guests)\n    #implementation \n  end\nend\n\nclass Decorator \n\n  def prepare_wedding(wedding)\n    decorate_place(wedding.flowers)\n  end\n  \n  def decoreate_place(flowers)\n    #implementation\n  end\nend\n\nclass Musician\n  def prepare_wedding(wedding)\n    prepare_performnace(wedding.songs)\n  end\n  \n  def prepare_performance(songs)\n    #implementation\n  end\nend \n      \n```\n\nWe can see that there is no inheritance in this example but we can still have polymoprhism. Each class must define a `prepare_wedding` method and implement it in its own way.  If we must add another preparer, we can create another class and just implement `prepare_wedding` to perform the appropriate actions. \n\n####Encapsulation \n\nEncapsulation lets us hide the internal representation of an object from the outside and only expose the methods and properties that the users of the object need. We expose these properties and methods through the public interface of a class: its public methods.\n\nexample:\n\n```ruby\n\nclass Dog\n\n  attr_reader :nickname\n  \n  def initialize(n)\n    @nickname = n\n  end \n  \n  def change_nickname(n)\n    self.nickname = n\n  end \n  \n  def greeting\n    \"#{nickname.capitalize} says Woof Woof!\"\n  end \n  \n  private \n    attr_writer :nickname \nend \n\ndog = Dog.new(\"rex\")\ndog.change_nickname(\"barny\") # changed nickname to \"barny\"\nputs dog.gretting #Displays: Barny says Woof Woof!\n\n```\n\nIn this example, we can change the nickname of a dog by calling the `change_nickname` method without needing to know how the `Dog` class and this method are implemented. \n\nNote that the `setter` method for `nickname` is private: it is not available outside of the class and `dog.nicknae = \"barny\" would raise an erro.\n\nHowever, even though the setter method for `nickname` is private we are still calling it with `self` prepended on line `9`, `self.nickname = n`.  **This is an exception in Ruby.  You need to use `self` when calling private setter methods as if you didn't use `self` Ruby would think you are creating a local variable**. \n\nkeep in mind, that the as class should have as few public methods as possible.\n\n####collaborator_objects\n\nInstance variables can hold any object, not only strings and integers.  It can hold data structures, like arrays or hashes.  Here's an example. \n\n```ruby \n\nclass Person\n  def initialize \n    @heros = ['Superman', 'Spiderman', 'Batman']\n    @cash = {'ones' => 12, 'fives' => 2, 'tens' => 0, 'twenties' =>, 'hundreds' =>0}\n  end \n  \n  def cash_on_hand\n     # this method will use @cash to calculate total cash value \n     # we'll skip the implementation \n  end\n  \n  def heroes \n    heroes.jion(', ')\n  end \nend \n\njoe = Person.new \njoe.cash_on_hand # => \"62.00\"\njoes.heroes  # => \"Superman, Spiderman, Batman\"\n\n```\n\nInstance variables can be set to any object, even an object of a custom class we've created.  Suppose we have a `Person` that has a `Pet`. We could have a class like this:\n\n\n``` ruby \nclass Person \n attr_accesor :name, :pet\n \n def initialize(name)\n   @name = name \n end \nend\n\nbob = Person.new(\"Robert\")\nbud = Bulldog.new #assume Bulldog class from previous assignment \n\nbob.pet = bud \n \n```\n\nThis last line is something new and we haven't seen that yet, but it's perfectly valid OO code.  We've essentially set `bob`'s `@pet` instance variable to `bud`, which is a `Bulldog` object.  This means that when we call `bob.pet`, it is returning a `Bulldog` object. \n\n```ruby\nbob.pet                       # => #<Bulldog:0x007fd8399eb920>\nbob.pet.class                 # => Bulldog\n```\nbecause `bob.pet` returns a `Bulldog` object, we can then chain any `Bulldog` methods at the end as well:\n\n```ruby\n  bob.pet.speak   # => \"bark!\"\n  bob.pet.fetch  # => \"fetching!\" \n```\n\nObjects that are stored as state within another object are also called \"collaborator objects\".  We call such objects collaborators because they work in work in conjunction (or collaboration) with the class they are associated with.  For instance, `bob` has a collaborator object stored in the `@pet` variable.  When we need the `BullDog` object to perform some action (i.e. we want to acess some behavior of @pet), then we can go through `bob` and call the method on the object stored in `@pet`, such as `speak` or `fetch`. \n\nWhen we work with collaborator objects, they are usually custom objects (e.g. defined by the programmer and not inherited from the Ruby core library); `@pet` is an example of a custom object.  Yet, collaborator objects aren't strictly custom objects.  Even the string object xtored in `@name` within `bob` in the code above is technically a collaborator object. \n\nCollaborator objecst play an important role in object oriented design, since they also reporesnt the connections between various actors in your program.  When working on an object oriented program be sure to consider what collaborators your classes will have and if those associations make sense, both form a tehcnicall stanpoint and in terms of modeling the problem your program aims to solve. \n\nNext, let's develop our program some more and change the impolementation a bit to allow a person to have many pets. How should we implement this?  How about an array of pets -- that is an array of `Pet` objects\n\n\n```ruby\nclass Person \n  attr_accessor :name, :pets\n  \n  def initialize(name)\n    @name = name\n    @pets = []\n  end \nend\n\nbob = Person.new(\"Robert\")\n\nkitty = Cat.new \nbud = Bulldog.new \n\nbob.pets << kitty\nbob.pets << bud \n\nbob.pets  # => [#<Cat:0x007fd839999620>, #<Bulldog:0x007fd839994ff8>]\n```\n\nnotice the opending and closing square brackets -- that means this is an array.  YOu can see that the first element in the array is a `Cat` object while the second element is a `Bulldog` object.   Because it's an array, you cannot just call `Pet` methods on `pets`:\n\n```ruby \nbob.pets.jump # NoMethodError: undefined method `jump' for [#<Cat:0x007fd839999620>, #<Bulldog:0x007fd839994ff8>]:Array\n```\n\nThere is no `jump` method in the `Array` class, so we get an error.  if we want to make each individual pet jump, we'll have to parse out the elements in the array and operate on the individual `Pet` object.  HEre' well just iterate throug the array. \n\nbob.pets.each do |pet|\n  pet.jump\nend \n\n####lecture modules \n\n##Coding Tips \n\n- Explore the problem before design.\n  Take time to explore the problem doamin with a *spike* - exploratory code to play around with the problem.  Spikes and help validate intial hunches and hypotheses. you don't have to worry about code quality, becasue the idea of as spikes is to throw away the code.   As you start to understand the probelm better and get a feel for possible solutions, start to organize your code into coherent classes and methods. \n\n- repetivie nouns in method names is a sign that you're missing a class. \n\n- when naming methods, don't include the class name\n\n```ruby\n\nclass Player \n  def player_info \n   # return players name, move and other data\n  end\nend \n\n```\n\nhowever it would be better if we just named the method `info` because for example \n\n```ruby\n\nplayer1 = Player.new\nplayer2 = Player.new \n\nputs player1.player_info\nputs player2.player_info \n\n```\nabove reads alot worse than below\n\n```ruby \nplayer1 = Player.new\nplayer2 = Player.new \n\nputs player1.info\nputs player2.info \n```\n\n- Avoid long method invocation chains:\n\nwhen working with OOP its tempting to keep calling methods on collaborator objects. Take the following code:\n\n```ruby\nhuman.move.display.size\n```\nThis is a 3 chain method invocation, and is very fragile. For example if `human.move` returns `nil` then the entire method invocation chain blows up and its hard to debug the error. \n\nThere are many strategies to deal with this type of thing, for now try to think about the smell of the code, and the possibility of `nil` or other unexpected return values in the middle of the chain. you could put in a guard clause to help to help with this.  If you've identified that that human.move could possibly return `nil` you could puts some guard expression in like this. \n\n``` ruby\nmove = human.move\nputs move.display.size if move\n```\n\n-avoid design patterns for now \n \n##CRC cards\n\nClass Responsibility Collaborator cards started out as a teaching tool to design classes and map interactions between classe. but is now a real world tool.\n\nHow to use:\n\n1. write a description of the problem and extract major nouns and verbs.\n\n2. make an initial guess at organizing the verbs and nouns into methods and classes/modules, then do a spike to explore the problem ith temporary code.\n\n3. when you have a better idea of ther problem, model your thoughts in CRC cards. \n\nhere's a component of CRC card:\n\n![IMAGE](quiver-image-url/BEF14F3C08543EE920CCEF44A36DE457.jpg =390x230)\n\nBelow is an example of the CRC card for the `Human` card: \n\n![IMAGE](quiver-image-url/B446EB10D952FD071FBAA0C6144D672B.jpg =391x234)\n\nif we create a CRC card for all classes in the RPS game we have a CRC model:\n\n![IMAGE](quiver-image-url/4541780EB56502DA97EA95F911ACA7CE.jpg =1215x552)\n\nfinally we have CRC card for the `RPSGame` class:\n\n![IMAGE](quiver-image-url/4541780EB56502DA97EA95F911ACA7CE.jpg =1215x552)\n\n\n"
    }
  ]
}