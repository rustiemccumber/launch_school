{
  "title": "RB120 Notes masterÂ ",
  "cells": [
    {
      "type": "markdown",
      "data": "##Lesson 2 Object Oriented Programming \n\n###Polymorphism \n**Polymorphism** refers to the ability of different objects to respond in different ways to the same message (or method invocation).\n\nThere are several ways to implement polymorphism \n\n####Polymorphism through inheritance \n\n```ruby\n\nclass Animal\n  def eat\n    # generic eat method\n  end\nend \n\nclass Fish < Animal\n  def eat\n    # eating specific to fish\n  end \nend\n\nclass Cat < Animal \n  def eat\n    # eat implementation for cat\n  end\nend \n\ndef feed_animal(animal)\n  animal.eat \nend\n\narray_of_animals = [Animal.new, Fish.new, Cat.new]\n\narray_of_animals.each do |animal|\n  feed_animal(animal)\nend\n\n```\n\n####Polymorphism through ducking type \n\nwe can implement polymorphism through **duck typing**.  \n\n*Duck typing* doesn't concern itself with the class of an object; instead, it concerns itself with what methods are available on the object.  If an object \"quacks\" like a duck, then we can treat it like a duck.\n\nthe example below attmepts to implemetn polymorphic behavior without using duck typing. **this is how not to do it**. \n\n```ruby\n\nclass Wedding \n  attr_readr :guests, :flowers, :songs\n  \n  def prepare(preparers)\n    prepares.each do |preparer|\n      case preparer\n      when Chef\n        preparer.prepare_food(guests)\n      when Decorator\n        preparer.decorate_place(flowers)\n      when Musician\n        preparer.prepare_performance(songs)\n      end \n    end\n  end\nend \n\nclass Chef\n  def prepare_food(guests)\n    # implementation \n  end \nend \n\nclass Decorator\n  def decorate_place(flowers)\n    #implementation\n  end \nend \n\nclass Musician\n  def prepare_performance(songs)\n    #implementation\n  end\nend \n```\n\nThe problem with this approach is that the `prepare` method has too many dependencies.  It relies on specific classes and their names.  It also needs to know which method it should call on each of the objects, as well as the argument that those methods require. If you change anything within those classes that impaces `Wedding#prepare` you need to refactor the method. \n\nnow refactored this code using `duck typing`.\n\n\n```ruby \nclass Wedding\n  attr_reader :guests, :flowers, :songs \n  \n  def prepare(preparers)\n    preparers.each do |preparer|\n      preparer.prepare_wedding(self)\n    end \n  end\nend\n\nclass Chef\n  def prepare_wedding(wedding)\n    prepare_food(wedding.guests)\n  end\n  \n  def prepare_food(guests)\n    #implementation \n  end\nend\n\nclass Decorator \n\n  def prepare_wedding(wedding)\n    decorate_place(wedding.flowers)\n  end\n  \n  def decoreate_place(flowers)\n    #implementation\n  end\nend\n\nclass Musician\n  def prepare_wedding(wedding)\n    prepare_performnace(wedding.songs)\n  end\n  \n  def prepare_performance(songs)\n    #implementation\n  end\nend \n      \n```\n\nWe can see that there is no inheritance in this example but we can still have polymoprhism. Each class must define a `prepare_wedding` method and implement it in its own way.  If we must add another preparer, we can create another class and just implement `prepare_wedding` to perform the appropriate actions. \n\n####Encapsulation \n\nEncapsulation lets us hide the internal representation of an object from the outside and only expose the methods and properties that the users of the object need. We expose these properties and methods through the public interface of a class: its public methods.\n\nexample:\n\n```ruby\n\nclass Dog\n\n  attr_reader :nickname\n  \n  def initialize(n)\n    @nickname = n\n  end \n  \n  def change_nickname(n)\n    self.nickname = n\n  end \n  \n  def greeting\n    \"#{nickname.capitalize} says Woof Woof!\"\n  end \n  \n  private \n    attr_writer :nickname \nend \n\ndog = Dog.new(\"rex\")\ndog.change_nickname(\"barny\") # changed nickname to \"barny\"\nputs dog.gretting #Displays: Barny says Woof Woof!\n\n```\n\nIn this example, we can change the nickname of a dog by calling the `change_nickname` method without needing to know how the `Dog` class and this method are implemented. \n\nNote that the `setter` method for `nickname` is private: it is not available outside of the class and `dog.nicknae = \"barny\" would raise an erro.\n\nHowever, even though the setter method for `nickname` is private we are still calling it with `self` prepended on line `9`, `self.nickname = n`.  **This is an exception in Ruby.  You need to use `self` when calling private setter methods as if you didn't use `self` Ruby would think you are creating a local variable**. \n\nkeep in mind, that the as class should have as few public methods as possible.\n\n####collaborator_objects\n\nInstance variables can hold any object, not only strings and integers.  It can hold data structures, like arrays or hashes.  Here's an example. \n\n```ruby \n\nclass Person\n  def initialize \n    @heros = ['Superman', 'Spiderman', 'Batman']\n    @cash = {'ones' => 12, 'fives' => 2, 'tens' => 0, 'twenties' =>, 'hundreds' =>0}\n  end \n  \n  def cash_on_hand\n     # this method will use @cash to calculate total cash value \n     # we'll skip the implementation \n  end\n  \n  def heroes \n    heroes.jion(', ')\n  end \nend \n\njoe = Person.new \njoe.cash_on_hand # => \"62.00\"\njoes.heroes  # => \"Superman, Spiderman, Batman\"\n\n```\n\nInstance variables can be set to any object, even an object of a custom class we've created.  Suppose we have a `Person` that has a `Pet`. We could have a class like this:\n\n\n``` ruby \nclass Person \n attr_accesor :name, :pet\n \n def initialize(name)\n   @name = name \n end \nend\n\nbob = Person.new(\"Robert\")\nbud = Bulldog.new #assume Bulldog class from previous assignment \n\nbob.pet = bud \n \n```\n\nThis last line is something new and we haven't seen that yet, but it's perfectly valid OO code.  We've essentially set `bob`'s `@pet` instance variable to `bud`, which is a `Bulldog` object.  This means that when we call `bob.pet`, it is returning a `Bulldog` object. \n\n```ruby\nbob.pet                       # => #<Bulldog:0x007fd8399eb920>\nbob.pet.class                 # => Bulldog\n```\nbecause `bob.pet` returns a `Bulldog` object, we can then chain any `Bulldog` methods at the end as well:\n\n```ruby\n  bob.pet.speak   # => \"bark!\"\n  bob.pet.fetch  # => \"fetching!\" \n```\n\nObjects that are stored as state within another object are also called \"collaborator objects\".  We call such objects collaborators because they work in work in conjunction (or collaboration) with the class they are associated with.  For instance, `bob` has a collaborator object stored in the `@pet` variable.  When we need the `BullDog` object to perform some action (i.e. we want to acess some behavior of @pet), then we can go through `bob` and call the method on the object stored in `@pet`, such as `speak` or `fetch`. \n\nWhen we work with collaborator objects, they are usually custom objects (e.g. defined by the programmer and not inherited from the Ruby core library); `@pet` is an example of a custom object.  Yet, collaborator objects aren't strictly custom objects.  Even the string object xtored in `@name` within `bob` in the code above is technically a collaborator object. \n\nCollaborator objecst play an important role in object oriented design, since they also reporesnt the connections between various actors in your program.  When working on an object oriented program be sure to consider what collaborators your classes will have and if those associations make sense, both form a tehcnicall stanpoint and in terms of modeling the problem your program aims to solve. \n\nNext, let's develop our program some more and change the impolementation a bit to allow a person to have many pets. How should we implement this?  How about an array of pets -- that is an array of `Pet` objects\n\n\n```ruby\nclass Person \n  attr_accessor :name, :pets\n  \n  def initialize(name)\n    @name = name\n    @pets = []\n  end \nend\n\nbob = Person.new(\"Robert\")\n\nkitty = Cat.new \nbud = Bulldog.new \n\nbob.pets << kitty\nbob.pets << bud \n\nbob.pets  # => [#<Cat:0x007fd839999620>, #<Bulldog:0x007fd839994ff8>]\n```\n\nnotice the opending and closing square brackets -- that means this is an array.  YOu can see that the first element in the array is a `Cat` object while the second element is a `Bulldog` object.   Because it's an array, you cannot just call `Pet` methods on `pets`:\n\n```ruby \nbob.pets.jump # NoMethodError: undefined method `jump' for [#<Cat:0x007fd839999620>, #<Bulldog:0x007fd839994ff8>]:Array\n```\n\nThere is no `jump` method in the `Array` class, so we get an error.  if we want to make each individual pet jump, we'll have to parse out the elements in the array and operate on the individual `Pet` object.  HEre' well just iterate throug the array. \n\nbob.pets.each do |pet|\n  pet.jump\nend \n\n####lecture modules \n\n"
    }
  ]
}