{
  "title": "RB120 Notes masterÂ ",
  "cells": [
    {
      "type": "markdown",
      "data": "##Lesson 2 Object Oriented Programming \n\n###Polymorphism \n**Polymorphism** refers to the ability of different objects to respond in different ways to the same message (or method invocation).\n\nThere are several ways to implement polymorphism \n\n####Polymorphism through inheritance \n\n```ruby\n\nclass Animal\n  def eat\n    # generic eat method\n  end\nend \n\nclass Fish < Animal\n  def eat\n    # eating specific to fish\n  end \nend\n\nclass Cat < Animal \n  def eat\n    # eat implementation for cat\n  end\nend \n\ndef feed_animal(animal)\n  animal.eat \nend\n\narray_of_animals = [Animal.new, Fish.new, Cat.new]\n\narray_of_animals.each do |animal|\n  feed_animal(animal)\nend\n\n```\n\n####Polymorphism through ducking type \n\nwe can implement polymorphism through **duck typing**.  \n\n*Duck typing* doesn't concern itself with the class of an object; instead, it concerns itself with what methods are available on the object.  If an object \"quacks\" like a duck, then we can treat it like a duck.\n\nthe example below attmepts to implemetn polymorphic behavior without using duck typing. **this is how not to do it**. \n\n```ruby\n\nclass Wedding \n  attr_readr :guests, :flowers, :songs\n  \n  def prepare(preparers)\n    prepares.each do |preparer|\n      case preparer\n      when Chef\n        preparer.prepare_food(guests)\n      when Decorator\n        preparer.decorate_place(flowers)\n      when Musician\n        preparer.prepare_performance(songs)\n      end \n    end\n  end\nend \n\nclass Chef\n  def prepare_food(guests)\n    # implementation \n  end \nend \n\nclass Decorator\n  def decorate_place(flowers)\n    #implementation\n  end \nend \n\nclass Musician\n  def prepare_performance(songs)\n    #implementation\n  end\nend \n```\n\nThe problem with this approach is that the `prepare` method has too many dependencies.  It relies on specific classes and their names.  It also needs to know which method it should call on each of the objects, as well as the argument that those methods require. If you change anything within those classes that impaces `Wedding#prepare` you need to refactor the method. \n\nnow refactored this code using `duck typing`.\n\n\n```ruby \nclass Wedding\n  attr_reader :guests, :flowers, :songs \n  \n  def prepare(preparers)\n    preparers.each do |preparer|\n      preparer.prepare_wedding(self)\n    end \n  end\nend\n\nclass Chef\n  def prepare_wedding(wedding)\n    prepare_food(wedding.guests)\n  end\n  \n  def prepare_food(guests)\n    #implementation \n  end\nend\n\nclass Decorator \n\n  def prepare_wedding(wedding)\n    decorate_place(wedding.flowers)\n  end\n  \n  def decoreate_place(flowers)\n    #implementation\n  end\nend\n\nclass Musician\n  def prepare_wedding(wedding)\n    prepare_performnace(wedding.songs)\n  end\n  \n  def prepare_performance(songs)\n    #implementation\n  end\nend \n      \n```\n\nWe can see that there is no inheritance in this example but we can still have polymoprhism. Each class must define a `prepare_wedding` method and implement it in its own way.  If we must add another preparer, we can create another class and just implement `prepare_wedding` to perform the appropriate actions. \n\n####Encapsulation \n\nEncapsulation lets us hide the internal representation of an object from the outside and only expose the methods and properties that the users of the object need. We expose these properties and methods through the public interface of a class: its public methods.\n\nexample:\n\n```ruby\n\nclass Dog\n\n  attr_reader :nickname\n  \n  def initialize(n)\n    @nickname = n\n  end \n  \n  def change_nickname(n)\n    self.nickname = n\n  end \n  \n  def greeting\n    \"#{nickname.capitalize} says Woof Woof!\"\n  end \n  \n  private \n    attr_writer :nickname \nend \n\ndog = Dog.new(\"rex\")\ndog.change_nickname(\"barny\") # changed nickname to \"barny\"\nputs dog.gretting #Displays: Barny says Woof Woof!\n\n```\n\nIn this example, we can change the nickname of a dog by calling the `change_nickname` method without needing to know how the `Dog` class and this method are implemented. \n\nNote that the `setter` method for `nickname` is private: it is not available outside of the class and `dog.nicknae = \"barny\" would raise an erro.\n\nHowever, even though the setter method for `nickname` is private we are still calling it with `self` prepended on line `9`, `self.nickname = n`.  **This is an exception in Ruby.  You need to use `self` when calling private setter methods as if you didn't use `self` Ruby would think you are creating a local variable**. \n\nkeep in mind, that the as class should have as few public methods as possible. \n"
    }
  ]
}