{
  "title": "OOP book",
  "cells": [
    {
      "type": "markdown",
      "data": "<details> <summary> The Object model </summary>\n\n###Why object oriented programming?\n\n**Encapsulation**:  hiding pieces of code functionality and making it unavailable to the rest of the code base.  it is a form of data protection, so that the data cannot be manipulated or changed without obvious intention.\n\n**Polymorphism**: is the ability for the data to be represented as many different types. OOP gives us flexibility in using pre-written code for new purposes. \n\n**Inheritance**: a class inherits the behaviors of another class, referred to as a *superclass*.  Giving ruby users the power to define basic classes with large reuseability.  and smaller classes for more fine-grained, detailed behavior. \n\n**module**: Is another way to apply polymorphic structures to ruby programs. `modules` like classes contain shared behavior. you cannot create an object with a `module`, an module must be mixed in (a mixin) with a class using the `include` method invocation. \n\n###What are objects?\n\n**Objects in ruby**:  numbers, strings, arrays, classes and modules. \n\n**things which are not objects**: methods and blocks are two which stand out \n\nobjects are created from classes. think as classes as molds, and objects are the parts being produced. \n\n###Classes define objects\n\nRuby defines the attributes and behaviors of its objects in classes. Think of classes as a basic outline of what an object should be made of and what it should be able to do. \n\nto define a class: replace the `def` with `class` and use the CamelCase to create the name.  \n\n```ruby\nclass GoodDog\nend\n\nsparky = GoodDog.new\n```\nin the above example we have created an instance of our `GoodDog` class and stored it in the variable `sparky`.  The workflow of creating a new object or instance from a class is called `instantiation`. So we can say that we instantiated an object called `sparky` from The class `GoodDog`. the object is returned by calling the class method `new`. \n\n###Modules \n\nModule:  a collection of behaviors that is usable in other classes via **mixins**. A module is \"mixed in\" to a class using the include method invocation. \n\nbelow is an example of how you mix in a module into other classes.\n\n``` ruby\n\nmodule Speak\n  def speak(sound)\n    puts sound \n  end \nend \n\nclass GoodDog \n  include Speak \nend\n\nclass HumanBeing \n  include Speak \nend \n\nsparky = GoodDog.new\nsparky.speak(\"Arf!\")  #=> Arf!\nbob = HumanBeing.new \nbob.speak(\"Hello!\")   #=> Hello!\n\n```\n\n###Method Lookup \n\nRuby has a distinct look up path it follows each time a method is called. `ancestors` method can be called on any class to find out the method lookup chain. \n\n``` ruby\n\nmodule Speak\n  def speak(sound)\n    puts \"#{sound}\"\n  end\nend\n\nclass GoodDog\n  include Speak\nend\n\nclass HumanBeing\n  include Speak\nend\n\nputs \"---GoodDog ancestors---\"\nputs GoodDog.ancestors\nputs ''\nputs \"---HumanBeing ancestors---\"\nputs HumanBeing.ancestors\n```\nThe output: \n\n```ruby \n---GoodDog ancestors---\nGoodDog\nSpeak\nObject\nKernel\nBasicObject\n\n---HumanBeing ancestors---\nHumanBeing\nSpeak\nObject\nKernel\nBasicObject\n```\nThis shows that `speak` method is not defined in the `GoodDog`class.  The next place it looks is the `Speak` module.  It continues this until the method is either found or there are no more places to look. \n\n</details>\n\n<details><summary> classes and objects part 1 </summary>\n\n###states and behaviours \n\n`classes` are used to create objects\n`states` track attributes for individual objects\n`behaviors` are what objects are capable of doing \n\n###initializing a new object \n\n``` ruby\n\nclass GoodDog\n  def initialize \n    puts \"This object as initialized!\"\n  end\nend \n\nsparky = GoodDog.new  # => \"This object was initialized!\"\n\n```\n\nThe `initialize` methods everytime you created a new object. \n\nwe refere to the `initialize` method as a **constructor**, because it gets triggered whenever we create a new object. \n\n###Instance Variables \n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end\nend \n\n```\n\n`instance variable` is a variable that has the `@` symbol in front of it (example `@name = name`).  An `instance variable` is a variable that exists as long as the object instance exists, and it is a way to tie data to objects. It does not \"die\" after the initialize method is run. It \"lives on\" to be referenced, until the object instance is destroyed. \n\nnow creating an object using the `GoodDog` class from above. \n\n```ruby\nsparky = GoodDog.new(\"Sparky\")\n```\n\nHere the string \"Sparky\" is being passed from the `new` method through to the `initialize` method and is assigned to the local variable `name`.  Within the constructor (i.e., the `initialize` method) we then set the instance variable `@name` to point to the same object that `name` is referencing. Which results in assigning the string \"Sparky\" to the `@name` instance variable. \n\n\n###Instance Methods\n\ncurrently the `GoodDog` class cant really do anything.  lets give it some behaviors\n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def speak \n    \"Arf!\"\n  end \nend \n\nsparky = GoodDog.new(\"Sparky\")\nsparky.speak\n\n```\nnow suppose we have another `GoodDog` object \n\n\n```ruby \nfido = GoodDog.new(\"Fido\")\nputs fido.speak   #=> Arf\n```\nthe second object `fido` can also perform GoodDog behaviors. All the objects of the same class have the same behaviors, but they contain different states.  In this case the differing state is the name. \n\nwhat if you wanted to output \"Sparky says Arf!\"\n\n``` ruby\n\ndef speak \n  \"#{@name} says arf!\"\nend \n\n```\n\nno you can expose information about the state of the object using instance methods \n\n```\nputs sparky.speak '# => \"Sparky says arf!\"\nputs fido.speak '# => \"Fido says arf!\"\n\n```\n\nif you want to get the name, add a *getter* method\n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def speak \n    \"Arf!\"\n  end \n  \n  def get_name\n    @name\n  end\n  \nend \n\nsparky = GoodDog.new(\"Sparky\")\nsparky.speak   # => Sparky says arf!\nputs sparky.get_name  # => Sparky\n```\nnow we need to add a setter method\n\n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def speak \n    \"Arf!\"\n  end \n  \n  def set_name = (name)\n    @name = name \n  end \n  \n  def get_name\n    @name\n  end\n  \nend \n\nsparky = GoodDog.new(\"Sparky\")\nsparky.speak   # => Sparky says arf!\nputs sparky.get_name  # => Sparky\nsparky.set_name = \"Spartacus\"\nputs sparky.get_name # => Spartacus \n```\nAs a convention rubyists typically want to name those getter and setter methods using the same name as he instance variable they are exposing and setting. The update code should be as follows:\n\n``` ruby \nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def name \n    @name\n  end \n  \n  def name=(n)\n    @name = n\n  end \n  \n  def speak\n    \"{@name} says arf!\"\n  end \n  \n  sparky = GoodDog.new(\"Sparky\")\n  puts sparky.speak   #=> Sparky says arf!\n  puts sparky.name    #=> \"Sparky\"\n  sparky.name = \"Spartacus\"  \n  puts sparky.name   #=> \"Spartacus\" \nend \n```\n\nthese getter and setter methods are very long. \nwould make the code even longer. because the methods are so common place Ruby has a built in way to automatically correct using **attr_accessor**\n\n``` ruby\n\nclass GoodDog\n  attr_accessor :name\n  \n  def initialize(name)\n    @name = name\n  end\n  \n  def speak \n     \"#{@name} says arf!\"\n  end \nend \n\n  sparky = GoodDog.new(\"Sparky\")\n  puts sparky.speak\n  puts sparky.name  # => \"Sparky\"\n  sparky.name = \"Spartacus\"\n  puts sparky.name  # => \"Spartacus\"\n\n```\nif you only want the `getter` method without the `setter` method then you would want to use the `attr_reader`. Which works the same way but only allows you to retrieve the instance variables. If you only want the setter method you can use the attr_writer method. All of the `attr_` methods take a symbol as a parameter ]. if there are more states you are tracking you can use this syntax. \n\n```ruby\nattr_ancestor :name, :height, :weight\n```\n\n###Accessor methods in action \n\n```ruby\n\ndef speak \n  \"#{@name} says arf!\"\nend \n```\ninstead of referencing the instance variable directly we want to use the name getter method that we created earlier and is provide by the `attr_accessor` method, so it will now look like : \n\n```ruby\ndef speak \n  \"#{name} says arf!\"\nend\n``` \nwe are now calling the instance method rather than the instance variable. why do this instead of just calling the instance variable?  Its generally a good idea to call the getter method instead of call the instance variable. \n\nsuppose we add two states to the `GoodDog` class called `height` and `weight`\n\nNow suppose we create a new method which changes several states at once `change_info(n, h, w)`.\n\nTo disambiguate from creating a local variable we need to use `self.name=` to let ruby know that we are calling a method. So our `change_info` should be update to this: \n\n``` ruby\n\ndef change_info(n, h, w)\n  self.name = n\n  self.height = h\n  self.weight = w \nend \n\n```\nto be consistent we could adopt this syntax for getter methods as well, though it is not required. \n\n``` ruby\n\n\"#{self.name} weighs #{self.weight} and is #{self.height} tall.\"\n\n```\n\nnote that prefixing `self`. is not restricted to just the `accessor` methods: you can use it with any instance method. For example the `info` method is not a method given to us by `attr_accessor` but we can still call it using the `self.info` \n\n``` ruby\nclass GoodDog\n  # ... rest of the code omitted for brevity\n  def some_method\n   self.info \n  end \nend \n\n```\n\n</details>"
    }
  ]
}