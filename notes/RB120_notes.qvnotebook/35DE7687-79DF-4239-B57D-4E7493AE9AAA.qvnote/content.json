{
  "title": "OOP book",
  "cells": [
    {
      "type": "markdown",
      "data": "<details> <summary> The Object model </summary>\n\n###Why object oriented programming?\n\n**Encapsulation**:  hiding pieces of code functionality and making it unavailable to the rest of the code base.  it is a form of data protection, so that the data cannot be manipulated or changed without obvious intention.\n\n**Polymorphism**: is the ability for the data to be represented as many different types. OOP gives us flexibility in using pre-written code for new purposes. \n\n**Inheritance**: a class inherits the behaviors of another class, referred to as a *superclass*.  Giving ruby users the power to define basic classes with large reuseability.  and smaller classes for more fine-grained, detailed behavior. \n\n**module**: Is another way to apply polymorphic structures to ruby programs. `modules` like classes contain shared behavior. you cannot create an object with a `module`, an module must be mixed in (a mixin) with a class using the `include` method invocation. \n\n###What are objects?\n\n**Objects in ruby**:  numbers, strings, arrays, classes and modules. \n\n**things which are not objects**: methods and blocks are two which stand out \n\nobjects are created from classes. think as classes as molds, and objects are the parts being produced. \n\n###Classes define objects\n\nRuby defines the attributes and behaviors of its objects in classes. Think of classes as a basic outline of what an object should be made of and what it should be able to do. \n\nto define a class: replace the `def` with `class` and use the CamelCase to create the name.  \n\n```ruby\nclass GoodDog\nend\n\nsparky = GoodDog.new\n```\nin the above example we have created an instance of our `GoodDog` class and stored it in the variable `sparky`.  The workflow of creating a new object or instance from a class is called `instantiation`. So we can say that we instantiated an object called `sparky` from The class `GoodDog`. the object is returned by calling the class method `new`. \n\n###Modules \n\nModule:  a collection of behaviors that is usable in other classes via **mixins**. A module is \"mixed in\" to a class using the include method invocation. \n\nbelow is an example of how you mix in a module into other classes.\n\n``` ruby\n\nmodule Speak\n  def speak(sound)\n    puts sound \n  end \nend \n\nclass GoodDog \n  include Speak \nend\n\nclass HumanBeing \n  include Speak \nend \n\nsparky = GoodDog.new\nsparky.speak(\"Arf!\")  #=> Arf!\nbob = HumanBeing.new \nbob.speak(\"Hello!\")   #=> Hello!\n\n```\n\n###Method Lookup \n\nRuby has a distinct look up path it follows each time a method is called. `ancestors` method can be called on any class to find out the method lookup chain. \n\n``` ruby\n\nmodule Speak\n  def speak(sound)\n    puts \"#{sound}\"\n  end\nend\n\nclass GoodDog\n  include Speak\nend\n\nclass HumanBeing\n  include Speak\nend\n\nputs \"---GoodDog ancestors---\"\nputs GoodDog.ancestors\nputs ''\nputs \"---HumanBeing ancestors---\"\nputs HumanBeing.ancestors\n```\nThe output: \n\n```ruby \n---GoodDog ancestors---\nGoodDog\nSpeak\nObject\nKernel\nBasicObject\n\n---HumanBeing ancestors---\nHumanBeing\nSpeak\nObject\nKernel\nBasicObject\n```\nThis shows that `speak` method is not defined in the `GoodDog`class.  The next place it looks is the `Speak` module.  It continues this until the method is either found or there are no more places to look. \n\n</details>\n\n<details><summary> classes and objects part 1 </summary>\n\n###states and behaviours \n\n`classes` are used to create objects\n`states` track attributes for individual objects\n`behaviors` are what objects are capable of doing \n\n###initializing a new object \n\n``` ruby\n\nclass GoodDog\n  def initialize \n    puts \"This object as initialized!\"\n  end\nend \n\nsparky = GoodDog.new  # => \"This object was initialized!\"\n\n```\n\nThe `initialize` methods everytime you created a new object. \n\nwe refere to the `initialize` method as a **constructor**, because it gets triggered whenever we create a new object. \n\n###Instance Variables \n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end\nend \n\n```\n\n`instance variable` is a variable that has the `@` symbol in front of it (example `@name = name`).  An `instance variable` is a variable that exists as long as the object instance exists, and it is a way to tie data to objects. It does not \"die\" after the initialize method is run. It \"lives on\" to be referenced, until the object instance is destroyed. \n\nnow creating an object using the `GoodDog` class from above. \n\n```ruby\nsparky = GoodDog.new(\"Sparky\")\n```\n\nHere the string \"Sparky\" is being passed from the `new` method through to the `initialize` method and is assigned to the local variable `name`.  Within the constructor (i.e., the `initialize` method) we then set the instance variable `@name` to point to the same object that `name` is referencing. Which results in assigning the string \"Sparky\" to the `@name` instance variable. \n\n\n###Instance Methods\n\ncurrently the `GoodDog` class cant really do anything.  lets give it some behaviors\n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def speak \n    \"Arf!\"\n  end \nend \n\nsparky = GoodDog.new(\"Sparky\")\nsparky.speak\n\n```\nnow suppose we have another `GoodDog` object \n\n\n```ruby \nfido = GoodDog.new(\"Fido\")\nputs fido.speak   #=> Arf\n```\nthe second object `fido` can also perform GoodDog behaviors. All the objects of the same class have the same behaviors, but they contain different states.  In this case the differing state is the name. \n\nwhat if you wanted to output \"Sparky says Arf!\"\n\n``` ruby\n\ndef speak \n  \"#{@name} says arf!\"\nend \n\n```\n\nno you can expose information about the state of the object using instance methods \n\n```\nputs sparky.speak '# => \"Sparky says arf!\"\nputs fido.speak '# => \"Fido says arf!\"\n\n```\n\nif you want to get the name, add a *getter* method\n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def speak \n    \"Arf!\"\n  end \n  \n  def get_name\n    @name\n  end\n  \nend \n\nsparky = GoodDog.new(\"Sparky\")\nsparky.speak   # => Sparky says arf!\nputs sparky.get_name  # => Sparky\n```\nnow we need to add a setter method\n\n\n``` ruby\n\nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def speak \n    \"Arf!\"\n  end \n  \n  def set_name = (name)\n    @name = name \n  end \n  \n  def get_name\n    @name\n  end\n  \nend \n\nsparky = GoodDog.new(\"Sparky\")\nsparky.speak   # => Sparky says arf!\nputs sparky.get_name  # => Sparky\nsparky.set_name = \"Spartacus\"\nputs sparky.get_name # => Spartacus \n```\nAs a convention rubyists typically want to name those getter and setter methods using the same name as he instance variable they are exposing and setting. The update code should be as follows:\n\n``` ruby \nclass GoodDog\n  def initialize(name)\n    @name = name\n  end \n  \n  def name \n    @name\n  end \n  \n  def name=(n)\n    @name = n\n  end \n  \n  def speak\n    \"{@name} says arf!\"\n  end \n  \n  sparky = GoodDog.new(\"Sparky\")\n  puts sparky.speak   #=> Sparky says arf!\n  puts sparky.name    #=> \"Sparky\"\n  sparky.name = \"Spartacus\"  \n  puts sparky.name   #=> \"Spartacus\" \nend \n```\n\nthese getter and setter methods are very long. \nwould make the code even longer. because the methods are so common place Ruby has a built in way to automatically correct using **attr_accessor**\n\n``` ruby\n\nclass GoodDog\n  attr_accessor :name\n  \n  def initialize(name)\n    @name = name\n  end\n  \n  def speak \n     \"#{@name} says arf!\"\n  end \nend \n\n  sparky = GoodDog.new(\"Sparky\")\n  puts sparky.speak\n  puts sparky.name  # => \"Sparky\"\n  sparky.name = \"Spartacus\"\n  puts sparky.name  # => \"Spartacus\"\n\n```\nif you only want the `getter` method without the `setter` method then you would want to use the `attr_reader`. Which works the same way but only allows you to retrieve the instance variables. If you only want the setter method you can use the attr_writer method. All of the `attr_` methods take a symbol as a parameter ]. if there are more states you are tracking you can use this syntax. \n\n```ruby\nattr_ancestor :name, :height, :weight\n```\n\n###Accessor methods in action \n\n```ruby\n\ndef speak \n  \"#{@name} says arf!\"\nend \n```\ninstead of referencing the instance variable directly we want to use the name getter method that we created earlier and is provide by the `attr_accessor` method, so it will now look like : \n\n```ruby\ndef speak \n  \"#{name} says arf!\"\nend\n``` \nwe are now calling the instance method rather than the instance variable. why do this instead of just calling the instance variable?  Its generally a good idea to call the getter method instead of call the instance variable. \n\nsuppose we add two states to the `GoodDog` class called `height` and `weight`\n\nNow suppose we create a new method which changes several states at once `change_info(n, h, w)`.\n\nTo disambiguate from creating a local variable we need to use `self.name=` to let ruby know that we are calling a method. So our `change_info` should be update to this: \n\n``` ruby\n\ndef change_info(n, h, w)\n  self.name = n\n  self.height = h\n  self.weight = w \nend \n\n```\nto be consistent we could adopt this syntax for getter methods as well, though it is not required. \n\n``` ruby\n\n\"#{self.name} weighs #{self.weight} and is #{self.height} tall.\"\n\n```\n\nnote that prefixing `self`. is not restricted to just the `accessor` methods: you can use it with any instance method. For example the `info` method is not a method given to us by `attr_accessor` but we can still call it using the `self.info` \n\n``` ruby\nclass GoodDog\n  # ... rest of the code omitted for brevity\n  def some_method\n   self.info \n  end \nend \n\n```\n\n</details>\n\n<details><summary>  Classes and Objects - Part 2 </summary>\n\n\n**class methods**: class methods are methods at the class level which can be called directly on the class itself, without having to instantiate any objects. \n\nwhen defining a class method we prepend the method name with the reserve word `self`, like this. \n\n``` ruby \n# ... rest of the code omitted for brevity \n\ndef self.what_am_i  #Class method Definition \n  \"I'm a GoodDog class\"\nend\n\n```\n\n##Class Variables \n\nWe can create variables for an entire class that are appropriately named `class variables`. \nclass variables are created using two `@` symbols, so `@@`. \n\n\n``` ruby\n\nclass GoodDog\n  @@number_of_dogs = 0\n  \n  def initialize \n    @@number_of_dogs += 1\n  end\n  \n  def self.total_number_of_dogs\n    @@number_of_dogs\n  end\nend \n\nputs GoodDog.total_number_of_dogs # => 0\n\n\ndog1 = GoodDog.new \ndog2 = GoodDog.new\n\nputs GoodDog.total_numhber_of_dogs # => 2\n\n```\nwe have a class variable `@@number_of_dogs` which we initilize to 0.\n\nThen in our constructor (the `initialize` method) we increment the number by 1.   This demonstrates that we can acess class variables from within an instance method (initialize is an instance method).  Finally, we just return the value of the class variable in the class method.  This is an example of using a class variable and a class method to keep track of a class level detail that pertains only to the class and not the individual objects. \n\n###constants \n\n\nyou define a constant by using an upper case letter at the beginning of the variable name. \n\nhowever most Rubyiest will make the entire variable uppercase.\n\n```ruby \n\nclass GoodDog\n  DOG_YEARS = 7 \n  \n  attr_accessor :name, :age \n  \n  def initialize(n, a)\n    self.name = n\n    self.age = a * DOG_YEARS\n  end \n  \nend \n\nsparky = GoodDog.new (\"Sparky\", 4)\nputs sparky.age   # => 28 \n\n```\n\n\n``` ruby \nclass GoodDog  # the class gooddog is created\n\n  DOG_YEARS = 7  # a constant DOG_YEARS is set to point to the integer 7 \n\n  attr_accessor :name, :age  #This creates a getter method with method called name, and age\n  \n\n  def initialize(n, a)  #you can pass arguments into this create a new object\n  \n      Note that we used the setter methods in the initialize method to initialize the @name and @age instance variables given to us by the attr_accessor method\n  \n    self.name = n  #you call the `name` method created above using the attr_accesor on self. Self will represent the object it is being called on. \n    \n    self.age  = a * DOG_YEARS  #same as above. \n    \n    \n  end\nend\n\nsparky = GoodDog.new(\"Sparky\", 4)  #\nputs sparky.age             # => 28\n```\n###The to_s method \n\n```ruby\nputs sparky # => #<GoodDog:0x007fe542323320>\n```\n\nthe `puts` automatically calls the `to_s` on its argument.  which in this case is the `sparky` object.  \n\nIn other words puts sparky is equivalent to puts sparky.to_s. \n\nBy default the to_s method returns name of the object class and an encoding of the object id. \n\nNOTE:  `puts` method calls `to_s` for any argument which is not an array. For an array, it writes on seperate lines, the result of calling `to_s` on each element of the array. \n\nTo test this we add a custom `to_s` method to our `GoodDog` class. overriding the default `to_s` that comes with ruby \n\n``` ruby\n\nclass GoodDog\n  DOG_YEARS = 7 \n  \n  attr_accessor :name, :age\n  \n  def initialize(n, a) \n    @name = n\n    @age = a * DOG_YEARS\n  end \n\n  def to_s \n    \"This dog's name is #{name} and it is #{age} in dog years.\"\n  end \n  \nend \n\nputs sparky.to_s # => This dog's name is Sparky and it is 28 in dog years. \n\n```\n\nThere is another method called `p` thats very similar to `puts`. except it doesn't call `to_s` on its arguments. It calls another built in ruby instance called `inspect`.   The `inspect` method is very helpful for debuggin purposses so we dont want to overide it. \n\n```ruby \np sparky   # => #<GoodDog:0x007fe54229b358 @name=\"Sparky\", @age=28>\n```\nThis output implies that `p sparky` is equivalent to `puts sparky.inspect`\n\nanother important attribute of the `to_s` method is that it's also automatically called in string interpolation. \n\n``` ruby\n\nirb :001 > arr = [1, 2, 3]\n=> [1, 2, 3]\nirb :002 > x = 5\n=> 5\nirb :003 > \"The #{arr} array doesn't include #{x}.\"\n=> The [1, 2, 3] array doesn't include 5.\n\n\n``` \n\nhere the `to_s` is called automatically on the object when we use it with `puts` or when used with string interpolation. \n\n\nWe'll see if we can include our `sparky` object in string interpolation. \n\n```ruby\nirb :001 > \"#{sparky}\"\n=> \"This dog's name is Sparky and it is 28 in dog years.\"\n```\n\nin summmary the `to_s` is called automatically on the object when it is used with string interpolation.\n\n###More about self \n\nso far we have seen two clear uses of self\n\n1. use self when calling setter methods from within the class. earliers `self` was used to disambiguate between intializing a local variable and callign a setter method.\n\n2. Use self for class method definitions. \n\nlets play around to see why the two rules work.  Let's assume the following code. \n\n``` ruby \n\nclass GoodDog\n\n  attr_accessor :name, :height, :weight\n  \n  def initialize(n, h, w)\n    self.name = n\n    self.height = h\n    self.weight = w\n  end \n  \n  def change_info(n, h, w) \n    self.name = n\n    self.height = h\n    self.weight = w\n  end \n  \n  def info \n    \"#{self.name} weighs #{self.weight} and is #{self.heigh} tall. \n  end \n\n``` \nabove we use `self` whenever we call an instance method from within the class. \n\n\nwe know the rules to use `self` but what does self really represent. \n\n```ruby\nclass GoodDog\n  #... rest of code omitted for brevity\n  \n  def what_is_self \n    self\n  end \nend \n\n```\nnow we can instantiate a new `GoodDog` object\n\n``` ruby \nsparky = GoodDog.new('Sparky', '12 inches', '10 lbs')\np sparky.what_is_self\n# => #<GoodDog:0x007f83ac062b38 @name=\"Sparky\", @height=\"12 inches\", @weight=\"10 lbs\">\n\n\n``` \nfrom within the class when an instance method uses `self` it references the calling object. In this case the `sparky` object.  Therefore from within the `change_info` method, calling `self.name=` acts the same as calling `sparky.name=` from outside the class (you can't call `sparky.name=` inside the class, though, since it isn't in the scope). \n\nthe other place we us `self` is when we're defining class methods, like this: \n\n```ruby \nclass MyAwesomeClass\n  def self.this_is_a_class_method\n  end \nend \n\n```\n\nWhen `self` is prepended to a method definition, it is defining a class method. We went over this earlier. n our  `GoodDo` class method example, we defined a class method called `self.total_number_of_dogs`. this method returned the value of the class variable `@@number_of_dogs`\nhow is that possible?\n\n``` ruby\nclass GoodDog\n  #... rest of code omitted for brevity\n  puts self \nend \n```\nThen you can test it in \"irb\" just by psting the above code into irb and typing \"GoodDog\"\n\n\n```ruby\nirb :001 > GoodDog\n=> GoodDog\n``` \n\nThus, you can see that using `self` inside a class but outside an instance method refers to the class itself. Therefore, a method deinition prefixed with `self` is the same as deifning the method on the class. That is, `def self.a_method` is equivalent to `def GoodDog.a_method`.  That's why its a class method; it's actually being defined on the class. \n\nTo be clear, from within a class..\n\n1. `self`, inside of an instance method, references the instance (object) that called the method- the calling object. Therefore, `self.weight=` is the same as `sparky.weight=`, in our example.\n2. `self`, outside of an instance method, references the class and can be used to define class methods.  Therefore, `def self.name=(n)` is the same as `def GoodDog.nam= (n)`, in our example \n\nThus, we can see that `self` is a way of being explicit about what our program is referencing and what our intentions are as far as behariou.  `self` changes depdning on the scope it is used in, so pay attention to see if you're inside an instance method or not.  `self` is a trickey concept to grasp in the beggining. \n\n</details>\n\n<details><summary> Inheritance </summary>\n\nInheritance is when a class inherits behavior from another class. The class that is inheriting behavior is called the subclass and the class it inherits from is called the superclass. \n\nWe use inheritance as a way to extract common behaviors from the classes that share that behavior, and move it to a superclass \n\n\n###Class inheritance \n\nhere we are extracting the `speak` method to a superclass `Animal` and we use inheritance to make the behavior available to `GoodDog` and `Cat` classes.\n\n\n```ruby\n\nclass Animal\n  def speak\n    \"Hello!\"\n  end \nend \n\nclass GoodDog < Animal\nend\n\nclass Cat < Animal \nend \n\nsparky = GoodDog.new\npaws = Cat.new\nputs sparky.speak  # => Hello!\nputs paws.speak  # = > Hello!\n\n```\n\nWe use the `<` symbol to signify that the `GoodDog` class is inheriting from the `Animal` class. This means that all the methods in the `Animal` class are available to the `GoodDog` class for use. \n\nbut what if we want to use the original `speak` method from the `GoodDog` class onluy.  Let's add it back and see what happens. \n\n``` ruby\nclass Animal \n  def speak \n    \"Hello!\"\n  end\nend \n\nclass GoodDog < Animal\n  attr_accessor :name\n  \n  def initialize(n)\n    self.name = n\n  end \n  \n  def speak\n    \"#{self.name} says arf!\"\n  end \nend \n\nclass Cat < Animal\nend \n\nsparky = GoodDog.new(\"Sparky\")\npaws = Cat.new \n\nputs sparky.speak # => Sparky says arf!\nputs paws.speak  # => Hello!\n\n``` \n\nIn the `GoodDog` class, we're overriding the `speak` method in the `Animal` class because Ruby checks the object's class first for the method before it looks in the superclass. That means when we wrote the code `sparky.speak` it first looked at `sparky`'s class, which is `GoodDog`.  It found the `speak` method there and used it.   When wer wrote the code `paws.speak` ruby first looked at `paws`'s class, which is `Car`.  It did not find a `speak` method there, so it continued to look in `Cat`'s superclass, `Animal`.  \n\nInheritance can be a great way to remove duplication in your code base. \n\n###Super \n\nruby has a built in function called `super` that allows us to call methods up the inheritance hierarchy. \n\nwhen you call `super` from within a method. it will serach the inheritance hierarchy for a method by the same name and then invoke it. \n``` ruby\n\nclass Animal\n  def speak\n    \"Hello!\"\n  end \nend \n\nclass GoodDog < Animal\n  def speak\n    super + \" from GoodDog class\"\n  end \nend \n\nsparky = GoodDog.new\nsparky.speak # => \"Hello! from GoodDog class\"\n```\nAnother more common way of using super is with `initialize` \n\n```ruby\n\nclass Animal\n  attr_accessor :name\n  \n  def initialize(name)\n    @name = name\n  end \nend \n\nclass GoodDog < Animal\n  def initialize(color)\n    super \n    @color = color\n  end \nend \n\nbruno = GoodDog.new(\"brown\")  => #<GoodDog:0x007fb40b1e6718 @color=\"brown\", @name=\"brown\">\n\n```\nIn this exampler, we're using `super` with no argumetns.  HOwever, the `initialize` method, where `super` is being used, takes and argument and adds a new twist to how `super` is invoked. Here, in addition to the defualt behavior, super automatically forwards the arugmetns that were passed to the amethod from which `super` is called  (`initialize` method in `GoodDog` class).  At this point, `super` will pass the `color` argumetn in the `initialize` defined in the to that of the `Animal` superclass and invoke it.  That explains the presence of the `@name= \"brown\"` when the `bruno` instance is created. Finally, the subclass` `initialize` continues to set the `@color` instance variable. \n\n\nWhen called with specific arguments, eg. `super(a, b)` the specified arguments will be sent up the method lookup chain.  example \n\n``` ruby\nclass BadDog < Animal\n  def initialize(age, name)\n    super(name)\n    @age = age\n  end\nend \n\nBadDog.new(2, \"bear\") # => #<BadDog:0x007fb40b2beb68 @age=2, @name=\"bear\">\n\n```\n\n###Mixing in Modules\n\nAnother way to DRY (don't repeat yourself) you your code in Ruby is to use modules.   \n\n\nExtracting common methods to a superclass, like we did in the previous section, is a great way to model concepts that are naturally hierarchical. \n\nBut sometimes you you have methods that do not fall into a hierarchy but are repeated in different parts of the hierarchy.  For concerns such as these, we'd like to group them inot a module and then mix n that module to the classes that require those behaviours. example:\n\n```ruby\nmodule Swimmable\n  def swim\n    \"I'm swimming!\"\n  end\nend \n\nclass Aniaml; end \n\nclass Fish < Animal\n  include Swimmable   # mixing in Swimmable module \nend \n\nclass Mammal < Animal \nend \n\nclass Cat < Mammal \nend\n\nclass Dog < Mammal\n  include Swimmable  #mixing in Swimmable module \nend \n\n```\n\nand now `Fish` and `Dog` objects can swim, but objects of other clases won't be able to:\n\n```ruby\n\nsparky = Dog.new\nneemo = Fish.new\npaws = Cat.new\n\nsparky.swim  # => I'm swimming!\nneemo.swim # => I'm swimming!\npaws.swim   # => NoMethodError\n\n```\n\n###Inheritance vs Modules \n\nTwo primary ways that Ruby implements inheritance.  `Class inheritance` is the traditional way to think about inheritance: one type inherits the behavior of another type. The result is a new type that specializes the type of the super class. \n\nThe other form is called `interface inheritance`: this is where mixin modules come into play. The class doesn't inherit from another type, but instead inherits the interface provided by the mixin module. In this case the result type is not a specialized type with respect to the module.  \n\nguidelines for using inheritance vs mixin: \n\n- you can only subclass (class inheritance) from one class. You can mix in as many modules (interface inheritance) as you'd like. \n- If there's an \"is-a\" relationship, class inheritance is usually the correct choice. If there is a \"Has-a\" relationship, interface inheritance is usually the better choice. Ex.  a dog \"is an\" animal and it \"has an\" ability to swim. \n- you can not instantiate modules (i.e. no objects an be created from a module). Modules are used only for namespacing and grouping common methods together. \n\n\n###Method look-up path\n\nlets see how both inheritance and mixins affect the *method lookup path*. \n\n``` ruby\nmodule Walkable\n  def walk\n    \"I'm walking\"\n  end\nend\n\nmodule Swimable \n  def swim\n    \"I'm swimming\"\n  end\nend \n\nmodule Climable\n  def climb\n    \"I'm Climbing\"\n  end\nend \n\nClass Animal \n  include Walkable \n  \n  def speak\n    \"I'm an animal, and I speak\"\n  end\nend \n\n```\n\nwe have three modules and one class. we've mixed in one module into the `Animal` class. The method lookup path is the path Ruby takes to look for a method. We can see is path with the `ancestors` class method. \n\n```ruby\n\nputs \"---Animal method lookp---\"\nputs Animal.ancestors\n```\n\n```\n---Animal Method lookup---\nAnimal\nWalkable\nObject\nKernal\nBasicObject\n```\nThis means that when we call a method of any `Animal` object, first Ruby looks into the `Animal` class, then the `Walkable` module, then the `Object` class, then the `Kernel` module, and finally the BasicObject class. \n\n```ruby\nfido = Animal.new \nfido.speak   #=> I'm an animal, and I speak! \n```\n\nRuby found the `speak` method in the `Animal` class and looked no further.\n\n```ruby\nfido.walk  # => I'm walking \n```\nRuby first looked for the `walk` instance method `Animal`.  Not finding it there it continued looking in the next place according to our list, which is the `Walkable` module. It saw `walk` method there, executed it and stopped looking further. \n\n``` ruby\nfido.swim  #NoMethodError\n```\n\nRuby traversed all the classes and modules in the list, and didn't find a method `swim` so it threw an error.\n\nlets add another class to the above code.  This class will inherit from the `Animal` class and mix in the `Swimmable` and `Climbable` modules. \n```ruby\nclass GoodDog < Animal\n  include Swimmable\n  include Climable\nend \n\nputs \"---GoodDog method Lookup--\"\nputs GoodDog.ancestors\n```\nadne this is the output we get \n\n```ruby\n---FoodDog method lookup---\n\nGoodDog\nClimbable\nSwimable\nAnimal\nWalkable\nObject\nKernel\nBasicObject\n\n```\n\nThis shows us that the order that we include modules is important.  Ruby actually looks at the last module we included first.  \nThe second interesting thing is that the module included in the superclass made it on to the method lookup path.  That means that all `GoodDog` objest will have aces to not only `Animal` methods, but also methods defined in the `Walkable` module, as well as ll other modules mixed in to any of its superclasses \n\n###More modules \n\nWe've already seen how we can mixin common behavior into classes. Now we'll see two more uses or modules. \n\nThe first use case we'll discuss is using modules for **namespacing**: organizing similar classes under a module. Use modules to group related classes, making it easy to for us to recognize related classes in our code. \n\nThe second advantage is it reduces the likelihood of our classes colliding with other similarly named classes inour codebase. Here's how we do it:\n\n```ruby\nmodule Mammal \n  class Dog\n    def speak(sound)\n      p \"#{sound}\"\n    end\n  end \n  \n  class Cat\n    def say_name(name)\n      p  \"#{name}\"\n    end\n  end \nend\n\n``` \n\nwe call classes in a module by appending the class name to the module name with two colons(`::`)\n\n``` ruby\nbuddy = Mammal::Dog.new\nkitty = Mammal::Cat.new\nbuddy.speak('Arf!')   # => \"Arf!\"\nkitty.say_name('kitty')  #=> \"kitty\"\n\n```\n\nThe second use case for modules we'll look at is using modules as a `container` for methods, called module methods. This involves using modules to house other methods.  This is very useful for methods that seem out of place within your code.  Let's use our `Mammal` module to demonstrate: \n\n\n```ruby\nmodule Mammal\n   ...\n   \n   def self.some_out_of_place_method(num)\n     num ** 2\n  end \nend   \n\n```\n\nDefining methods this way within a modules means wwe can call them directly from the module.\n\n```ruby\n\nvalue = Mammal.some_out_of_place_method(4)\n\n```\n\nwe can also call such methods by doing:\n\n```ruby\nvalue = Mamml::some_out_of_place_method(4)\n```\nalthough the former is the preferred way. \n\n\n###Private, Protected, and Public\n\nright now all the methods in our `GoodDog` class are public methods.\n\na **public method** is a method that is available to anyone who knows either the class name or the object's name. These methods are readibly available for the rest of the program to use and comprise the class's interface (that's how other classes and objects will interact with this class and its objects). \n\n**Private** methods are methods that are doing work in the class but don't need to be available to the rest of the program.  We us the `private` method call in our program and anything below it is private, unless another method like `protected` is called after it to negate it. \n\nWhen we initialize an object in the GoodDog class, we calculate the dog's age in Dog years. Lets refactor this logic into a method an make it private so nothing outside the class can use it. \n\n```ruby\n\nclass GoodDog\n  Dog_years = 7 \n  \n  attr_accessor :name, :age\n  \n  def initialize(n, a)\n    self.name = n\n    self.age = a\n  end \n  \n  private\n  \n  def human_years\n    age * DOG_YEARS\n  end\nend \n\nsparky = GoodDog.new(\"Sparky\", 4)\nsparky.human_years \n\n``` \n\nwe get the error message:\n\n```ruby\n NoMethodError: private method `human_years' called for\n  #<GoodDog:0x007f8f431441f8 @name=\"Sparky\", @age=4>\n\n```\n\nwe have made the `human_years` method private by placing it under the `private` method call.  What is it good for, then, if we can't call it?  `private` methods are only accessible from other methods in the cass.  For example, given the above code, the following wold be allowed\n\n```ruby\n\n#assume the method definition below is above the \"private\"\n\ndef public_disclosure\n  \"#{self.name} in human years is #{human_years}\"\nend \n```\nNote that in this case, we can not use `self.human_years`, because the `human_years` method is private.  Remember that the `self.human_years` is equivalent to the `sparky.human_years`, which is not allowed for private methods. Therefore, we have to just use `human_years`.  In summary, privte methods are not acessible outside of the class defintional at all, and are only accessible from inside the class when called without `self`.\n\n***as of ruby 2.7, it is now legal to call private methods with a literal `self` as the caller.\n\nwe use the `protected` keyword to create protected methods.  The easiest way to understand protected methods is to follow these two rules:\n\n- from inside the class, `protected` methods are accessible just like `public` methods.\n- from oustdie the class, `protected` methods act just like private methods. \n\n\nExample of `protected` methods:\n\n```ruby\n\n\nclass Animal\n  def a_public_method\n    \"Will this work?\" + self.a_protected_method\n  end \n  \n  protected\n  \n  def a_protectec_method\n     \"Yes, I'm protected!\"\n  end \nend\n```\n\n```ruby\nfido = Animal.new\nfido.a_public_method # => Will this work?  Yes, I'm protected!\n```\nThe above line of code shows us that we can call a `protected` method rom within the class, even with `self` prepended.  What about outside of the class?\n\n```ruby\nfido.a_protected_method\n  # => NoMethodError: protected method `a_protected_method`\n```\n\nThis deomonstrates the second rule, that we can't call protected methods from outside of the class. The two rules for `protected` methods apply within the context of inheritance as well. \n\nprotected methos are not used often in practie and that knowledge isn't transferrable to other languages. so just rememebr those tow rules. \n\n###Accidental Method Overriding \n\nIt's important to remember that every class you create inherently subclasses from `class Object`.  The `Object` class is built into Ruby and comes with many critical methods.\n\n```ruby\n\nClass Parent\n  def say_hi\n    p \"Hi from Parent.:\n  end\nend \n\nParent.superclass # => Object\n```\n\nThis means that methods defined in the `Object` class are available in all classes. \n\nFurther, recall that through the magic of inheritance, a subclass can override a superclass's method.\n\n```ruby\nclass Child < Parent\n  def say_hi\n    p \"Hi from Child.\"\n  end \nend \n\nchild = Child.new\nchild.say_hi   # => \"Hi from Child.\"\n\n```\n\nThis means that, if you accidentally override a method that was originally definied in the `Object` class, it can have far-reaching effects on your code.  \n\nFor example `send` is an instance method that all classes inherit from `object`.  If you define a new `send` instance in your class, all objects in your class will call the custom `send` method instead of the ones in the `object` class.  \n\nObject `send` serces a way to call a method by passing it a symbol or a string which represnets the method you want to call. \n\n\n``` ruby\nson = Child.new\nson.send :say_hi   # => \"Hi from Child.\"\n\n```\n\nlets see what happens when we define a `send` method in our `child` class and then try to invoke `Object's` `send` method:\n\n```ruby\nclass Child\n  def say_hi\n    p \"Hi from Child.\"\n  end\n  \n  def send\n    p \"send from Child...\"\n  end\nend \n\nlad = Child.new\nlad.send :say_hi \n\n\n```\n\nNormally we would expect the output of this call to be `\"Hi from Child.\"` but we get \n\n```ruby\nArgumentError: wrong number of arugments ( 1 for 0)\n```\n\nIn our example we pass `send` one argument even though our oerrriden `send` method doesn't take arguments. \n\nLet's take a look at another example by exploring Object's `instance_of?` method.  \n`instance_of?` returns `true` if an object is an instance of a give class and `false` otherwise\n\n```ruby\nc = Child.new\nc.instance_of? Child  # => true \nc.instance_of? Parent # => false \n\n```\n\nNow let's override `instance_of?` within `Child`:\n\n``` ruby\nclass Child\n  # other methods omitted\n  \n  def instance_of?\n    p \"I am a fake instance?\"\n  end\nend \n\nheir = Child.new\nheir.instance_of? Child\n```\nagain we see something completely different though are intition was to use Object's `instance_of?` method: \n\n```ruby\nArgumentError: wrong number of arguments (1 for 0)\nfrom (pry):22:in `instance_of?`\n```\nOne `Object` instance method that's easily overridden without any major side effect is the `to_s` method. \n</details>"
    }
  ]
}