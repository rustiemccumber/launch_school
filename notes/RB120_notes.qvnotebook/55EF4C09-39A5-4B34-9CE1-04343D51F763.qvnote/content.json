{
  "title": "RB129 Study Guide for Test",
  "cells": [
    {
      "type": "markdown",
      "data": "### Specific Topics of Interest\n\n#### [x] Classes and Objects\n\nA class is a combination of states, and behaviors which can be used as a blue print to instantiate objects.\n\nobjects are anything which have a value  (arrays, integers, strings, hash) are all objects.  instances of classes form objects, or objects can be instantiated from classes.\n\n\n```ruby\nclass GoodDog\nend\n\nsparky = GoodDog.new\n```\n\nfrom example above we can say that we've instantiated an object called `sparky` from the class `GoodDog`\n\n- [x] Use `attr_*` to create setter and getter methods\n\nattr_accessor is a ruby method that takes a symbol as an argument, the symbol is then used as the name of the getter/setter instance method. This cuts done the length of the code signficantly. \n\n- [x] How to call setter and getters\n\nyou can call getter and setter methods just like any other instance method. for the getter method you usually do some thing object.get_name, and object.set_name =. ruby's syntatical sugar lets you drop the paratheiss to make it more readable (the setter method).\n\n- [x] Instance methods vs. class methods\n\nInstances mehtods are available to be called on objects (or instances of a class).  class methods can be called on the class themselve and are prepended with `self.`\n\n- [x] Referencing and setting instance variables vs. using getters and setters\n- [x] Class inhertiance, [encapsulation](https://launchschool.com/books/oo_ruby/read/the_object_model#whyobjectorientedprogramming), and [polymorphism](https://launchschool.com/books/oo_ruby/read/the_object_model#whyobjectorientedprogramming)\n you should review encapsulaiton and polymorphism a bit more to tell the difference.\n  **polymorphism** is making data sufficently generic such that it can be made available throughout different parts of a code, to aid in DRY code.  Inheritance through class inheritance and interface inheritance (modules) are two examples of polymoprhism.\n  **encapsulation**, is hiding parts of the implementation of a code, and only intentionally exposing parts of the information to to public interface.  It is what defines the boundaries in your applicaiton and allows your code to achieve new levels of complexity. ruby does this by creating objectgs and exposing interfaces to interact with those objects. It is a form of data protection\n- [] Modules\n  Modules are anohter way to achieve polymorphism in Ruby.  A module is a collection of behaviors that is usable in other classes via **mixins**.  A module is \"mixed in\" to a class using the `include` method invocation.  \n  with class inheritance a class can only inherit from one parent class, but it can inherit from as many module as you want.  This will let you insert behavior throughout a class hierarchy to a selection of the classes which have the behavior.  Typically you use class inheritance when the sub class has a \"is a\" relation ship with a the parent class, and you use interface inheritance (modules) when the class has a \"has a\" relationship, a dog has an ability to swim\n  you cannot instantiate from a module, no object can be created from a module.\n- [] Method lookup path\nyou can call Ancestors on any class in ruby and it will go through the the method lookup path.  first it will look in the subclass that the method was called in, then it will look in the last module called, then it will look in the module before that was called, then it will go up the hierachy starting all to way up to object, kernel and basic object.\n- [] self\n  - [calling methods with self](https://launchschool.com/books/oo_ruby/read/classes_and_objects_part1#callingmethodswithself)\n  - [More about self](https://launchschool.com/books/oo_ruby/read/classes_and_objects_part2#moreaboutself)\n  \n- [] Readding OO code\n- [] Fake operators and equality\n\n![fake_operators.png](quiver-image-url/36C773E313D16AB760536DB2DA4E736E.png =919x611)\n- [] Truthiness\n  - ruby has to decide wheteher values count as true or false. If the value isn't literally \"ture\" but evaluates as true, we call it \"turthy\".  Likewise, if the values isn't literally \"false\" but evaluates as false, we call it \"falsey\".  A truthy value is truthy, evaulates to true, but you can't say \"is true\" unless it is literally 'true'.  All values are truthy, or evaluate to true, other than `nil` an `0`\n- [] Working with collaborator objects\n  - Objects that are stored in the state of another object are called collaborator objects. \n  - the relationship that a collaboration creates is called **association**: which can be thought of as a has-a relatiohsip. For example, a library has books, so there is an assoicative relationsip between objects of class Library and objects of class Book.\n  - the collaborative relationship exists in the design of our code; in terms of actual objects you could say that the association or collaboration takes place wehn we add one objec to the state of another object. \n\n\n### Precision of Language\n\nsome questions require that you explain code or concepts with words.  I'ts important to explain hbow code works using precise vocabulary and to pinpoint the causal mechanism at work. In other words, us the righ words and don't be vague.\n\nFor example, let's take the following piece of code.\n\n```ruby\n\nclass Dog\n  def initialzie(name)\n    @name = name\n  end\n  \n  def say_hello\n    puts \"Woof! My name is #{@name}.\"\n  end\nend\n\n```\n\nIf we ask you to describe this code, you may say that \"It defins a `Dog` class with two methods: an initializer and a mehtod that has a message as a result.\"  This description isn't wrong, but it's imprecise and lcaks some essential details.  An answer like this may receive a score of 5/10 on a 10-point question; 50% is not a passing score.\n\nA more precise answer says that \"This code defines a `Dog` class with two methods:\n\n  - the `#initialize` method that initializes a new `Dog` object, which is does by assigning the instance variable `@name` to the do's name specified by the argument.\n  - The `#say_hello` instance method which prints a message that includes the dog's name in place of `#{@name}`.  `#say_hello` returns `nil`.\n  \n  In programing, we must always concern ourselves with outputs, return value, and object mutations.  we must use the right terms when we speak, and not use vague words like \"results\".  Furhtermore, we need to be explicit about even the smallest details.\n\nWhen writing answers to test questions, make sure you're as precise as poissible, and that you use the proper vocabulary.  Doing this helps you debug and understand more complex code later in your journey.  If your definations are imprecise, you can't use them to decompose a complicated mehtod or program.  Also, you may be unable to pass the test.\n\n### Additional tips \n\nThis assesment has a different style thant the RB109 written assessment, so you should expect severl open-ended questions where you will need to explain certain OOP concepts using code examples.\n\n\nWhile working through the assessment questions it is useful to run your code often to check it, so make sure to have either ruby document/terminal or oline repl prepared beforehand. "
    }
  ]
}