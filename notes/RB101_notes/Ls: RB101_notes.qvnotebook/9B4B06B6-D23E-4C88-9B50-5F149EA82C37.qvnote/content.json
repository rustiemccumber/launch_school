{
  "title": "REGEX Notes (Launch School Introduction to Regex book)",
  "cells": [
    {
      "type": "markdown",
      "data": "###Overview\n\n<details><summary> Overview </summary>\n\n\n\n- Patterns are the building blocks of regex. You construct regex from patterns using concatenation and alternation. You then place the resulting pattern between two / characters.\n- Concatenation and alternation of two patterns create a new pattern.\n- The most basic patterns match a single character, a range of characters, or a set of characters.\n- We call some special characters meta-characters; they have special meaning inside a regex. When you must match one literally, escape it with a leading \\ character.\n- Character class patterns match any character in a set or range of characters or any combination of sets and ranges.\n- Anchors force a regex to match at a specific location inside a string.\n- A quantifier matches a pattern multiple times; they always apply to the pattern to the left of the quantifier. Quantifiers are greedy by default, but also have lazy forms.\n- Parentheses let you combine patterns as a series of alternates. They also provide a way to capture parts of a match for later reuse; when used this way, we call the groups capture groups. We can access captured values with backreferences.\n\n</details>\n\n###Cheat Sheet\n\n*Basic Matching*\n\nPattern\t| Meaning\n--- | ---\n/a/\t| Match the character a\n/\\?/, /\\./\t| Match a meta-character literally\n/\\n/, /\\t/ |\tMatch a control character (newline, tab, etc)\n/pq/\t| Concatenation (p followed by q)\n/(p)/ |\tCapture Group\n/(p|q)/ |\tAlternation (p or q)\n/p/i\t| Case insensitive match\n\n*Character Classes and Shortcuts*\n\nPattern |\tMeaning\n--- | ---\n/[ab]/ |\ta or b\n/[a-z]/ |\ta through z, inclusive\n/[^ab]/\t| Not (a or b)\n/[^a-z]/ |\tNot (a through z)\n/./\t | Any character except newline\n/\\s/, /[\\s]/\t| Whitespace character (space, tab, newline, etc)\n/\\S/, /[\\S]/ |\tNot a whitespace character\n/\\d/, /[\\d]/ |\tDecimal digit (0-9)\n/\\D/, /[\\D]/ |\tNot a decimal digit\n/\\w/, /[\\w]/ |\tWord character (0-9, a-z, A-Z, _)\n/\\W/, /[\\W]/ |\tNot a word character\n\n\n*Anchors*\n\nPattern |\tMeaning\n--- | ---\n/^p/ |\tPattern at start of line\n/p$/ |\tPattern at end of line\n/\\Ap/ |\tPattern at start of string\n/p\\z/ |\tPattern at end of string (after newline)\n/p\\Z/ |\tPattern at end of string (before newline)\n/\\bp/\t| Pattern begins at word boundary\n/p\\b/ |\tPattern ends at word boundary\n/\\Bp/\t| Pattern begins at non-word boundary\n/p\\B/\t| Pattern ends at non-word boundary\n\n*Quantifiers*\n\nPattern |\tMeaning\n--- | ---\n/p*/\t| 0 or more occurrences of pattern\n/p+/\t| 1 or more occurrences of pattern\n/p?/\t| 0 or 1 occurrence of pattern\n/p{m}/ |\tm occurrences of pattern\n/p{m,}/ |\tm or more occurrences of pattern\n/p{m,n}/\t| m through n occurrences of pattern\n/p*?/ |\t0 or more occurrences (lazy)\n/p+?/ |\t1 or more occurrences (lazy)\n/p??/\t| 0 or 1 occurrence (lazy)\n/p{m,}?/ |\tm or more occurrences (lazy)\n/p{m,n}?/\t| m through n occurrences (lazy)\n\n*Common Ruby Methods for Regex*\n\nMethod |\tUse\n--- | ---\nString`#match`| Determine if regex matches a string\nstring `=~`regex |\tDetermine if regex matches a string\nString`#split`\t| Split string by regex\nString`#sub`\t| Replace regex match one time\nString`#gsub`\t| Replace regex match globally\n\n###Basic Matching \n\nAt their most basic, regex are strings of characters between two `/` characters, e.g., At their most basic, regex are strings of characters between two `/` characters, e.g., `/cat/`\n - `/cat/` matches the string 'cat' anywhere it is found in the text. Even in 'catolog', 'scat' etc.\n\nUse `Rubular` to test Regex \n\n\n<details><summary> Special Characters </summary>\n\n\n`$ ^ * + ? . ( ) [ ] { } | \\ /` have special meaning in ruby and are referred to as `meta-characters`\n\nif you want to match a meta-character you must escape it with a leading backslash `\\`, (ex. `/\\?/`).\n\nmeta characters have a meta meaning `()` is `grouping`, `|` is `or`. If you want to match the literal characters you escape before\n</details>\n\n<details><summary> Commonly used </summary>\n\n`:` is not a special character so `/:/`\n`' '`: space must be represented by `/[ ]/`\n</details>\n\n<details><summary> Concatenation </summary>\n\ncan do something like `/cat/` and it will match any string that has `c` followed by `a` follow by `t`\n</details>\n\n<details><summary> Alternation </summary>\n\nalternation: a simple way to construct a regex so that it matches one of several patterns\n\nex: \n\n`/(cat|dog|rabbit)/` will match `cat`, `dog` or `rabbit` anywhere it appears in the string. \n\n</details>\n\n<details><summary> Control character escapes </summary>\n\n`\\n` line feed\n`\\r` carriage return \n`\\t` tabs \n\nNote that not everything that looks like a control character escape is a genuine control character escape. For instance:\n\n`\\s` and `\\d` are special character classes (we'll cover these later)\n`\\A` and `\\z` are anchors (we'll cover these as well)\n`\\x` and `\\u` are specials character code markers (we won't cover these)\n`\\y` and `\\q` have no special meaning at all\n\n</details>\n\n\n\n<details><summary> ignoring cases </summary>\n\nif you want to ignore case of letters (upper, lower) and match any case append `i` to closing `/`\n\n`/launch/i`\n\nwill match `Launch`, `LAUNCH` etc. \n\n</details>\n\n### Character Classes \n\nPatterns which let you specify a set of characters you want to match.\n\n<details><summary> set of characters </summary>\n\ncharacter classes use a list of characters between square brackets ex: `/[abc]/`  Such patterns will match a single occurance of any of the characters between the brackets. \n\nyou can concantenate with character class.  \n`/[abc][12]/`, this matches any two characters where the first is `a`, `b` or `c` and the second is `1` or `2`.\n\nmeta characters within character class include:\n\n`^ \\ - [ ]`\n\nYou can escape any of the special characters, even if you don't have to. Thus, `/[\\*\\+]/` is an acceptable, albeit less readable, equivalent to `/[*+]/`. As before, though, you should keep this list of class meta-characters handy until you know it by heart.\n\n</details>\n\n<details><summary> Range of Characters</summary>\n\n`/[a-z]/` will match all lowercase letters\n`/[A-Za-z]/` will match all lowercase and uppercase letters\n\n</details>\n\n<details><summary> Negated Classes</summary>\n\n\nnegated characters look like ordinary character classes expect the first character between the brackets is a `^`\n\n`/[^y]/`\n\nadditionally you can negate multiple characters\n\n`/[^aeiou]/`\n\n</details>\n\n### Character Class Shortcuts\n\n<details><summary> Any character </summary>\n\n`/./` this will match any character \n\n`/./` does not match new line characters if you want to match those use `/./m`(multiline)\n\n</details>\n\n<details><summary> Whitepace </summary>\n\n `\\s` for whitespace characters: By definition, the whitespace characters are the space (' '), tab ('\\t'), vertical tab ('\\v'), carriage return ('\\r'), line feed ('\\n'), and form feed ('\\f'). Thus, /\\s/ is equivalent to /[ \\t\\v\\r\\n\\f]/\n \n `\\S` for non-whitespace characters, /\\S/ is equivalent to /[^ \\t\\v\\r\\n\\f]/.\n \n `\\s` or `\\S` can be used in or outside of brackets \n \n `/\\s/` represents any whitespace character \n `/[a-z\\s]/` any lowercase alphabetic character or any whitespace characeter \n \n</details>\n\n<details><summary> Digits and Hex Digits </summary>\n\nShortcut |\tMeaning\n--- | ---\n\\d |\tAny decimal digit (0-9)\n\\D |\tAny character but a decimal digit\n\\h\t| Any hexadecimal digit (0-9, A-F, a-f) (Ruby)\n\\H|\tAny character but a hexadecimal digit (Ruby)\n\n</details>\n\n### Anchors \n\nAnchors ensure that a regex matches a string at a specific place: the beginning or end of the string or end of a line, or on a word or non-word boundary.\n\n<details><summary> Matching at the start/end of a line (^ and $) </summary>\n\n`^` is a meta character that fixes a regex match to the beginning of a line of text.\n\n`$` is a meta character that fixes a regex match to the end of a line of text. \n\n`/^cat/` matches any word or pattern in a new line of  string that begins with `cat`.\n\n`/cat$/` matches any word or pattern in a new line of a string that begins with `cat`. \n\nnote that a you can match multiple words/patterns in a string with `^` as long as the word is on the new line of the string. The same is true with the last word in a line with `$`\n\n</details>\n\n<details><summary> Matching at the start/end of a string (\\A and \\Z, \\z) </summary>\n\n`\\A` matches at the beginning of a string\n`\\Z` matches up to but not including the new line at the end of a string\n`\\z` always matches at the end of a string \n\nnote: use `\\z` until that you determine that you need `\\Z`\n\n</details>\n\n<details><summary> Word boundaries (\\b, \\B, \\w, \\W) </summary>\n\n`\\b` matches to word boundaries\n`\\B` matches to non-word boundaries\n`\\w` matches sequences of word characters\n`\\W` matches sequences of non word characters \n\nA `word boundary` occurs (`\\b`): \n\n- between any pair of characters, one of which is a word character and one which is not.\n- at the beginning of a string if the first character is a word character \n- at the end of a string if the last character is a word character. \n\nA `non-word boundary` occurs (`\\B`): \n\n- between any pair of characters, both of which are word characters or both which are not word characters. \n- at the beginning of a string if the first character is a non-word character.\n- at the end of a string if the last character is a non-word character. \n\n\n\nfor example: \n\n```\nEat some food.\n```\nHere, word boundaries occur before the `E`, `s`, and `f` at the start of the three words, and after the `t`, `e`, and `d` at their ends. Non-word boundaries occur elsewhere, such as between the `o` and `m` in some, and following the `.` at the end of the sentence.\n\n</details>\n\n### Quantifiers \n\n<details><summary> * quantifier </summary>\n\n`*` matches 0 or more occurences of the pattern to its left. \n\n`/\\b\\d\\d\\d\\d*\\b/ `\n\n```\nFour and 20 black birds\n365 days in a year, 100 years in a century.\nMy phone number is 222-555-1212.\nMy serial number is 345678912.\n```\n\nYou should see that this pattern matches `365`, `100`, `222`, `555`, `1212`, and `345678912`, but it does not match `20`.\n\nPattern |\tExplanation\n--- | ---\n\\b |\tStarting at a word boundary\n\\d |\tA single digit followed by ...\n\\d |\ta single digit followed by ...\n\\d |\ta single digit followed by ...\n\\d*\t| Zero or more additional digits\n\\b |\tEnding with a word boundary\n\n</details>\n\n<details><summary>One or more (+ quantifier) </summary>\n\nThe `+` is nearly identical to the `*` but instead of matching 0 or more occurences of something it matches one or more occurences. \n\n</details>\n\n<details><summary> Zero or one (? quantifier) </summary>\n\nSuppose you need to test whether a string contains the words cot or coot, but don't want to match against `ct` or `cooot`. In this case, you can use `/coo?t/`, which matches a `c` followed by an `o` followed by an optional `o` followed by a `t`\n\n\n</details>\n\n<details><summary> Ranges </summary>\n\nThe range quantifier consists of a pair of curly braces, `{}`, with one or two numbers and an optional comma between the braces:\n\n`p{m}` matches precisely `m` occurrences of the pattern `p`.\n`p{m,}` matches `m` or more occurrences of `p`.\n`p{m,n}` matches m or more occurrences of `p`, but not more than `n`\n\n</details>\n\n<details><summary> Greediness Laziness </summary>\n\nThe quantifiers we've discussed thus far are `greedy`: they always match the longest possible string they can.\n\nIf you want to match the fewest characters possible we call this a `lazy` match. \n\nIn most cases, `greediness` is what you want. However, sometimes it isn't, and you need to match the fewest number of characters possible; we call this a lazy match. In Ruby and JavaScript, you can request a lazy match by adding a `?` after the main quantifier. For example, `/a[abc]*?c/` matches `abc` and `ac` in `xabcbcbacy`.\n\n</details>\n\n<details><summary> Matching Strings </summary>\n\nmatching url in a text \n\n```ruby\nfetch_url(text) if text.match(/\\Ahttps?:\\/\\/\\S+\\z/)`\\\n```\nsplitting strings\n\n```ruby\nrecord = \"xyzzy\\t3456\\t334\\tabc\"\nfields = record.split(\"\\t\")\n# -> ['xyzzy', '3456', '334', 'abc']\n```\n```ruby\nrecord = \"xyzzy  3456  \\t  334\\t\\t\\tabc\"\nfields = record.split(/\\s+/)\n# -> ['xyzzy', '3456', '334', 'abc']\n```\n\n</details>\n\n<details><summary> capture groups (or grouping parentheses) </summary>\n\n**Capture groups**: capture the matching characters that correspond to part of a regex. You can reuse these matches later in the same regex, and when constructing new values based on the matched string.\n\n` #sub` transforms the first part of a string that matches a regex, while `#gsub` transforms every part of a string that matches.\n\n```ruby\ntext = %(We read \"War of the Worlds\".)\nputs text.sub(/(['\"]).+\\1/, '\\1The Time Machine\\1')\n# prints: We read \"The Time Machine\".\n```\n`\\1` is a capture group but i don't know why this is different than `\\2` etc\n\nOne thing to note here is that if you double quote the replacement string, you need to double up on the backslashes:\n\n```ruby\nputs text.sub(/(['\"]).+\\1/, \"\\\\1The Time Machine\\\\1\")\n```\n\n</details>\n\n"
    }
  ]
}