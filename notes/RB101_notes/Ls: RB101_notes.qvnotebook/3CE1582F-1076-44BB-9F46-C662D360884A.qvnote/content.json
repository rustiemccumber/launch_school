{
  "title": "101 Written Test notes",
  "cells": [
    {
      "type": "markdown",
      "data": "what is the difference between modified and mutated?! can you say an object that was mutated was modified? can you say that a variable that was reassigned to a new object was modified  (the variable was modified)?\n\nI think  you can only used modified when the object which the variable is pointing to has been mutated. \n\n### Truthiness\n- In ruby everthing is truthy other than `Nil` and `false`\n- puts evaluates to `Nil`\n- Use \"evaluates to true\" or \"is truthy\" when discussing an expression that evaluates to true in a boolean context\n- Do not use \"is true\" or \"is equal to true\" unless specifically discussing the boolean true\n- && short circuits when it encounters first false expression\n- || short circuits when encounters first true expression\n\n----\n\n### Variable Scope \n\n- *method invocation* followed by curly braces of `do..end` is the way in which we define a block in Ruby\n- variable scope is defined by a block\n  - a block is a piece of code following a method invocation usually delimited by either `{}` or `do/end`\n  - not all `do/end` pairs imply a block \n\nexample of `do/end` code which does not imply a block \n\n```ruby\narr = [1,2,3]\n\nfor i in arr do \n  a = 5               # a is initialized her\nend \n\nputs a          #is acessible here because `for` is part of ruby                      language not a method invcocation so a block with an                   inner scope is not created\n```\n- inner scope can acess variables initialized in the outerscope but not vise versa\n- you can change variables from an inner scope and have the change affect the outer scope. \n\nexample: outerscope variables can be accessed by inner scope, innerscope variables can change outer scop\n\n``` ruby\n\na = 1    # outer scope variable\n\nloop do    #block after invocation of the `loop` method creates inner scope\n  puts a   #=> 1\n  a = a+1  # \"a\" is re assigned to a new value\n  break\nend \n\nputs a  # => 2  \"a\" was re-assigned in the inner scope\n\n```\n- peer blocks cannont reference variables initialized in other blocks. this means that we could re use the variable name in multiple blocks. \n\n*Methods*\n\n\n\n- while a block has a scope that leaks, a methods scope is entirely self contatined\n- the only variable a method has access to must be pased into the method definition (when talking about local variables)\n\n```ruby\na= `hi`\n\ndef some_method\n  puts a\nend\n\n# invoke the method\nsome_method #=> NameError: undefined local variable\n```\n\n```ruby\ndef change_name(name)\n  name = 'bob'\nend \n\nname = 'jim'\nchange_name(name)\nputs name # => jim\n```\nin the above example there are two variables `name` one scoped within the method, and the other in in main scope.  The outer variable does not have access to the inner variable scope in the method. (this still works the same if the inner variable is assigned a different variable name)\n\nif you perform operations which mutate the caller within the method this will affect the original variable. \n\n``` ruby\ndef add_name( array, name)\n  arr = arr << name\nend\n\nnames = ['bob', 'kim']\nadd_names(names, 'jim')\nputs names.inspect # => ['bob', 'kim', 'jim']\n```\n\n*more variable scope*\n\n- The `def..end` construction in Ruby is method definition\n- Referencing a method name, either of an existing method or subsequent to definition, is method invocation\n- Method invocation followed by `{..}` or `do..end` defines a block; the block is part of the method invocation\n- Method definition sets a scope for local variables in terms of parameters and interaction with blocks\n- Method invocation uses the scope set by the method definition\n\n*method definition* : when, within out code, we define a RUby method using the `def` keyword.  Method definition sets a scope for local variables in terms of parameters and interaction with blocks\n\n```ruby\ndef greeting\n  puts \"Hello\"\nend \n```\n*method invocation*: is when we call a method, method invocation uses the scope set by the method definition. \n\n```ruby\n\ngreeting # calling the greeting method outputs \"Hello\"\n\n```\n- essentially a the block acts as an arugument to the method. In the same way that a local variable can be passed as an arugment to a method at incoation, when a method is called with a block it acts as an argument to the method. \n\nto use a block with a method invocation you must define the method to use with a block or have the method `yield` to the block.\n\n```ruby\ndef greeting \n  yield\n  puts \"goodbye\"\nend\n\nword = \"Hello\"\n\ngreetings do \n  puts word\nend \n\n# outputs 'Hello'\n# outputs 'Goodbye'\n\n```\n\n- when invoking a method with a block, were aren't just limited to executing code within the block,, depending on the method definition, the method can use the return value of the block to perform some other action\n\n```ruby\na = 'hello'\n\n[1,2,3].map {|num| a} # => ['hello', 'hello', 'hello']\n# uses return value to perform transformation \n\n```\n----\n\n### Variable shadowing\n\nvariable shadowing (examples below): When you name the \"block parameter\" the same as the local variable initialzed in the outer scope.  The parameter in the inner scope will block the local variable in the outscope,  and the variable in the inner scope will not have acess to the outer scope and and only access the inner scope.\n\n```ruby\n\nn = 10 \n\n[1,2,3].each do |n|\n  puts n\nend\n\n#1\n#2\n#3\n#nil \n\n```\n\n``` ruby\nn = 10\n\n1.times do |n|\n  n = 11\nend\n\nputs n # => 10 \n\n```\n\n### Variables as pointers \n\nwhen you initialized a new local variable it creates a new value in a new physical memory space. (unless you are assigning a variable to a variable (below))\n\n```ruby \na = 'hi there'\nb = a\na = 'not there' \n```\n- local variable `a` is initialized and is assigned to string object 'hi there'\n- local variable `b` is initialized and is assigned to variable `a` which points to string object 'hi there'.\n- local variable `a` and `b` are both pointing to string object 'hi there'\n- local variable `a` is reassigned to string object 'not there'.  \n`b` is still pointing to 'hi there'\n`a` is now pointing to 'not there' \n\n```ruby\n\na = 'hi there'\nb = 'a'\na << ', Bob'\n\n# a = 'hi there, Bob'\n# b = 'hi there, Bob'\n\n```\n\nIn the above example a mutating method `<<` is used to append ', Bob' to the string object which local variable a is pointing. The line of code `a` << \", Bob\" mutates the caller and modifies the exisiting string, which is also pointed to by the variable `b`.  `a` and `b` both reflect the changes to a because they are both pointing to the same thing. \n\n### Pass by reference vs Pass by value\n\npass by value: the method only has a copy of the original object. Operations performed on the object within the method have no effect on the original object outside the method. \n\npass by reference: a link to the object is passed to the method. \n\n\n### Variable References and Mutability of Ruby Objects\n\nWhen a string object reperesented by a string ('hello') is assigned to a local variable (`greeting`).  This causes the varibael `greeting` to reference the String object whose value is 'Hello', buy storing the object id of the string. \n\n(`greeting` (object 70101471431160)) -----------> (String ('Hello'))\n\nnow if you assign the variable `greeting` to another local variable `whazzup`\n\n`whazzup` = `greeting`\n\n(`greeting` (object 70101471431160))--+\n                                      |------------> (String ('Hello'))\n(`whazzup`  (object 70101471431160))--+ \n\nif you reasign `greeting` to a different String object the variable will reference a new object id and the `whazzup` variable will remain referencing the String object with value 'Hello'\n\n```ruby\ngreeting = 'dude'\n```\n\n(`greeting` (object 70109768889089))---------------> (String ('Dude'))\n\n(`whazzup`  (object 70101471431160))---------------> (String ('Hello'))\n\n*Mutability*\n\n**Mutable Objects**: Objects which can be changed. most objects in ruby are mutable.  \n\nArrays are mutable. You can reassign individual items of an array while maintaining the object ide of the array \n\n```ruby \na = ['a', 'b', 'c']\na[1] = '_'\n# a => ['a', '_', 'c']\n```\n\n(`a`(object: 70289098908908907)) ---------> \na[0]  | a[1] | a[2]\n--- | --- | ---\nobject: 18494 | object: 09809 | object: 09098\n                                            \n\n\n**Immutable objects**: Objects which cannot be changed.  \n- In ruby numbers and boolean values are immutable, objects of NilClass and Range objects. \n- There are no methods available that let you alter the value of an immutable object (you can only reassign). \n- Any class can establish itself as immutable by simply not providing any methods that alter its state. \n\n*Object Passing* \n\npass by value:  a copy is made and this is passed to the method\n\npassy by reference: a link to the original object is made and this is passed to the method. \n\n### mutating and Non-Mutating Methods in Ruby\n\nnon-mutating: a method is sead to be non-mutating with respect to an argument or its calling object if it does not modify it. Most methods you will encounter do not mutate their arguments or caller. some do mutate their caller, but few mutate the arguments. All methods are non-mutating with respect to immutable objects. \n\nassignment `=` is non-mutating. \n`+=`, `*=`, `-=`, `%=` are all non mutating as well (same as asignment)\n\nseters methods for calss instance variables and indexed assignment are not the same as assginment.  Setter methods and indexed assigment usually mutate the calling object. \n\n*mutating method example* \n\n----\n\n```ruby\ndef fix(value)\n  value.upcase!\n  value.concat('!')\n  value\nend \n\ns = 'hello'\nt = fix(s)\n```\nin the above example after the method invocation \n`t` = 'HELLO!'\n`s` = 'HELLO!'\n\nwhen `t` is passed to the method, `value` and `t` are both pointing to the same string object 'hello' (`t` and `value` are aliases) . upcase! will mutate the caller, s `t` is still pointing to the original string object but it has not been upcased ('HELLO').  Concat also mutates the caller so `t` points to the original object which has been modified to 'HELLO!'.\n\n``` ruby \n\ndef fix(value)\n  value = value.upcase!\n  value.concat('!')\nend \n\ns = 'hello'\nt = fix(s)\n\n# s => \"HELLO!\"\n# t => \"HELLO!\"\n```\nin the above `s` is passed to the method. `s` and `value` are now pointing to `hello`.  A mutating method upcase! is called on value.  This value `HELLO` is assigned to `value` (`value` is bound to the object, albiet modified, it was bound to originally).  another mutating method is called on `value`.  \n\n**Indexed Assignment is Mutating relative to the caller**\n\nstring[3] = 'x'  this changes the object bound to indivdual letter, but the object entire string object is unaffected\n\narray[5] = 'cat' this changes the object bound to the index, but no the entire array object still points to the original \n\nhash[:age] = 25 this changes the object bound to the individual value, but the entire hash object still points to the original\n\n**Concatenation is Mutating**\n`#<<`\n\n```ruby \ns = 'hello' object id 1234\ns << '!'\ns = 'hello!' object id 1234\n```\n** setters are mutating **\n\n``` ruby \nperson.name = 'Bill'\nperson.age = 23\n```\nThis looks identical to reassignment (non-mutating) but these are setter calls and actually mutate the object bound to person. \n*non-mutating method example (assignment `=` is non-mutating.)*\n\n-----\n\n``` ruby \ndef fix(value)\n  value = value.upcase\n  value.concat('!')\nend\n\ns = 'hello' \nt = fix(s)\n```\nthe above code:\n `s` = 'hello' \n `t` = 'HELLO!'  # `t` is bound to a different object than `s`\n\nwe assign the return `value` of `value.upcase` back to `value`. #upcase does not modify the String reference by value, it creastes a new copy of the string reference by value, modifies the copy and then returns a reference to the copy. We then bind `value` to the returned reference\n\n### Object passing in ruby - Pass by reference or pass by value \n\nThe caller (or receiver) of a method call can be thought of as an implied argument. \n\n*Evaluation Strategies*\n\nThe strategy a program uses to determine when expressions a evaulated.  Ruby uses strict evaluation exclusively, with strict evaulation every expression is evaluted and converted to an object before it is passed along to a method. \n\n*Object Passing Strategies*\n\npass by value and pass by reference  are object passing strategies. Which are the two most common strict evaluation strategies. \n\n***RUBY IS PASS BY REFERECENCE ALL THE WAY DOWN***\n\nexample: \n``` ruby\ndef print_id number\n  puts \"In method object id = #{number.object_id}\"\nend\n\nvalue = 33\nputs \"Outside method object id = #{value.object_id}\"\nprint_id value \n\n# => outside method object id = 67\n# => In method object id = 67\n```\n***RUBY IS PASS BY REFERENCE VALUE***\n\nmost accurately ruby is pass by reference value, pass by reference of the value or pass by value of the referece. \n\nbut it could be described as `pass by reference` if you take into tak ineot account assignment and immutability. \n\n---\n\n\n### Notes From Srdan's 4 part blow series\n\n*general notes*\n\n- us mark down for variables `a`\n- divide you answers into paragraphs you will lose non-tech points if you answer looks like one long paragraph.\n- Pay close attention to what each question is asking and keep your answers concise. For example, if the question is to explain how variable shadowing affects given code, then you should simply describe how variable shadowing is demonstrated in the code and what affect it has, with as much precision as possible.\n\n*learn to use programming terms:*\n\n- initialize\n- assign \n- referencing\n- reassigned\n- methods are defined with **parameters** but called wih **arguments**\n\n``` ruby\na = 'hello'\nb = a\na = 'goodbye'\n\n```\ndescription of above code:\non line 1 local variable `a` is being **initialized** and the string object value `hello` is **assigned** to it. \n\non line 2 local variable `b` is being initialized and is **assigned** to the a string object that local variable `a` is **referencing**. \ncurrently both of these \n\none line 3 local variable `a` is being **reassigned** to string object with value `goodbye`.  Now the local variable `a` is pointing to (**referencing**) string object with value `goodbye`, while local variable `b` is pointing to (**referencing**) string object with value `hello`\n\n``` ruby \ndef example(str)\n  i = 3\n  loop do\n    puts str\n    i -= 1\n    break if i == 0\n  end\nend\n\nexample('hello')\n```\n\non `line 1-8` we are defining the method `example` which takes one parameter `str`.  On line ten we are calling or invoking the method and passing in the string `hello` as an argument. **IMPORTANT NOTE: METHODS ARE DEFINED WITH PARAMETERS, BUT THEY ARE CALLED WITH ARGUMENTS**.\n\non `line 2` we are initializing local variable `i` and assigning an Integer with value `3` to it. \n\non `line 3` we are calling the method `loop`, and passing in the `do..end` block as an argument. \n\non `line 4` we are calling the method puts and passing in local variable `str` as an argument. \n\non `line 5` local variable `i` is  **reassigned**. `-=` is part of ruby's syntactical sugar for i = i - 1.  since `-` is not an operator but a method and that code can also be written as `i = i.-(1)`. So inside this code we are reassining the local variable `i` to the return value of method call Integer#- on a local variable `i` with `1` passed to it as an argument. \n\nOn `line 6` we are breaking out of the loop by using the keyword `break` if that value of the object local variable 'i' is referencing is 0. \n\non `line 10` we are calling or invoking the method `example` and passing the in string `hello` as an argument \n\nthe code outputs `hello` 3 times and returns nil.  It returns nil because the last line in code in the `example` method that is evaluated returns (`puts`) nil. \n\n*variable scope*\n\nWithout running the code try to answer what will this code example output\n\n``` ruby \na = 4\n\nloop do\n  a = 5\n  b = 3\n  break\nend\n\nputs a\nputs b\n```\n\nthis code will output: `5`, and line 10 will through and error (undefined local variable `b`) because `b` is initialized in the inner scope of the block defined by the `do..end`  alongside the `loop` method invocation.  This example illustrates local variable scope behaviors, specifically that local variables initialized in the outerscope can be acessed by to the inner scope, and changes made in the inner scope will effect variables in the outer scope.  additionally it illustrates that variables initiliazed in the inner scope cannot be acessed by the outerscope. \n\n\nWithout running the code try to answer what will this code example output\n\n\n``` ruby\na = 4\nb = 2\n\nloop do\n  c = 3\n  a = c\n  break\nend\n\nputs a\nputs b\n```\n\nthis code outputs: `4` and `2`\n\non `line 1` local variable `a` is initialized and an integer with value 4 is assigned to it.\n\non `line 2` local variable `b` is initialized and an integer with value 2 is assigned to it.\n\non `line 4` the method loop is invoked with the `do..end` block passed into it as an argument. Inside of this block we initialze no local variable `c` and an integer with value 3 is assigned to it. The inner scope of the block is available to this new local variable. \n\non `line 6` local variable `a` is reassigned to point to an integer with value 3 which local variable `c` is referencing as well. since we are still in the inner scope defined by the block, local variable `c` is accesible. \n\none `line 7` we are breaking out of the loop by using keyword `break`. \n\n`line 10` calls the method `puts` passing in local variable `a` as an argument , outputing integer with value `3`, since we reassigned `a` inside the block.\n\n*variable shadowing sdran part 3*\n\nWithout running the code try to answer what will this code example output\n\n``` ruby\na = 4\nb = 2\n\n2.times do |a|\n  a = 5\n  puts a\nend\n\nputs a\nputs b\n```\n\nResults = the code outputs `5`, `5`, `4`, and `2` in this order\n\non `line 1` local variable `a` is initialized and the integer `4` is assigned to it. (or setting its value to `4`)\n\non `line 2` local variable `b` is initialized and the integer `2` is assigned to it.  (or setting its value to `2`)\n\non `line 4` the method `times` is called on the integer `2`, a `do..end` block as passed to it as an argument with one parameter `a`. the `do..end` along side the method invocation defines a block with an inner scope.  \n\nThe use of local variable `a` for the parameter of the `do..end` block creates *variable shadowing*.  Variable shadowing occurs when a parameter name of a block has the same name as a local variable which was initialized outside of the block. Variable shadowing prevents access to local variables of the same name outside of the block from within the block. So on `line 5` we are actually assigning integer `5` to the local variable `a` passed in as a parameter of the `do..end` block. And the value of our local variable `a` initiliaze in the outer block remains `4`. \n\nOn line `6` the `puts` method is invoked with the local variable `a` passed as a argument.  The local variable `a` is referncing `5` as defined in the inner scope of the block.  `5` is output two times, **`2` is returned because `2` is the last line of the method**. \n\non `line 9` the `puts` method is invoked with local variable `a` passed to it as an argument.  the local variable `a` is referencing the integer `4` as assigned in the outer block, the reassignment of `a` in the inner scope had no effect on what the local variable `a` was referencing in the outer scope (variable shadowing). The integer `4` is output. \n\non `line 10` the method `puts` is called with the local variable `b` passed to it as an argument.  `b` is referencing integer `2` as assigned in the outer block. `2` is output. \n\nyou could change this code to not have variable shadowing by changing the parameter of the block to anything but `a`, use `_` because the parameter is not being used. \n\n*Each, Map and Select Methods sdran part 3 continued*\n\nArray#each \n\n`Each` iterates through the Array object passing each element of the array to the block, then runs the block (outputting the value of parameter num) and when it finishes all iterations it returns the original array. The each method does not care about the return value of the block. \n\nArray#map\n\n`Map` iterates through array object, passing in each element of the array to the block, then runs the block. Map then takes the return value of the block and moves it to a new array, and when it finishes all iterations it returns the new array with elements which passed into it (return values of block of each iteration). \n\nArray#select \n\n`select` iterates throught the array object, passing each element of the array to the block and then runs the block. Select considers the truthiness of the return value of the block.  If the return value of the block evaluates to `true` it takes the element and puts it in a new array, after all iterations have been completed `select` returns the array after each iteration. \n\n```ruby\n[1, 2, 3, 4].each { |num| puts num }\n```\n**Sdran part 4**\n\n\n*mutating/non-mutating methods*\n\nmutating methods: methods which change the value of the calling object.\n\n``` ruby\na = 'hello'\n\nputs a # -> hello\nputs a.object_id # -> 70368527757720 (this number will be different for you)\n\na.upcase! \n\nputs a # -> HELLO\nputs a.object_id  # -> 70368527757720 (this number will be the same as the one above)\n\n```\n\none `line 1` we are initializing the local variable `a` and assigning the string object with value `hello` to it\n\non `line 3` we invoke the `puts` method, passing in the local variable `a` as an argument which is referencing the string object with value `hello`.  Outputting the **value** of this string object. and returning nil. \n\non `line_4` we are calling the method object_id on local variable `a` and passing this into the method puts as an argument, displaying the object id of the string object which local variable `a` is pointing to. \non `line_6` we are calling the destructive method `upcase!` on the string object which local a is pointing to (referencing). The `upcase!` is a mutating method. which means that it changes the value of the object that the is calling it, while maintaining the same object_id.\n\n```ruby\na = 'name'\nb = 'name'\nc = 'name'\n\n# Are these three local variables pointing to the same object?\n\nputs a.object_id\nputs b.object_id\nputs c.object_id\n\n# And when we add these two lines of code... ?\n\na = c\nb = a\n\nputs a.object_id\nputs b.object_id\nputs c.object_id\n\n# What about now?\na = 5\nb = 5\nc = 5\n\nputs a.object_id\nputs b.object_id\nputs c.object_id\n```\n\nThe answer to the first question is no. In the first example on `lines 1-3` we are initializing 3 new local variables and assignment string objects which have the same value 'name' but are poiting to seperate objects with seperate object_ids. Objects are just physical space in memory and these 3 objects occupy different physical space in memory, which happy to have the same value. \n\non `line 13-14` we are reassigning local variable `a` to point to the same string object `name` which local variable `c` is pointing to.  on `line 14` we are reassigning local variable `b` to point to the same string object which local variable `a` is referencing (and also `c` is referencing).  Now all local variables initialized in `line 1-3` are referencing the same string object. \n\none `line 25-27`  we are seperately reassingin local variable `a` `b` and `c` to point to the same integer object with value 5.  Unlike the above examples where each string value `name` has the same value but different object_id integer objects with the same value share the same object id. In ruby Integers and Symbols  (unlike strings) occupy the same physical space in the computers memory meaning they have the same object id. \n\n*`+=` operator*\n\n```ruby \na = 'hello '\nputs a\nputs a.object_id\n\na += 'world'\nputs a\nputs a.object_id\n```\n\nin ruby the `+=` operator is non-mutating.  the `+=` opertor is short hand for `a = a + b` (`a += b`)\n\n`+=` (`-=`, `*=`) is the same a reassignment. \n`line 5` can be written as `a = a + 'world'`.  so we are actually reassinging local variable `a` to point to a new string object with the value `hello world`. so the ouputs on `line 3` and `line 7` will not be the same. \\\n### Live lessons Ruby\n\n**Part 1 (video 1)** \n\n- reading Ruby's syntactical sugar\n - you can put methods with out without (): ie, puts() vs puts. Kernel.puts('hello') => puts 'hello'\n- where does he code come from \n\n**Part 2 (video 2)**\n\n- variable scope\n\n``` ruby \ndef amethod(param)\n  param += \" universe\"\n  param << \" world\"\nend\n\nstr = \"hello\"\namethod(str)\n\np str\n\n# => hello  \nthis is because += is reassignment so << is mutating the new string object that param is pointing to within the method, so the original string object us unmodified outside of the method. \n\n```\n``` ruby \na  = 'hello'\nb = a\n\nb << \" world\"\n\n# ----- 2 variables, 1 object\n\nputs a # => hello world\nputs b # => hello world\n\na = 'hey'\n\n# ---- 2 variables, 2 objects\n\nb << ' universe'\n\nputs a # => hey\nputs b # => hellow world universe \n \n```\n\n- pass by reference vs pass by value\n- questions\n\n+, - , *, / are methods\n\n\n**Part 3 (video 3)  EACH MAP SELECT**\n\na method will modify the object a variable points to if it uses a distructive method.  if not the object will not be modified (reassignment does not modify). \n\n- What's the difference between an Array and a Hash\n  - order\n  - index vs key retrieval\n  - arrays can have duplicates, but hash keys are unique\n  \nhsh.fetch('a') is better than hsh['a'] because it will tell you if it doesn't exist \n\n``` ruby\narr = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nidx = 0\n\nloop do\n  puts arr[idx]\n  idx += 1\n  break if idx == arr.size\nend\n\n# the above outputs \n#1\n#2\n#3\n#4\n#5\n#6\n#7\n#8\n#9\n#10\n# => nil # because it is the last line of the code executed\n\n\narr.each do |n|\n  puts n\nend \n\n# the above puts \n#1\n#2\n#3\n#4\n#5\n#6\n#7\n#8\n#9\n#10\n# => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # because it is the last line of the code executed\n\n```\n\n\n\n**IMPORTANT MEMORIZE DEFINITION `select`: returns a new array based on the blocks return value. If\nthe return value evaluates to true, the element is selected.  `select` cares about the return values truthiness**\n\n`select` example:\n\n``` ruby \nodds = arr.select do |n|\n  n + 1\n  puts n\nend\n\np odds # => [] this is because `puts` has a return value of nil which evaluates to false or is falsey\n```\n\n  \n\n**IMPORTANT MEMORIZE DEFINITION `map`: returns a new array based on the block's return value. each element is transformed based on the return value. \n\n`map` example: \n\n```ruby \nincremented = arr.map do |n|\n  n.odd?\n  puts n\nend\n\np incremented # => array o nils \n```\n<div style=\"page-break-after: always;\"></div>\n\n---\n\n### Ryan Schaul Break down problems\n\n**example 1**\n\n``` ruby \na = [1, 2, 3, 3]\nb = a\nc = a.uniq\n```\n\non `line 1` local variable `a` is initialized and the array object with value `[1, 2, 3, 3]` is assigned to it.\non `line 2` the local variable `b` is initialized assigned and the same array object that local variable `a` is referencing is assigned to local variable `b`. Now local variable `a` and `b` are pointing to the same array object.\non `line 3` local variable `c` is initialized and the return value of the method call `uniq` on local variable `a` is assigned to it. `uniq` will delete duplicate elements of the array and return a new array,  `uniq` is a non mutating method so local variable `c` is referencing a different array object than local variables `a` and `b`\n\na and b both reference the same array object [1, 2, 3, 3]\nb references a different array object [1, 2, 3]\n\n\n**example 2**\n\n``` ruby\ndef test(b)\n  b.map { |letter| \"I like the letter: #{letter}\" }\nend\n\na = ['a', 'b', 'c']\np test(a)\np a\n\n```\n\nOn line 1-3 a method definition `test` is created which takes one parameter `b` indicated by the `def..end`.\n\non `line 5` a local variable initialized in an array object with value `['a', 'b', 'c']` is assigned to it \n\non line 6 the method `p` is invoked with  method invocation `test(a)` passed to it as an arument.  `test(a)` is a method invocation with the array object which local variable `a` is referencing passed to it as an arugment. alternate (on line 10 we call the the method `p` passing in the `test` method as and argument, calling the `test` method and passing in `a` as an argument.) \n\non `line 1` the `test` method parameter `b` is set to the value of the argument passed in `a: ['a', 'b', 'c']`. \n\non `line 2` the `map` method is called on `[ 'a', 'b', 'c']`, with the block `{|letter| \"I like the letter: #{letter}` passed in as an argument with the parameter `letter`.  the `map` method iterates throught the array (['a', 'b', 'c']) while passing each value of the array as an argument to the variable `letter`. The block produces a return value \"I like the letter: #{letter}\" expect with `letter` being interpolated with the argument being passed in.  This return value is then in put into a new array.  \n\nline 6 ouputs [\"I like the letter: a\",  \"I like the letter: b\", \"I like the letter: c\"] and returns the same. \n\nline 7 ouputs the value of the the array object which local variable `a` is pointing to ['a', 'b', 'c']. The `array` object which `a` is pointing to has not been changed.  \n\n*explain what happens in the follow code \n\n``` ruby   \n# now with map! instead of just map\n\ndef test(b)\n  b.map! {|letter| \"I like the letter: #{letter}\" }\nend\n\na = ['a', 'b', 'c']\np test(a)\np a\n```\n\non `line 3-5` a method is defined with one parameter `b`.\n\non line 7 the local variable `a` is inititailzed with the array object ['a', 'b', 'c'] assigned to it.\n\non `line 8` the method `p` is called with the `test` method passed to it as an arguement. `test` method is called with the local variable `a` passed to it as an argument.\n\non `line 3` the parametr `b`, local to the test method, is assigned to point to the same array object local variable `a` is referencing.  \n\non line 4 the mutating method `map!` is called on the array ['a', 'b', 'c'] with a block `{|letter| \"I like the letter: #{letter}\" }` with one parameter `letter` passed to it as an argument. map! iterates through the array, taking taking each element of the array and iterporlating it into the place of `letter` in the string in the block.  Map then takes the return value and returns it to the same array.  Mutating the original array refence by local variable `a`\n\nline 8 outputs an array [ \" I like the letter: 'a', \"I like the letter\": 'b', \"i like the letter: 'c'] and returns the same\n\nline 9 outputs the letter array [ \" I like the letter: 'a', \"I like the letter\": 'b', \"i like the letter: 'c'] and returns the same, because the test definition has mutated the original array.  \n\n*explain what happens in the following code \n\n\n``` ruby\nmy_arr = [[18, 7], [3, 12]].each do |arr|\n  arr.each do |num|\n    if num > 5\n      puts num\n    end\n  end\nend\n```\n\non `line 1` a the local variable `my_arr` is initialized and set to the return value of calling the `each` method on the nested array `[[18,7], [3,12]]`.\n\none line 1 -7 the `each` method is called on the nested array  `do..end` block with one parameter `arr` passed to it as an argument.\n\nThe method `each` iterates through the nested array, assigning each subarray to the parameter `arr`.   **language check, can you say you a passing as an argument to where the parameter appears?**\n\non `line 3-6` the method `each` is called on the `arr` parameter a `do..end` block with one parameter `num` is passed to it as an argument.  The `each method` iterates through each subarray, assigning each element to the `num` parameter is it iterates through the subarray. \n\non `line 3 -5` a conditional is statement is defined.  The conditional statement is triggered if the result of `line 3` evaluates to true.  If the condidtional evaluates to true, the current value of the `num` parameter will be passed to the `puts` method as an argument. interestingly [3, 12] will be the the final return value of the `each` method invoked on `line 2` because it is the last code run on the block from line2 -6 \n\nline 4 outputs \n18\n7\n12 \nand returns [[18,7], [3, 12]] (`each` returns the intialize value of the array) \nmy_array = [[18,7], [3, 12]]\n\n*explain the following code* \n\n``` ruby \nn = 10\n\n[1, 2, 3].each do |n|\n  puts n\nend\n\np n\n```\non `line 1` the local variable `a` is initialized with an integer with value `10` assigned to it. \n\non `line 3` the method `each` is called on the array `[1, 2, 3]` with a `do..end` block with one parameter `n` passed to it as an argument. The block defines an inner scope.  The parameter is named the same as the local variable `n` initialized outside of the block.  This prevents the inner block accessing the local variable `n` in the outer block. and is and example of the concept of variable shadowing.  \n\non `line 4` the `puts` method is invoked the block parameter `n` is passed to it as an argument. as each iterates through the array each element of the array is passed to the `puts` method ouputting  1, 2 and  3.  Finally the each method returns the original value of the array \n\non line for the `p` is called and `n` is passed to it as an argument.  the integer with value `10` is output, the same is returned.  the each method with block does not effect the object with the local variable a is pointing to. \n\n*explain the below code*\n\n```ruby\n[[1, 2], [3, 4]].map do |arr|\n  arr.map do |num|\n    num * 2\n  end\nend\n\n```\n\non `line 1` the method `map` is called on the the Array object [[1, 2], [3,4]].  A `do..end` block is passed to it as an argument with one parameter `arr` defined. The `do..end` block spans from `line 1 - 5`.  The `map` method iterates through the nested array, `[[1, 2], [3, 4]]` of the subarray. taking each return value of the block and putting it in a new array as returning the new array as it iterates through the calling array. \n\n\nWithin the block, on `line 2` the `map` method is called on the `arr` parameter of the block.  on a `do..end` block is passed into the second `map` method as an argument with `num` defined as a parameter. The second `do..end` block spans from `lines 2-4`. Within the block the parameter `num` is assigned to the current element of the sub array multipying this value by the integer `2` and return this value. The `map` method iterates through the array performing this transfromation on each element of each subarray and returning the transformed value to a new subarray.  The final return value of the inner most bloc is [6, 8] because this is the last line of the code run. \n\nthe final output of the array is a new array object with value:\n`[[2,4], [3, 4]]`\n\n*explain what happens in the below code*\n\n```ruby \ndef fix(value)\n  value << 'xyz'\n  value = value.upcase\n  value.concat('!')\nend\ns = 'hello'\nt = fix(s)\n```\non `line 1 -5` on the method `fix` is defined with one parameter, `value`.\n\non `line 6` the local variable `s` is intialized and is assigned to the string object with value `hello`. \n\non `line 7` the local variable `t` is initialized, to the return value of the method call `fix` with the local variable `s` referencing the string value `hello` as an argument is assigned to `t`. (*alternate: we are calling the fix method and passing in `s` as an argument, and we're assigning the return value of said call to the local variable t being initialized there.*) \n\n On `line 2` the shovel `<<` method called on `value` which now references the same string object as `s`, the string object has a value of `hello`. the string object `xyz` is passed to the `<<` method as an agurment. The shovel operator mutates the original string object so now `s` and `value` are both pointing to `helloxyz`\n\non `line 3` value is reassigned to reference the return value of the method call on value.upcase, which returns a new string with all letters of the orignal string in capitals (`HELLOXYZ`). Now both `value` and `s` are pointing to a new string object, and the reference to the orginal string object passed in by `s` is now broken. \nOne `line 4` the method `concat` with `!` passed as a parameter is called on the `HELLOXYZ`.  This mutates string `HELLOXYZ` to now be `HELLOXYZ!`, which is the return value of the method `fix` because it is the last line of the code run. \n\non line 7 local variable `t` is refecncing `HELLOXYZ!` while `s` outside of the block is pointing to `helloxyz`\n\nthis example illustrates that local variable passed into methods as arguments can only be modified when mutating methods are called on them from within the method. \n\n*explain the below example*\n\n``` ruby \nn = 10\n\n1.times do |n|\n  n = 11\nend\n\nputs n\n\n```\non `line 1` the local variable `n` is initialized and the integer `10` is assigned to it. \n\non `line 3` the method `times` is called on the integer `1`.  The `do..end` block which spans from `line 3-5` is passed into the method as an argument with on parameter `n`.  the `times` method is a looping method that will loop the number of times specified by the integer it is called upon, in this case `1`. With each iteration the current count of iterations is stored in variable `n`, locally scoped to the block, starting at integer `0`. \n\nsince the block is only looped through once, `n` is initally set to `1` however on line 4 `n` is reassigned to reference `11` \n\nThe use of local variable `n` for the parameter of the `do..end` block creates *variable shadowing*.  Variable shadowing occurs when a parameter name of a block has the same name as a local variable which was initialized outside of the block. Variable shadowing prevents access to local variables of the same name outside of the block from within the block. So on `line 4` we are assigning integer `11` to the local variable `n` passed in as a parameter of the `do..end` block. the value of the local variable `n` initiliaze in the outer block is uneffected, and remains `10`.\n\non line 7 the method `puts` is called with the local variable `n` passed in as a parameter. method call `times` with the block had no effect on the object that `n` is pointing to  (described above).  this will output `10` and return `nil`. \n\n*describe what happens in the following code\n\n``` ruby \na = \"hello\"\n\n[1, 2, 3].map do |num| \n  a \nend\n```\n\nOn `line 1` the variable `a` is initialized and the string object with value `hello` is assigned to it. \n\nOn `line 3` the `map` method is called on the array object with value  `[1, 2, 3]`\nOn `line 1-3` the `do..end` block is passed as an argument to the `map` method call with `one` parameter `num`.  \n\nIn this case the block simply returns the value of `a` on `line 4`.  The value of `a` can be accessed here in the inner scope of the block because it was initialized in the outer scope. \n\nThe `map` method iterates through the array, passing each element of the array to the block and assigning it to the variable `num`, with each iteration return value of the block is the move into a new array. the array `[1, 2, 3]` has 3 elements, so the block completes three iterations, one for each element, and returns the new array object `['hello', 'hello', 'hello']`\n\n*describe what happens in the following code*\n\n``` ruby \ndef change_name(name)\n  name = 'bob'\nend\n\nname = 'jim'\np change_name(name)\nputs name \n```\n\non `line 1-3` the method `change_name` is defined with one parameter `name`.\n\nOn `line 5` the variable `name` is initialized and the string object with value `jim` is assigned to it. \n\non `line 6` the `change_name` method is called with the local variable `name` passed to it as an argument.  The method `p` is called with the return value of the `change_name` method passed to it as an argument. \n\non line `1` the `name` parameter specified in the method scope is set to point to the value of the local variable `name` specified outside on the method.  \n\non `line 2` the `name` variable is reassigned to point to a new string object with value `bob`. reference to the string object `jim` is now broken.\n\nline prints `bob`\n\nand because reassignment is a non-mutating, the local variable of `name` specified outside of the method is still point to `jim`.  line 7 outputs `jim` and returns `nil` (puts returns `nil`)\n\n*describe what happens in the following code*\n\n``` ruby\ndef add_name(arr, name)\n  arr = arr + [name]\nend\n\nnames = ['bob', 'kim']\np add_name(names, 'jim')\nputs names.inspect \n```\n\non `line 1-3` the method add_name is defined with two parameters `arr` and `name`.\n\nOn `line 5` the local variable `names` is initialized and the array object with value `['bob', 'kim']` is assigned to it.\n\n on `line 6` the `add_names` method is called with the local variable `names` and the string object `jim` passed to it as arguments.  The return value of this method call is then passed to the method  `p`, which calls the method `inspect` on the object it is called on displaying a string containing a human-readable representation of the obj. \n \n On `line 1` the variable ,`arr`, local to the method defintion `add_name` is set to point to the same array object which is being referenced by the local variable `names`, with value `[bob, kim]`. Also the variable `name` local to the method definition is assigned to point to the string object with value `jim`.\n \n \n \n on `line 2` the the `arr` variable is reassigned to point to `['bob', 'kim']` + `[jim]` which evaluates to `['bob', 'kim, jim]`.  Because reassignment is non mutating the reference to local variable `names` is broken.\n \n `line 6` outputs the return value of of the method call `add_name` `['bob', 'kim, jim]`.\n \n `line 7` the method `inspect` is called on the local variable `names`, returning string containing a human-readable representation of the obj. This return value is passed to the `puts` method which outputs `['bob', 'kim']`  and returns nil, the value was unmutated within the method so remains the same. \n\n* explain the following code * \n\n``` ruby\ndef add_name(arr, name)\n  arr = arr << name\nend\n\nnames = ['bob', 'kim']\np add_name(names, 'jim')\nputs names.inspect\n```\non `line 1-3` the method `and_name` is defined with two parameter `arr` and `nam`.\n\nOn `line 5` the local variable `names` is initialized and the array object with value `['bob', 'kim']` is assigned to it. \n\non `line 6` the `method_name` method is called with the local variable `name` and the string object `jim` passed to it as arguments.  The return value of this method call is then passed to the method  `p`. which calls the method `inspect` on the object it is called on displaying a string containing a human-readable representation of the obj.\n\nOn `line 1` the variable ,`arr`, local to the method defintion `add_name` is set to point to the same array object which is being referenced by the local variable `names`, with value `[bob, kim]`.\nAdditionally the variable `name` local to the method `add_name` is set to point to the string object with value `jim`.\n\none `line 2` the variable the shovel `<<` method is used to append the string object `jim` to the array object `['bob', 'kim']`.  The result is a mutation of the original array object which both `arr` and `names` and pointing to.  this value is reassigned to `arr`, but `names` and `arr` are referencing this value. The method returns  `['bob', 'kim', jim ]`\n\nline 6 outputs `['bob', 'kim', 'jim']`\n\non line 7 puts is called on the return value of the return value of the method call `inspect` on the local variable `names`, which returns a human readable string object, which inturn is output by puts. outputing the mutated `['bob', 'kim', 'jim']`\n\n*explain the following code* \n\n``` ruby\ndef increment(a)\n  a = a + 1\nend\n\nb = 3\np increment(b)\np b\n```\n\non `line 1-3` the method `increment` is defined with one parameter `a`.\n\nOn `line 5` the local variable `b` is initialized and the integer object with value `3` is assigned to it. \n\non `line 1` the `increment` method is called with the local variable `b` passed to it as an argument.  The return value of this method call is then passed to the method  `p`.  `p`  calls the method `inspect` on the object it is called on displaying a string containing a human-readable representation of the obj. \n\n On `line 1` the variable ,`a`, local to the method defintion `add_name` is set to point to the same integer object which is being referenced by the local variable `b`, with value `3`.\n \n on `line 2` a is resassigned to point to the sum of `a + 1` with a value of `4`.  reasignment is non-mutating so the reference to the local variable value outside the method is broken.\n \n on line 6 `4` is output\n \n on line 7 the local variable `b` is passed to the method `p`.  `p` calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs `3`. The method incremet did not modify this value. \n \n*explain the following code*\n\n```ruby \ndef append(s)\n  s << '*'\nend\n\nt = 'abc'\nputs append(t)    \nputs t \n```\n\n on `line 1-3` the method `append` is defined that takes one parameter `s`.\n \n On `line 5` the local variable `t` is initialized and the string object with value `abc` is assigned to it. \n\n\n on `line 6` the `append` method is called with the local variable `t` passed to it as an argument.  The return value of this method call is then passed to the method  `puts`.  (description of what method does) `puts` diplays the argument that is past to it and returns nil.\n \n On `line 1` the variable ,`s`, local to the method defintion `append` is set to point to the same array object which is being referenced by the local variable `t`, with value `abc`.\n \n on `line 2` the shovel method `<<` is called on the value which s and t ad pointing to. the shovel operator is mutating so the value of the local variable `t` ouside the method is also modified. \n \n line 6 outputs the return value of the method which is  `abc*` since line 2 is the last line of the code run,  and returns `nil` \n \n on line 7 the variable t is passed to `puts` as an argument. `puts` ouputs `abc*` and returns `nil`"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}