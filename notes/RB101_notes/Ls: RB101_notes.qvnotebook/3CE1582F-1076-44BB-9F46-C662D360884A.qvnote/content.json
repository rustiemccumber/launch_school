{
  "title": "101 Written Test notes",
  "cells": [
    {
      "type": "markdown",
      "data": "what is the difference between modified and mutated?! can you say an object that was mutated was modified? can you say that a variable that was reassigned to a new object was modified  (the variable was modified)?\n\nI think  you can only used modified when the object which the variable is pointing to has been mutated. \n\n### Truthiness\n- In ruby everthing is truthy other than `Nil` and `false`\n- puts evaluates to `Nil`\n- Use \"evaluates to true\" or \"is truthy\" when discussing an expression that evaluates to true in a boolean context\n- Do not use \"is true\" or \"is equal to true\" unless specifically discussing the boolean true\n- && short circuits when it encounters first false expression\n- || short circuits when encounters first true expression\n\n----\n\n### Variable Scope \n\n- *method invocation* followed by curly braces of `do..end` is the way in which we define a block in Ruby\n- variable scope is defined by a block\n  - a block is a piece of code following a method invocation usually delimited by either `{}` or `do/end`\n  - not all `do/end` pairs imply a block \n\nexample of `do/end` code which does not imply a block \n\n```ruby\narr = [1,2,3]\n\nfor i in arr do \n  a = 5               # a is initialized her\nend \n\nputs a          #is acessible here because `for` is part of ruby                      language not a method invcocation so a block with an                   inner scope is not created\n```\n- inner scope can acess variables initialized in the outerscope but not vise versa\n- you can change variables from an inner scope and have the change affect the outer scope. \n\nexample: outerscope variables can be accessed by inner scope, innerscope variables can change outer scop\n\n``` ruby\n\na = 1    # outer scope variable\n\nloop do    #block after invocation of the `loop` method creates inner scope\n  puts a   #=> 1\n  a = a+1  # \"a\" is re assigned to a new value\n  break\nend \n\nputs a  # => 2  \"a\" was re-assigned in the inner scope\n\n```\n- peer blocks cannont reference variables initialized in other blocks. this means that we could re use the variable name in multiple blocks. \n\n*Methods*\n\n\n\n- while a block has a scope that leaks, a methods scope is entirely self contatined\n- the only variable a method has access to must be pased into the method definition (when talking about local variables)\n\n```ruby\na= `hi`\n\ndef some_method\n  puts a\nend\n\n# invoke the method\nsome_method #=> NameError: undefined local variable\n```\n\n```ruby\ndef change_name(name)\n  name = 'bob'\nend \n\nname = 'jim'\nchange_name(name)\nputs name # => jim\n```\nin the above example there are two variables `name` one scoped within the method, and the other in in main scope.  The outer variable does not have access to the inner variable scope in the method. (this still works the same if the inner variable is assigned a different variable name)\n\nif you perform operations which mutate the caller within the method this will affect the original variable. \n\n``` ruby\ndef add_name( array, name)\n  arr = arr << name\nend\n\nnames = ['bob', 'kim']\nadd_names(names, 'jim')\nputs names.inspect # => ['bob', 'kim', 'jim']\n```\n\n*more variable scope*\n\n*method definition* : when, within out code, we define a RUby method using the `def` keyword.  Method definition sets a scope for local variables in terms of parameters and interaction with blocks\n\n```ruby\ndef greeting\n  puts \"Hello\"\nend \n```\n*method invocation*: is when we call a method, method invocation uses the scope set by the method definition. \n\n```ruby\n\ngreeting # calling the greeting method outputs \"Hello\"\n\n```\n- essentially a the block acts as an arugument to the method. In the same way that a local variable can be passed as an arugment to a method at incoation, when a method is called with a block it acts as an argument to the method. \n\nto use a block with a method invocation you must define the method to use with a block or have the method `yield` to the block.\n\n```ruby\ndef greeting \n  yield\n  puts \"goodbye\"\nend\n\nword = \"Hello\"\n\ngreetings do \n  puts word\nend \n\n# outputs 'Hello'\n# outputs 'Goodbye'\n\n```\n\n- when invoking a method with a block, were aren't just limited to executing code within the block,, depending on the method definition, the method can use the return value of the block to perform some other action\n\n```ruby\na = 'hello'\n\n[1,2,3].map {|num| a} # => ['hello', 'hello', 'hello']\n# uses return value to perform transformation \n\n```\n----\n\n### Variable shadowing\n\nvariable shadowing (examples below): When you name the \"block parameter\" the same as the local variable initialzed in the outer scope.  The parameter in the inner scope will block the local variable in the outscope,  and the variable in the inner scope will not have acess to the outer scope and and only access the inner scope.\n\n```ruby\n\nn = 10 \n\n[1,2,3].each do |n|\n  puts n\nend\n\n#1\n#2\n#3\n#nil \n\n```\n\n``` ruby\nn = 10\n\n1.times do |n|\n  n = 11\nend\n\nputs n # => 10 \n\n```\n\n### Variables as pointers \n\nwhen you initialized a new local variable it creates a new value in a new physical memory space. (unless you are assigning a variable to a variable (below))\n\n```ruby \na = 'hi there'\nb = a\na = 'not there' \n```\n- local variable `a` is initialized and is assigned to string object 'hi there'\n- local variable `b` is initialized and is assigned to variable `a` which points to string object 'hi there'.\n- local variable `a` and `b` are both pointing to string object 'hi there'\n- local variable `a` is reassigned to string object 'not there'.  \n`b` is still pointing to 'hi there'\n`a` is now pointing to 'not there' \n\n```ruby\n\na = 'hi there'\nb = 'a'\na << ', Bob'\n\n# a = 'hi there, Bob'\n# b = 'hi there, Bob'\n\n```\n\nIn the above example a mutating method `<<` is used to append ', Bob' to the string object which local variable a is pointing. The line of code `a` << \", Bob\" mutates the caller and modifies the exisiting string, which is also pointed to by the variable `b`.  `a` and `b` both reflect the changes to a because they are both pointing to the same thing. \n\n### Pass by reference vs Pass by value\n\npass by value: the method only has a copy of the original object. Operations performed on the object within the method have no effect on the original object outside the method. \n\npass by reference: a link to the object is passed to the method. \n\n\n### Variable References and Mutability of Ruby Objects\n\nWhen a string object reperesented by a string ('hello') is assigned to a local variable (`greeting`).  This causes the varibael `greeting` to reference the String object whose value is 'Hello', buy storing the object id of the string. \n\n(`greeting` (object 70101471431160)) -----------> (String ('Hello'))\n\nnow if you assign the variable `greeting` to another local variable `whazzup`\n\n`whazzup` = `greeting`\n\n(`greeting` (object 70101471431160))--+\n                                      |------------> (String ('Hello'))\n(`whazzup`  (object 70101471431160))--+ \n\nif you reasign `greeting` to a different String object the variable will reference a new object id and the `whazzup` variable will remain referencing the String object with value 'Hello'\n\n```ruby\ngreeting = 'dude'\n```\n\n(`greeting` (object 70109768889089))---------------> (String ('Dude'))\n\n(`whazzup`  (object 70101471431160))---------------> (String ('Hello'))\n\n*Mutability*\n\n**Mutable Objects**: Objects which can be changed. most objects in ruby are mutable.  \n\nArrays are mutable. You can reassign individual items of an array while maintaining the object ide of the array \n\n```ruby \na = ['a', 'b', 'c']\na[1] = '_'\n# a => ['a', '_', 'c']\n```\n\n(`a`(object: 70289098908908907)) ---------> \na[0]  | a[1] | a[2]\n--- | --- | ---\nobject: 18494 | object: 09809 | object: 09098\n                                            \n\n\n**Immutable objects**: Objects which cannot be changed.  \n- In ruby numbers and boolean values are immutable, objects of NilClass and Range objects. \n- There are no methods available that let you alter the value of an immutable object (you can only reassign). \n- Any class can establish itself as immutable by simply not providing any methods that alter its state. \n\n*Object Passing* \n\npass by value:  a copy is made and this is passed to the method\n\npassy by reference: a link to the original object is made and this is passed to the method. \n\n### mutating and Non-Mutating Methods in Ruby\n\nnon-mutating: a method is sead to be non-mutating with respect to an argument or its calling object if it does not modify it. Most methods you will encounter do not mutate their arguments or caller. some do mutate their caller, but few mutate the arguments. All methods are non-mutating with respect to immutable objects. \n\nassignment `=` is non-mutating. \n`+=`, `*=`, `-=`, `%=` are all non mutating as well (same as asignment)\n\nseeters methods for calss instance variables and indexed assignment are not the same as assginment.  Setter methods and indexed assigment usually mutate the calling object. \n\n*mutating method example* \n\n----\n\n```ruby\ndef fix(value)\n  value.upcase!\n  value.concat('!')\n  value\nend \n\ns = 'hello'\nt = fix(s)\n```\nin the above example after the method invocation \n`t` = 'HELLO!'\n`s` = 'HELLO!'\n\nwhen `t` is passed to the method, `value` and `t` are both pointing to the same string object 'hello' (`t` and `value` are aliases) . upcase! will mutate the caller, s `t` is still pointing to the original string object but it has not been upcased ('HELLO').  Concat also mutates the caller so `t` points to the original object which has been modified to 'HELLO!'.\n\n``` ruby \n\ndef fix(value)\n  value = value.upcase!\n  value.concat('!')\nend \n\ns = 'hello'\nt = fix(s)\n\n# s => \"HELLO!\"\n# t => \"HELLO!\"\n```\nin the above `s` is passed to the method. `s` and `value` are now pointing to `hello`.  A mutating method upcase! is called on value.  This value `HELLO` is assigned to `value` (`value` is bound to the object, albiet modified, it was bound to originally).  another mutating method is called on `value`.  \n\n**Indexed Assignment is Mutating relative to the caller**\n\nstring[3] = 'x'  this changes the object bound to indivdual letter, but the object entire string object is unaffected\n\narray[5] = 'cat' this changes the object bound to the index, but no the entire array object still points to the original \n\nhash[:age] = 25 this changes the object bound to the individual value, but the entire hash object still points to the original\n\n**Concatenation is Mutating**\n`#<<`\n\n```ruby \ns = 'hello' object id 1234\ns << '!'\ns = 'hello!' object id 1234\n```\n** setters are mutating **\n\n``` ruby \nperson.name = 'Bill'\nperson.age = 23\n```\nThis looks identical to reassignment (non-mutating) but these are setter calls and actually mutate the object bound to person. \n*non-mutating method example (assignment `=` is non-mutating.)*\n\n-----\n\n``` ruby \ndef fix(value)\n  value = value.upcase\n  value.concat('!')\nend\n\ns = 'hello' \nt = fix(s)\n```\nthe above code:\n `s` = 'hello' \n `t` = 'HELLO!'  # `t` is bound to a different object than `s`\n\nwe assign the return `value` of `value.upcase` back to `value`. #upcase does not modify the String reference by value, it creastes a new copy of the string reference by value, modifies the copy and then returns a reference to the copy. We then bind `value` to the returned reference\n\n### Object passing in ruby - Pass by reference or pass by value \n\nThe caller (or receiver) of a method call can be thought of as an implied argument. \n\n*Evaluation Strategies*\n\nThe strategy a program uses to determine when expressions a evaulated.  Ruby uses strict evaluation exclusively, with strict evaulation every expression is evaluted and converted to an object before it is passed along to a method. \n\n*Object Passing Strategies*\n\npass by value and pass by reference  are object passing strategies. Which are the two most common strict evaluation strategies. \n\n***RUBY IS PASS BY REFERECENCE ALL THE WAY DOWN***\n\nexample: \n``` ruby\ndef print_id number\n  puts \"In method object id = #{number.object_id}\"\nend\n\nvalue = 33\nputs \"Outside method object id = #{value.object_id}\"\nprint_id value \n\n# => outside method object id = 67\n# => In method object id = 67\n```\n***RUBY IS PASS BY REFERENCE VALUE***\n\nmost accurately ruby is pass by reference value, pass by reference of the value or pass by value of the referece. \n\nbut it could be described as `pass by reference` if you take into tak ineot account assignment and immutability. \n\n"
    }
  ]
}