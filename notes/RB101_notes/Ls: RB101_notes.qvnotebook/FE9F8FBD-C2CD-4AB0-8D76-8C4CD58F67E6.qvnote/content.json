{
  "title": "RB 101 Written Assesment: Canned lines",
  "cells": [
    {
      "type": "markdown",
      "data": "###General lines \n\nOn `line X` the variable `a` is initialized and the X object with value `X` is assigned to it. \n\n\nThe `do..end` alongside the loop method invocation on `lines 3 - 6` defines a block, which one parameter `letter`. \n\n- (1) one `line A`  the local variable `B` is initialized and is assigned to the return value of the `C` method call  on the `Array` object with value `E`. \n\n###Vocabulary to use\n\n- initialize\n- assign \n- referencing (i.e. points to) \n- reassigned\n- methods are defined with **parameters** but called wih **arguments**\n\n\n###Variable shadowing\n\nThe use of local variable `n` for the parameter of the `do..end` block creates *variable shadowing*.  Variable shadowing occurs when a parameter name of a block has the same name as a local variable which was initialized outside of the block. Variable shadowing prevents access to local variables of the same name outside of the block from within the block.\nSo on `line 5` we are assigning integer `5` to the local variable `n` passed in as a parameter of the `do..end` block. the value of the local variable `n` initiliaze in the outer block is uneffected, and remains `10`.\n\n###Each, Map and Select\n\n- (5) The `map` method iterates through the array, passing each element of the array to the block and assigning it to the variable `num`, with each iteration the return value of the block is then moved into a new array and that new array after all iterations have been completed the new array populated with the tranformed elements is returned. \n\n- (5) The `each` method iterates through the array, passing each element of the array to the block and assigning it to the variable `num`. The `each` method returns the original value of the `Array`, it does not take into consideration the return value of the block. \n\n- (5) The `map!` method  modifies the current element of the original `array` object, replacing it with the return value of the block for each iteration.  when it finishes all iterations it returns the original, albiet modified, `array` with the return values of the block for each element). \n\n- (5) The `select` method considers the truthiness of the return value of the block.  If the return value of the block evaluates to `true` it takes the element and puts it in a new `array` and returns the `array` after all iterations have been completed.. \n\n- (5) The `select!` method considers the truthiness of the return value of the block.  If return value of the block evaluates to `true`, the element of the current iteration of the `array` is maintained (not deleted) otherwise the element is removed from the array.  The original , albiet modified, `array` is returned after all iterations have been completed . \n\n`p` calls the `inspect` method on the object it is called on, which returns a human-readable representation of the object. The `p` method then outputs this object, and returns the  object  WHAT IS PUTS ACTUALLY OUTPUTTING AND RETURNING \n\n`inspect` returns a string containing a human-readable represenation of the object it is called on. \n\n`puts` prints a string representation of the object and returns `nil`\n\n`times` the `times` method is a looping method that will loop the number of times specified by the integer it is called upon, in this case `1`. With each iteration the current count of iterations is stored in variable `n`, locally scoped to the block, starting at integer `0`.\n\ninterpolation: `#{}` This string is using string interpolation, which allows an imbedded ruby expression to be interpretted and returned within the string. This case #{my_string} returns \"pumkins\"\n\neach_with_object: .each_with_object iterates through the array, assigning each element to `num` in turn and assigns a newly created empty array to `array`\n\neach_wtih_index \n\n"
    }
  ]
}