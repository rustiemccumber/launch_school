{
  "title": "RB101_Notes_MasterÂ ",
  "cells": [
    {
      "type": "markdown",
      "data": "### small problem list not completed in 20 min\n\n- medium_1: Rotation(P2) *didn't do psuedo code very well with this, additionally took more than 20, 25*\n\n### Lesson 1: Prepartions\n<details><summary>Git and Git hub:</summary>\n\n  - **do not nest git repositories**\n  \n  </details>\n\n<details><summary>Good vs Bad questions:</summary>\n\n  - if you can test a question in irb, dont ask, test\n  \n</details>\n\n<details><summary>Active Learning:</summary>\n\n  - take notes\n  - afterwords articulate ideas in your head\n  - review notes to ensure you captured key concepts\n  \n</details>\n\n### Lesson 2: Small programs\n\n<details><summary>Ruby style:</summary>\n\n- set tabs to 2 spaces for ruby\n- define or initailze method, variable, or file use `snake_case`\n- when you define a constant variable (number that does not change) use all uppercase (FOUR = 4)\n- when working with `do..end` blocks us {} when fit one line when declare a class name use `CamelCase`\n- \n\n</details>\n\n<details><summary>Ruby kick off video:</summary>\n\n- goals of the course\n  - build fluency in the language\n  - learn to think like a programmer\n    - learn to think procedurally\n  - learn to build apps\n  - debugging mindset\n\n</details>\n\n<details><summary>Note on Methods Style:</summary>\n\n- all methods can be followed by (), but not necessary\n  - gets().chomp() == gets.chomp \n- additionally you can call the module of the the method but not necessary\n  - Kernel.gets() \n- must rubiest don't use () with method unless they are passing in a variable `name.empty()` --> `name.empty`\n- you don't even need to put () when passing arguments as method calls `puts \"hi\"` vs `puts(\"hi\")`\n- try to avoid writing methods that both have a side affect and a meaningful return value.\n- what is a side affect: there is either displaying something or mutating an object (both can be side effects of the method)\n\nexample of method with side effects\n``` ruby\n# side effect: displays something to the output\n# returns: nil\n\ndef total(num1, num2)\n  puts num1 + num2\nend\n\n# side effect: mutates the passed-in array\n# returns: updated array\n\ndef append(target_array, value_to_append)\n  target_array << value_to_append\nend\n```\nexample of method WITHOUT side effects\n\n```ruby\n# side effect: none\n# returns: new integer\n\ndef total(num1, num2)\n  num1 + num2\nend\n```\n\n</details>\n\n<details><summary>Truthiness (IMPORTANT CONCEPT)(INCOMPLETE):</summary>\n\nEverything in Ruby other than nil and false, is truthy. \n\nputs returns nil \n\n- INCOMPLETE: return back to READ PRINT OUT and take notes \n\n</details>\n\n<details><summary>Walk Through: Calculator (INCOMPLETE) </summary>\n\n-  INCOMPLETE: return back to WATCH VIDEO and take notes\n\n</details>\n\n<details><summary>Psuedo Code </summary>\n\nInformal psuedo code: list of operations in plain english\n\n```ruby\n# Given a collection of integers.\n\n# Iterate through the collection one by one.\n#  - save the first value as the starting value.\n#  - for each iteration, compare the saved value with the current value.\n#  - if the saved value is greater, or it's the same\n#    - move to the next value in the collection\n#  - otherwise, if the current value is greater\n#   - reassign the saved value as the current value\n\n# After iterating through the collection, return the saved value.\n```\n\nFormal psuedo code\n\nkeyword |\tmeaning\n--- | ---\nSTART | start of the program\nSET |\tsets a variable we can use for later\nGET |\tretrieve input from user\nPRINT\t| displays output to user\nREAD |\tretrieve value from variable\nSUBPROCESS | denotes a subprocess\nIF / ELSE IF / ELSE |\tshow conditional branches in logic\nWHILE\t| show looping logic\nEND\t| end of the program\n\n```ruby\nSTART\n\n# Given a collection of integers called \"numbers\"\n\nSET iterator = 1\nSET saved_number = value within numbers collection at space 1\n\nWHILE iterator <= length of numbers\n  SET current_number = value within numbers collection at space \"iterator\"\n  IF saved_number >= current_number\n    go to the next iteration\n  ELSE\n    saved_number = current_number\n\n  iterator = iterator + 1\n\nPRINT saved_number\n\nEND\n```\nIf the problem is simple you can likely use full psuedo code to solve the problem. you might stil however find you logic is incorrect when testing and will need to alter logic. \n\nOnce it becomes more complicated you will need to psuedo code one part at a time in pseudo code, test it, then return back to pseudo code. to make the other parts\n\n</details>\n\n<details><summary>Flow Charts:</summary>\n\n- flowcharts are used in a *imperative* or *procedural* way to solve a problem (step by step)\n\n  - this is useful when the problem is large (pseudo code fails)\n  - subproceses can be noted in an *imperative* way (no step by step, just a rectangle representing)\n\n- flow charts let you zoom out on the overall logic, and identify subproess which you can focus on individually and in detail (in seperate flowcharts, pseudo code and code)\n\n![Screen Shot 2019-12-20 at 2.14.52 PM.png](quiver-image-url/5B2B45ECCC89C66C58308ECACBAF5E3A.png =295x416)\n\n</details>\n\n<details><summary>Debugging:</summary>\n\nSteps:\n1. Reproduce the error\n2. Determine the boundaries of the problem\n    - try inputing different variables, and testing edges.\n3. Trace the code \n   - find origin of the bug\n4. Understand the problem well\n   - find what exactly is happening, determine what is happening locally exactly at the problem spot or method\n5. Implement fix\n6. test the fix \n\nTechniques for debugging\n\n1. Line by line \n   - including reading the *stack trace* and to identify the error method and very carefully and tracing this back to root problem\n2. Rubber duck\n3. Walking away\n4. Use pry\n5. Use a debugger\n\n\n</details>\n\n<details><summary>Coding Tips (IMPORTANT: short seciton on truthiness):</summary>\n\n1. don't mutate constants (constants should be immutable)\n2. make methods specific, and do one thing (don't return a value, and display to the output (just one))\n3. decide whether method should return a value with side affects or perform side effects with no return value. (use ! in method name when there are side effects)\n4. keep your methods at same level of abstraction. iterate_through_cards is at a differenct level of abstraction. The others focus on the gameplay and hold subprocesses internally.\n   - hit()\n   - stay()\n   - iterate_through_cards\n5. truthiness: everything is truthy except `nil` or `false`\n\nri Array#push gives you the ruby doc in IRB\n\nthis allows you to do:\n\n``` ruby\nif user_input\n```\ninstead of \n``` ruby\nif user_input == true\n```\n\n5. use \"!\" in name when mutating\n6. methods = lego blocks, stand alone pieces of functionality to build larger structures.\n7. if you method prints something, name it accordingly (`print`, `say_`, `display`)\n\n(from more tips)\n8. do not mutate the caller during iteration (ex. add or remove items from an array)\nthis is fine because you are mutating indivdual objects\n\n```ruby \nwords = %w(scooby doo on channel two)\nwords.each {|str| str << '!'}\nputs words.inspect        # => [\"scooby!\", \"doo!\", \"on!\", \"channel!\", \"two!\"]\n```\nthis is NOT ok because you are mutating the caller array\n\n```ruby\nwords = %w(scooby doo on channel two)\nwords.each {|str| words.delete(str)}\nputs words.inspect        # => [\"doo\", \"channel\"]\n```\n9. don't use assignment in conditional\n```ruby \n#do this \nif number_cats == 5\n\n#not this \nif number_cats = 5\n```\n10. wrap things in () if they are intentional but confusing to read\n\n```ruby\nwhile (num = numbers.shift)\n  puts num\nend\n```\n11. use underscores for unused parameters \n\n``` ruby\nnames = ['kim', 'joe', 'sam']\nnames.each { |_| puts \"got a name!\" }\n```\n12. if you have an unused parameter replace with underscore. \n\n``` ruby\nnames.each_with_index do|_, idx|\n  puts \"#{idx+1}. got a name!\"\nend\n```\n\n13. use new lines to different concerns in the code (variable initialization, user input and validation, using the variable).\n\n```ruby\n\nname = '' # variable initialization \n\nputs \"Enter your name: \"\nloop do\n  name = gets.chomp         # User input and validation\n  break unless name.empty?\n  puts \"That's an invalid name. Try again:\"\nend\n\nputs \"Welcome #{name}!\"   # using the variable \nputs \"What would you like to do?\"  \n\n```\n\n</details>\n\n\n<details><summary>Variable Scope (IMPORTANT CONCEPT)(INCOMPLETE):</summary>\n\n- [Variable scope](https://launchschool.com/lessons/a0f3cd44/assignments/fff0b9db) (INCOMPLETE): return back to READ PRINT OUT and take notes [READ PRINT OUT](/variable_scope_1_print.pdf/)\n- [More variable scope](https://launchschool.com/lessons/a0f3cd44/assignments/9e9e907c0) (INCOMPLETE): return back to [READ PRINT OUT](/variable_scope_2_print.pdf/) and take notes\n\n</details>\n\n<details><summary>Pass by Reference vs Pass by Value (IMPORTANT CONCEPT)(INCOMPLETE):</summary>\n\n- [pass reference pass value](https://launchschool.com/lessons/a0f3cd44/assignments/4b1ad598) (INCOMPLETE): return back to READ PRINT OUT and take notes [READ PRINT OUT]\n\n- [variables as pointers](https://launchschool.com/books/ruby/read/more_stuff#variables_as_pointers) (INCOMPLETE)\n\n- [Variable References and Mutability of Ruby Objects](https://launchschool.com/blog/references-and-mutability-in-ruby) (INCOMPLETE) (PRINTOUT)\n- [Mutating and non-mutating methods in ruby](https://launchschool.com/blog/mutating-and-non-mutating-methods)(INCOMPLETE)(Printout)\n- [Object Passing in Ruby - Pass by Reference or Pass by Value](https://launchschool.com/blog/object-passing-in-ruby) (INCOMPLETE)(PRINTOUT)\n\n</details>\n\n\n<details><summary> Variable Shadowing </summary>\n\n[Variable Shadowing](https://launchschool.com/lessons/a0f3cd44/assignments/f612fbc5) occures when choose a local variable in the innerscope that shares the same name as the outerscope.  This prevents in the innerscope from acessing the outerscope \n\nthis is variable shadowing \n``` ruby\nname = 'johnson'\n\n['kim', 'joe', 'sam'].each do |name|\n  # uh-oh, we cannot access the outer scoped \"name\"!\n  puts \"#{name} #{name}\"\nend\n```\nthis is not variable shadowing inner scope is acessing the outter scope local variable `name` and reassigning it.  After the each block, the name will be set to \"sam\".\n\n```ruby\nname = 'johnson'\n\n['kim', 'joe', 'sam'].each do |fname|\n  name = fname\nend\n```\nIMPORTANT: EXAMPLE OF VARIABLE SHADOWING IN A NORMAL LOOP\n\n- How does the block know what num is? For each iteration, each sends the value of the current element to the block in the form of an argument. In this block, the argument to the block is num and it represents the value of the current element in the array.\n\n</details>\n\n<details><summary> Variable Re-assingment and mutation  </summary>\n\ntwo students questions: \n\n- [question 1](https://launchschool.com/posts/4a62e769)\n- [question 2](https://launchschool.com/posts/f62ba91a)\n\n</details>\n\n### Lesson 4: Ruby collections\n\n<details><summary> Collection Basics  </summary>\n\n``` ruby\n\nstr = 'abcdefghi'\nstr[2, 3] # => cde\n\nstr[2, 3][0] # => \"c\"\n\n``` \nThe above starts at string position 2 and returns the following 3 positions, including the position 2. \n\nThis is the same is str.slice(2, 3)\n\n``` ruby\narr = [1, 'two', :three, '4']\narr.slice(3, 1) # => [\"4\"]\narr.slice(3..3) # => [\"4\"]\narr.slice(3)    # => \"4\"\n```\n--------------------------------------------------------\n### Hashes \n\n``` ruby \n\nhsh = { 'fruit' = 'apple', 'vegetable' = 'carrot'}\nhsh['fruit'] # => 'apple'\nhsh['fruit'][0] # => 'a'\n\n```\nwhen initializing a hash, keys must be unique \n\n``` ruby\nhsh = { 'fruit' => 'apple', 'vegetable' => 'carrot', 'fruit' => 'pear' }\n\n(irb):1: warning: key :fruit is duplicated and overwritten on line 1\n=> {\"fruit\"=>\"pear\", \"vegetable\"=>\"carrot\"}\n```\n\nhowever values can be duplicated\n\n``` ruby\nhsh = { 'apple' => 'fruit', 'carrot' => 'vegetable', 'pear' => 'fruit' }\n```\ngotchas\n\n```ruby\narr.fetch(3) # will tell you if an position is out of bounds or actually nil. if you just you arr[3] it will return nil in both cases\n```\n</details>\n\n<details><summary> Looping  </summary>\n\nan example of of `loop` where break is place on the last line mimics the behavior of a \"do/while\" loop.  **the code within the block is guarenteed to execute at least once**\n\nif break is moved to the first line within the block, mimics behavior of while loop. **this means the code within the block might not execute at all depending on the condition**\n\n`next` skips current iteration depending on condition\n```ruby\n\nnext if counter.odd?\n```\n\n</details>\n\n<details><summary> PEDAC approach (TEMPLATE)  </summary>\n\n[Template made by student](https://gist.github.com/Cadowyn/a8b78f9682d026348dc5c0aa7e01eded)\n\n</details>\n\n<details><summary> Selection and Transfromation (IMPORTANT)  </summary>\n\n- Selection: is picking certain elements out of a collection depending on some criterion. *If there are `n` elements in the collection, selection always results in `n` or less elemnts\n\n- Transfromation: manipulating every element in the collection. *transformation always results in `n` elements. \n\n</details>\n\n<details><summary> Methods (each, select, map (and others!)) (IMPORTANT)  </summary>\n\n\nMethod |\tAction |\tConsiders the return value of the block? |\tReturns a new collection from the method? | Length of the returned collection\n--- | --- | --- | --- | ---\neach | Iteration |\tNo |\tNo, it returns the original |\tLength of original\nselect |\tSelection |\tYes, its truthiness\t| Yes | \tLength of original or less\nmap\t| Transformation |\tYes |\tYes |\tLength of original\n\neach:\n- once each is done iterating it returns *original collection*\n\nselect:\n- evalutates the return value of the block\n- returns a new collection with all the items that evaluated to true or had a truthy value depending on the criterion of the code block\n\n``` ruby\n[1, 2, 3].select do |num|\n  num + 1\nend\n\n# => [1, 2, 3] because (num + 1) is evaluates to true (or is truthy) for all items of the collection (everything is selected)\n\n```\n``` ruby\n[1, 2, 3].select do |num|\n  num + 1\n  puts num\nend \n # => [] becuase the last expression evaluates to nil (or is falsey) for all items of the collection (nothing is selected). additionally this will will display 1 2 3 (all on new lines)\n```\n\nmap:\n- map considers the return value of the the of the block and uses this to perform tranformations\n- returns a new collection with each item of the collection transformed\n\n``` ruby\n[1, 2, 3].map do |num|\n  num * 2\nend\n\n# => [2, 4, 6] (new array)\n```\n``` ruby \n[1, 2, 3].map do |num|\n  num.odd?\n  puts num\nend\n\n# => [nil, nil, nil] new array additionally it displays each number 1 2 3 on new lines\n```\n---\n### Other useful methods\n\nEnumerable#any?\n\n---------------\n\nlooks at the truthiness of the blocks return value an item, if any return values evaluate to true, the return value of the method will be true\n\n``` ruby \n[1, 2, 3].any? do |num|\n  num > 2\nend\n# => true\n```\n\nEnumerable#all?\n\n---------------\nlooks at the truthiness of the blocks return value an item, if all return values evaluate to true, the return value of the method will be true\n\n```ruby\n{ a: \"ant\", b: \"bear\", c: \"cat\" }.all? do |key, value|\n  value.length >= 3\nend\n# => true\n```\n\nEnumerable#each_with_index\n\n--------------------------\nequivalent to `each` but takes a second argument which represents the index of each element \n\n``` ruby\n{ a: \"ant\", b: \"bear\", c: \"cat\" }.each_with_index do |pair, index|\n  puts \"The index of #{pair} is #{index}.\"\nend\n\n# The index of [:a, \"ant\"] is 0.\n# The index of [:b, \"bear\"] is 1.\n# The index of [:c, \"cat\"] is 2.\n# => { :a => \"ant\", :b => \"bear\", :c => \"cat\" }\n```\n\nEnumerable#each_with_object\n\n---------------------------\n\n``` ruby\n{ a: \"ant\", b: \"bear\", c: \"cat\" }.each_with_object({}) do |(key, value), hash|\n  hash[value] = key\nend\n# => { \"ant\" => :a, \"bear\" => :b, \"cat\" => :c }\n```\n\n\nEnumerable#first\n\n----------------\n\n`first()`\n\n```ruby \n{ a: \"ant\", b: \"bear\", c: \"cat\" }.first(2)\n# => [[:a, \"ant\"], [:b, \"bear\"]]\n```\n\nEnumerable#include?\n\n---------------------\n\n`include?` returns true if argument exists in the collection and false if it doesn\n\n```ruby\n\n[1, 2, 3].include?(1)\n# => true\n```\nwhen it's called on a hash it only checks the keys and not the values. \n\n``` ruby\n{ a: \"ant\", b: \"bear\", c:  \"cat\"}.include?(\"ant\")\n\n# => false\n\n{ a: \"ant\", b: \"bear\", c: \"cat\" }.include?(:a)\n\n# => true\n```\n\n\nEnumerable#partition \n\n```ruby\n[1, 2, 3].partition do |num|\n  num.odd?\nend\n# => [[1, 3], [2]]\n```\n``` ruby\nlong, short = { a: \"ant\", b: \"bear\", c: \"cat\" }.partition do |key, value|\n  value.size > 3\nend\n# => [[[:b, \"bear\"]], [[:a, \"ant\"], [:c, \"cat\"]]]\n```\n</details>\n\n\n### Lesson 5: Ruby advance collections \n\n<details><summary> sorting  </summary>\n\n#### The `<=>` method \n\n----------------------\n\n`<=>` method (spaceship operator)\n\n- performs comparision on two objects *of the same type* and returns a `-1`, `0` or `1` depending whether the first object is less than, equal or greater than second object. nil returned if cannot be compared\n- the relative values of string characters are determined by the [ASCII chart](https://en.wikipedia.org/wiki/ASCII#Code_chart)\n  - All uppercase come before lowercase letters; for example, \"Z\" precedes \"a\"\n  - Digits and many punctuation marks come before letters\n- `ord` will give you the ASCII value of character\n- \n \n```ruby\n'b'.ord # => 98\n'}'.ord # => 125\n```\nyou can call `sort` with a `do..end` block to have more control of sorting\n\n``` ruby\n\n[3, 4, 5, 1, 2].sort do |a, b|\n  b <=> a \nend \n\n# => [5, 4, 3, 2, 1]\n```\nsorting strings of dif length. goes through and compares letter to letter, if strings are same but one adds a char at end, longer is greater. \n\n``` ruby\n['arc', 'bat', 'cape', 'ants', 'cap'].sort\n\n# => ['ants', 'arc', 'bat', 'cap', 'cape'].sort \n```\ncomparing multiple nested arrays.  each nested array is compared item to item (first_1 to first_2, 2nd_1 to 2nd_2) as soon as any two items have a non-zero comparision, the result is returned for the who array comparision.\n\nif two array have all the same items but one has another char added to array, the longer one is greater. \n\nIF YOU TRY TO COMPARE SUBARRAYS WHERE DIFFERENT TYPES ARE COMPARED AN ERROR WILL BE THROWN. \n\n#### The `sort_by` method\n\n_________________________\n\n``` ruby\n\n['cot', 'bed', 'mat'].sort_by do |word|\n  word[1]\nend\n# => [\"mat\", \"bed\", \"cot\"] this will compare index position 1 in each item ( a, e, o)\n```\n\n</details>\n\n<details><summary> Nested array structures  </summary>\n\n``` ruby \narr = [[1, 3], [2]]\narr[0][1] = 5\n\narr # => [[1, 5], [2]]\n```\n```ruby\narr = [[1], [2]]\n\narr[0] << 3\narr # => [[1, 3], [2]]\n```\n```ruby\n\narr = [[1], [2]]\n\narr[0] << [3]\narr # => [[1, [3]], [2]]\n```\n\nmodifying variables in nested arrays\n\n![Screen Shot 2019-12-23 at 6.25.10 PM.png](quiver-image-url/A0463244ED9B457C398BF8C5CEE165FA.png =907x531)\n\nmodifying arrays with variables as pointers\n\n![Screen Shot 2019-12-23 at 6.25.19 PM.png](quiver-image-url/0735BD8877FBABD2518CD629AFBA3EB1.png =903x181)\n\nIn both cases above the local variables `a` and `b` are modified. Wether the are modified from inside out or outside array they are pointing to the same object. \n\n#### creating shallow copies\n\n----------------------------\n\n`dup` and `clone` both create shallow copies. \n\nshallow copy: copies the object that the method is called on (instead of creating a reference. however, if the object contains other objects, like a nested array, these objects will be shared (passed by reference).\n\n```ruby\narr1 = [\"a\", \"b\", \"c\"]\narr2 = arr1.dup\narr2[1].upcase!\n\narr2 # => [\"a\", \"B\", \"c\"]\narr1 # => [\"a\", \"B\", \"c\"]\n```\nAbove: index 1 is updated in both arrays because a destructive method is used .upcase! and called on the object within the array, not on the array itself. \n\n``` ruby\narr1 = [\"a\", \"b\", \"c\"]\narr2 = arr1.dup\narr2.map! do |char|\n  char.upcase\nend\n\narr1 # => [\"a\", \"b\", \"c\"]\narr2 # => [\"A\", \"B\", \"C\"]\n```\nAbove destructive method is called on the array and so only arr2 is changes\n\n``` ruby\narr1 = [\"a\", \"b\", \"c\"]\narr2 = arr1.dup\narr2.each do |char|\n  char.upcase!\nend\n\narr1 # => [\"A\", \"B\", \"C\"]\narr2 # => [\"A\", \"B\", \"C\"]\n```\n\nAbove destrucitve method is called on each individual item of array so both arrays are changed. \n\n#### freeze objects\n\n```ruby\narr1 = [\"a\", \"b\", \"c\"].freeze\narr2 = arr1.dup\narr2 << \"d\"\n\narr2 # => [\"a\", \"b\", \"c\", \"d\"]\narr1 # => [\"a\", \"b\", \"c\"]\n```\n\nonly muteable objects can be frozen, because immuteable objects are already frozen. \n\n```ruby\n5.frozen? # => true\n```\n\n</details>\n\n<details><summary> Working with Blocks (IMPORTANT) </summary>\n\nWORTH REVIEWING THIS SECTION FOR TEST IF YOU HAVE TIME\nthis section shows how to break down a block of code\n\n``` ruby\n[[1, 2], [3, 4]].each do |arr|\n  puts arr.first\nend\n# 1\n# 3\n# => [[1, 2], [3, 4]]\n```\n![Screen Shot 2019-12-24 at 1.58.38 PM.png](quiver-image-url/EDA646F848CB81FFF1F1978FE94D9A22.png =890x261)\n\n</details>\n"
    }
  ]
}