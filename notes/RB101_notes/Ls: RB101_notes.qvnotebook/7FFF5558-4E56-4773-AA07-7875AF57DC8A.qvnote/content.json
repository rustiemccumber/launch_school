{
  "title": "RB101_Notes_MasterÂ ",
  "cells": [
    {
      "type": "markdown",
      "data": "### Lesson 1: Prepartions\n<details><summary>Git and Git hub:</summary>\n\n  - **do not nest git repositories**\n  \n  </details>\n\n<details><summary>Good vs Bad questions:</summary>\n\n  - if you can test a question in irb, dont ask, test\n  \n</details>\n\n<details><summary>Active Learning:</summary>\n\n  - take notes\n  - afterwords articulate ideas in your head\n  - review notes to ensure you captured key concepts\n  \n</details>\n\n### Lesson 2: Small programs\n\n<details><summary>Ruby style:</summary>\n\n- set tabs to 2 spaces for ruby\n- define or initailze method, variable, or file use `snake_case`\n- when you define a constant variable (number that does not change) use all uppercase (FOUR = 4)\n- when working with `do..end` blocks us {} when fit one line when declare a class name use `CamelCase`\n- \n\n</details>\n\n<details><summary>Ruby kick off video:</summary>\n\n- goals of the course\n  - build fluency in the language\n  - learn to think like a programmer\n    - learn to think procedurally\n  - learn to build apps\n  - debugging mindset\n\n</details>\n\n<details><summary>Note on Methods Style:</summary>\n\n- all methods can be followed by (), but not necessary\n  - gets().chomp() == gets.chomp \n- additionally you can call the module of the the method but not necessary\n  - Kernel.gets() \n- must rubiest don't use () with method unless they are passing in a variable `name.empty()` --> `name.empty`\n- you don't even need to put () when passing arguments as method calls `puts \"hi\"` vs `puts(\"hi\")`\n\n\n</details>\n\n<details><summary>Truthiness (IMPORTANT CONCEPT)(INCOMPLETE):</summary>\n\n- INCOMPLETE: return back to READ PRINT OUT and take notes \n\n</details>\n\n<details><summary>Walk Through: Calculator (INCOMPLETE) </summary>\n\n-  INCOMPLETE: return back to WATCH VIDEO and take notes\n\n</details>\n\n<details><summary>Psuedo Code </summary>\n\nInformal psuedo code: list of operations in plain english\n\n```ruby\n# Given a collection of integers.\n\n# Iterate through the collection one by one.\n#  - save the first value as the starting value.\n#  - for each iteration, compare the saved value with the current value.\n#  - if the saved value is greater, or it's the same\n#    - move to the next value in the collection\n#  - otherwise, if the current value is greater\n#   - reassign the saved value as the current value\n\n# After iterating through the collection, return the saved value.\n```\n\nFormal psuedo code\n\nkeyword |\tmeaning\n--- | ---\nSTART | start of the program\nSET |\tsets a variable we can use for later\nGET |\tretrieve input from user\nPRINT\t| displays output to user\nREAD |\tretrieve value from variable\nSUBPROCESS | denotes a subprocess\nIF / ELSE IF / ELSE |\tshow conditional branches in logic\nWHILE\t| show looping logic\nEND\t| end of the program\n\n```ruby\nSTART\n\n# Given a collection of integers called \"numbers\"\n\nSET iterator = 1\nSET saved_number = value within numbers collection at space 1\n\nWHILE iterator <= length of numbers\n  SET current_number = value within numbers collection at space \"iterator\"\n  IF saved_number >= current_number\n    go to the next iteration\n  ELSE\n    saved_number = current_number\n\n  iterator = iterator + 1\n\nPRINT saved_number\n\nEND\n```\nIf the problem is simple you can likely use full psuedo code to solve the problem. you might stil however find you logic is incorrect when testing and will need to alter logic. \n\nOnce it becomes more complicated you will need to psuedo code one part at a time in pseudo code, test it, then return back to pseudo code. to make the other parts\n\n</details>\n\n<details><summary>Flow Charts:</summary>\n\n- flowcharts are used in a *imperative* or *procedural* way to solve a problem (step by step)\n\n  - this is useful when the problem is large (pseudo code fails)\n  - subproceses can be noted in an *imperative* way (no step by step, just a rectangle representing)\n\n- flow charts let you zoom out on the overall logic, and identify subproess which you can focus on individually and in detail (in seperate flowcharts, pseudo code and code)\n\n![Screen Shot 2019-12-20 at 2.14.52 PM.png](quiver-image-url/5B2B45ECCC89C66C58308ECACBAF5E3A.png =295x416)\n\n</details>\n\n<details><summary>Debugging:</summary>\n\nSteps:\n1. Reproduce the error\n2. Determine the boundaries of the problem\n    - try inputing different variables, and testing edges.\n3. Trace the code \n   - find origin of the bug\n4. Understand the problem well\n   - find what exactly is happening, determine what is happening locally exactly at the problem spot or method\n5. Implement fix\n6. test the fix \n\nTechniques for debugging\n\n1. Line by line \n   - including reading the *stack trace* and to identify the error method and very carefully and tracing this back to root problem\n2. Rubber duck\n3. Walking away\n4. Use pry\n5. Use a debugger\n\n\n</details>\n\n<details><summary>Coding Tips (IMPORTANT: short seciton on truthiness):</summary>\n\n1. don't mutate constants (constants should be immutable)\n2. make methods specific, and do one thing (don't return a value, and display to the output (just one))\n3. decide whether method should return a value with side affects or perform side effects with no return value. (use ! in method name when there are side effects)\n4. keep your methods at same level of abstraction. iterate_through_cards is at a differenct level of abstraction. The others focus on the gameplay and hold subprocesses internally.\n   - hit()\n   - stay()\n   - iterate_through_cards\n5. truthiness: everything is truthy except `nil` or `false`\n\nthis allows you to do:\n\n``` ruby\nif user_input\n```\ninstead of \n``` ruby\nif user_input == true\n```\n\n5. use \"!\" in name when mutating\n6. methods = lego blocks, stand alone pieces of functionality to build larger structures.\n7. if you method prints something, name it accordingly (`print`, `say_`, `display`)\n\n\n</details>\n\n\n<details><summary>Variable Scope (IMPORTANT CONCEPT)(INCOMPLETE):</summary>\n\n- [Variable scope](https://launchschool.com/lessons/a0f3cd44/assignments/fff0b9db) (INCOMPLETE): return back to READ PRINT OUT and take notes [READ PRINT OUT](/variable_scope_1_print.pdf/)\n- [More variable scope](https://launchschool.com/lessons/a0f3cd44/assignments/9e9e907c0) (INCOMPLETE): return back to [READ PRINT OUT](/variable_scope_2_print.pdf/) and take notes\n\n</details>\n\n<details><summary>Pass by Reference vs Pass by Value (IMPORTANT CONCEPT)(INCOMPLETE):</summary>\n\n- [pass reference pass value](https://launchschool.com/lessons/a0f3cd44/assignments/4b1ad598) (INCOMPLETE): return back to READ PRINT OUT and take notes [READ PRINT OUT]\n\n- [variables as pointers](https://launchschool.com/books/ruby/read/more_stuff#variables_as_pointers) (INCOMPLETE)\n\n- [Variable References and Mutability of Ruby Objects](https://launchschool.com/blog/references-and-mutability-in-ruby) (INCOMPLETE) (PRINTOUT)\n- [Mutating and non-mutating methods in ruby](https://launchschool.com/blog/mutating-and-non-mutating-methods)(INCOMPLETE)(Printout)\n- [Object Passing in Ruby - Pass by Reference or Pass by Value](https://launchschool.com/blog/object-passing-in-ruby) (INCOMPLETE)(PRINTOUT)\n\n</details>"
    }
  ]
}