{
  "title": "RB 101 Pracitce Test: Ryan Schaul copyÂ ",
  "cells": [
    {
      "type": "markdown",
      "data": "```ruby\na = [1, 2, 3, 3]\nb = a\nc = a.uniq\n```\n\non `line 1` the local variable `a` is initialize and the array object with value `[1, 2, 3, 3]` is assigned to it.\n\non `line 2` the loca variable `b` is initialize and the value of the local variable `a` is assigned to it. now both `a` and `b` are pointing to the same array object. \n\non `line 3` local variable `c` is initialized and the return value of the method call `uniq` on the value of local variable `a` is assigned to it. uniq is a non-mutating method, and creates a array object with the repeating elements deleted.  so a and b are pointing to the same array object still while `c` is pointing to a new array object `[1,2,3]`\n\n```ruby\ndef test(b)\n  b.map { |letter| \"I like the letter: #{letter}\" }\nend\n\na = ['a', 'b', 'c']\np test(a)\np a\n```\non line 1 the method `test` is defined which takes one parameter `b`\n\none line 5 the local variable `a` is initialized and the array object `['a', 'b', 'c']` is assigned to it. \non line 6 the method `test` is called withe the local variable `a` passed to it as a parameter.  the return value of this method is then passed to the method `p` as a parameter.  `p` calls the `inspect` method on the object which is passed to it, inspect returns a human readable string object, this string object is then output by the the `p` method. \n\non line one the variable `b` local to the method `test` is set to point to the same array value which is being referenced by `a`, `['a', 'b', 'c']`\n\non line 2 the method map is called on array object which `a` and `b` are referecning. one line 2 a `{..}` block is defined which takes one parameter `letter`.  The map method iterates through the array passing each element of the array to the block assigning it to the variable `letter`, the return value of the block is then moved to a new array object, this is repeated with each iteration. \n\nthe return value of the `test` method is [\"I like the letter: #{letter}\"....]\n\nline 6 outputs this [\"I like the letter: #{letter}\"....]\n\nline 7 calls the `p` method with the local variable `a` passed to it as a parameter.  `['a', 'b', 'c']` is output because a was not mutated within the method. \n\n```ruby\ndef test(b)\n  b.map! {|letter| \"I like the letter: #{letter}\" }\nend\n\na = ['a', 'b', 'c']\np test(a)\np a\n```\non line 1 the method `test` is defined which takes one parameter `b`\n\none line 5 the local variable `a` is initialized and the array object `['a', 'b', 'c']` is assigned to it. \non line 6 the method `test` is called withe the local variable `a` passed to it as a parameter.  the return value of this method is then passed to the method `p` as a parameter.  `p` calls the `inspect` method on the object which is passed to it, inspect returns a human readable string object, this string object is then output by the the `p` method. \n\non line one the variable `b` local to the method `test` is set to point to the same array value which is being referenced by `a`, `['a', 'b', 'c']`\n\non line 2 the mutating method `map!` is called on the array object which is being referenced by `a` and `b` The `map!` method  modifies the current element of the original `array` object, replacing it with the return value of the block for each iteration.  when it finishes every iteration it returns the original, albiet modified, `array` with the return values of the block for each element).   The `test` method returns [\"I like the letter: #{letter}\"...]\n\non line 6 [\"I like the letter: #{letter}\"...] is ouput\n\non line 7 the method `p` is called and the variable `a` is passed to it as an argument. the array object was mutated within the method `test` so this value has been changed to [\"I like the letter: #{letter}\"...]\n\n\n```ruby\nmy_arr = [[18, 7], [3, 12]].each do |arr|\n  arr.each do |num|\n    if num > 5\n      puts num\n    end\n  end\nend\n```\non line 1 the variable `my_arr` is initalized, the method `each` is called on the array object [[18, 7], [3, 12]], the return value is assigned to `my_arr`.  \n\non line 1-5 a block is defined that takes 1 parameter `arr`.   \n\nThe `each` method iterates through the array, passing each element of the array to the block and assigning it to the variable `arr`.  In this case each entire sub array is passed to the variable `arr`. The `each` method returns the original value of the `Array`, it does not take into consideration the return value of the block.\n\non line 2 the `each` method is called on the variable local to the block `num`. on lines 2-5 a `do..end` block is defined an passed to the 2nd `each` method as an argument. \n\nthe each method iterates through each subarray and passes each element of the sub array to the block assinging it to be referenced by `num`.   the each method then returns the original value of the array. \n\non line 3 - 4 a conditional statemnt is defined whic is triggered if the current element of the sub array is greater than `5` i this occurs the `puts` method its called and the current elements is passed to it as an argument.\n\n18, 7 and 12 are output on newlines. the orginal array `[[18, 7], [3, 12]]` is returned because it is the last line of the code. \n\n\n\n```ruby\nn = 10\n\n[1, 2, 3].each do |n|\n  puts n\nend\n\np n\n```\n\none lin 1 the local variable `n` is initialized and the integer with value `10` is assigned to it. \n\non line 3 the method `each` is called on the array object with value `[1, 2, 3]`.  on line 3-4 a `do..end` block is defined with one parameter `n` and passed to the `each` method as an argument. \n\nThe `each` method iterates through the array, passing each element of the array to the block and assigning it to the variable `n`. The `each` method returns the original value of the Array object [1, 2, 3], it does not take into consideration the return value of the block. \n\nThe use of local variable `n` for the parameter of the `do..end` block creates *variable shadowing*.  Variable shadowing occurs when a parameter name of a block has the same name as a local variable which was initialized outside of the block. Variable shadowing prevents access to local variables of the same name outside of the block from within the block.\nSo on `line 5` we are assigning integer `5` to the local variable `n` passed in as a parameter of the `do..end` block. the value of the local variable `n` initiliaze in the outer block is uneffected, and remains `10`.\n\non line 4 the method `puts` is called with the variable `n` passed to it as an argument.  which outputs 1, 2, 3 on new lines. \n\non line 7 the the `p` method is called with the local variable `n` passed to it as an argumnet.  calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs this string. so `10` is output because it variable shadowing left it unaffected.\n\n\n\n```ruby\n[[1, 2], [3, 4]].map do |arr|\n  arr.map do |num|\n    num * 2\n  end\nend\n```\n\non line one the method `map` is called on the array object `[[1, 2], [3, 4]]`. on line 1-5 a `do..end` block is defined with one parameter `arr` and passed to the `map` method as an argument.  \n\n`Map` iterates through array object, passing in each element of the array to the block, assigning the element to the variable `arr`, then runs the block. Map then takes the return value of the block and moves it to a new array, after every iteration it returns the new array with elements which were passed into it (return values of block of each iteration). \n\nIn this case each sub array is passed to the variable `arr`\n\non line 2 the `map` method is called again but on the variable arr. On line 2-4 a {do..end} blcok is defined with one parameter `num`.  the map method iterates through each element of the subarray passed to it, assigning this calue to the `num` variable and moving the return value of the block to a new array.\n\non line 3 the `num` variable is mutliped by integer `2`.  Each element of each subarray is transform by this muliplication. \n\n\n`a new nested array is returned [[2, 4], [6, 8]]`\n\n\n\n```ruby\ndef fix(value)\n  value << 'xyz'\n  value = value.upcase\n  value.concat('!')\nend\ns = 'hello'\nt = fix(s)\n```\n\non line 1 a method `fix` is defined that takes one parameter `value`\n\non line 6 the local variable `s` is defined, and the string object with value `hello` is assgined to it \non line 7 the method `fix` is called and the local variable `s` is passed to it, the local variable `t` is initilized and the return value of the above method call is assigned to it. \n\non line 1 the variable `value` local to the method definition `fix` is set to point to the same string object that `s` is referecning, `hello` \n\non line 2 the mutating method `<<`, know on as the shovel method, is called on the string object `hello` which is being referenced by both `s` and `value`. The string object `xyz` is passed to it as an arugment. This mutating method modifies both the string that value and s are referencing. value and s are both pointing to `helloxyz`\n\non line 3 the non-mutating method `upcase` is called on the object `helloxyz`, which creates a new string object `HELLOXYZ`.  This value is reassigned to the variable `value` this reassignment breaks the reference to `s` outside of the method. \non line 4 the mutating method `concated` is called on the value of variable `value` and `!` is passed to it as an argument.  returning `HELLOXYZ!`, this is the last line of the code run so this is also the return value of the method `fix`. \n\non line 6 s is now pointing to `helloxyz`\n\nt is now pointing to `HELLOXYZ!`\n\n```ruby\nn = 10\n\n1.times do |n|\n  n = 11\nend\n\nputs n\n```\non line 1 the local variable n is initialized and the integer with value `10` is assigned to it.\n\non line 3 the method `times` is called on the integer `1`.  on line 3 a `do..end` block is defined with one variable `n`\n\nthe `times` method is a looping method that will loop the number of times specified by the integer it is called upon, in this case `1`. With each iteration the current count of iterations is stored in variable `n`, locally scoped to the block, starting at integer `0`.\n\nThe use of local variable `n` for the parameter of the `do..end` block creates *variable shadowing*.  Variable shadowing occurs when a parameter name of a block has the same name as a local variable which was initialized outside of the block. Variable shadowing prevents access to local variables of the same name outside of the block from within the block.\nSo on `line 4` we are assigning integer `11` to the local variable `n` passed in as a parameter of the `do..end` block. the value of the local variable `n` initiliaze in the outer block is uneffected, and remains `10`.  \n\nThe times method returns `1` because that is the last line of the code in the method run. \n\non line 7 the `puts` method is called with the local variable `n` passed to it as an argument. line 7 outputs `10` (variable shadowing did not allow reassignent). then `nil` is returned\n\n\n\n```ruby\na = \"hello\"\n\n[1, 2, 3].map do |num| \n  a \nend\n```\n\non line 1 the local variable `a` is initialized and the string object `hello` is assigned to it\n\non line 3 the method `map` is called on the array object with value `[1, 2, 3]`.  on line 3-4 a block is called with one parameter `num`. \n\n`map` iterates through array object, passing in each element of the array to the block, assigning the element to the variable `num`, then runs the block. Map then takes the return value of the block and moves it to a new array, after every iteration it returns the new array with elements which were passed into it (return values of block of each iteration). \n\nin this case the variable value `hello` is returned by the block with each iteration.  and the final return value of the method call is `['hello', 'hello', 'hello']`\n\n\n```ruby\ndef change_name(name)\n  name = 'bob'\nend\n\nname = 'jim'\np change_name(name)\nputs name \n```\n\non line 1-3 the method definition `change_name` is defined with one parameter `name`. \n\non line 5 the local variable `name` is defined with the string object with value `jim` assinged to  it.\n\non line 6 the the method `change_name` is called with the variable `name` passed to it as an argument. the return value of this method call is then passed to the `p` method.  `p` calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs this string, and returns the string object.\n\non line 1 the variable `name` local to the variable `change_name` is assigned to point to the string object `name` the same object with the local variable `name` is refencing outside of the method. on line 2 the string object bob is reassigned to the `name` variable, this reassignment breaks the reference to the external string object `jim`\n\nbecauase this is the last line of the method, `change_name` returns `bob`\n\nline six outpus `bob` and returns `bob`\n\none line 7 the method `puts` is called and the local variable `name` is passed to it.  `name` is still refercning `jim` on affected by the reassignment within th method. so `jim` is output and then puts returns `nil`\n\n\n```ruby\ndef add_name(arr, name)\n  arr = arr + [name]\nend\n\nnames = ['bob', 'kim']\np add_name(names, 'jim')\nputs names.inspect \n```\n\none line 1-3 the method `add_name` is defined which takes two parameters `arr` and `name` \n\non line 5 the local variables `names` is initialized and the array object with value `['bob', 'kim']` is assigned to it. \n\non lin 6 the method `add_name` is called and the local variable `names` is passed to it as the first parameter, the string `jim` is passed to it as the second parameter. the return value of this method call is then assigned to the method `p`.  calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs this string, and returns the string object  WHAT IS PUTS ACTUALLY OUTPUTTING AND RETURNING \n\non line 1 the `arr` variable local to the method `add_name` is set to put to eh array object `['bob', 'kim']` which is also being refrenced by the local variable `names`.  Also the variable `name` local to the method add_name is set to point to the string `jim`.\n\non line 2 the variable `arr` is added to the single element array [`jim`]. With a result of ['bob', 'kim', 'jim'], this is also the value returned by the method because it is the last line of the method.  this value is then reasigned to variable `arr`.  This reassignment breaks the reference to the varibale that names is pointing to, leaving the array object outside method unaffected. \n\nline 6 outputs ['bob', 'kim', 'jim'], and returns the same.\n\none line 7 the inspect method is called on the object that the variable `names` is refencing. returns a string containing a human-readable represenation of the object it is called on.  This return value is then passed to the `puts` method call which outputs ['bob', 'kim'] and returns `nil` \n\n```ruby\ndef add_name(arr, name)\n  arr = arr << name\nend\n\nnames = ['bob', 'kim']\np add_name(names, 'jim')\nputs names.inspect\n```\n\none line 1-3 the method `add_name` is defined which takes two parameters `arr` and `name` \n\non line 5 the local variables `names` is initialized and the array object with value `['bob', 'kim']` is assigned to it. \n\non lin 6 the method `add_name` is called and the local variable `names` is passed to it as the first parameter, the string `jim` is passed to it as the second parameter. the return value of this method call is then assigned to the method `p`.  calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs this string, and returns the string object  WHAT IS PUTS ACTUALLY OUTPUTTING AND RETURNING \n\non line 1 the `arr` variable local to the method `add_name` is set to put to eh array object `['bob', 'kim']` which is also being refrenced by the local variable `names`.  Also the variable `name` local to the method add_name is set to point to the string `jim`.\n\non line 2 the variable the shovel method `<<` is called on the `arr` variable with the variable name passed to it as an argument. This method is mutating and appends `jim` to the array `['bob', 'kim']`, returning the same array object `['bob', 'kim', 'jim']`.  This value is then reassigned to point to the `arr` variable.  The array object remains the same so the reassignment does not break the reference to the variable `names`\n\nline 6 outputs ['bob', 'kim', 'jim'], and returns the same.\n\none line 7 the inspect method is called on the object that the variable `names` is refencing. returns a string containing a human-readable represenation of the object it is called on.  This return value is then passed to the `puts` method call which outputs ['bob', 'kim','jim'] and returns `nil`.  It was mutated from within the method.\n\n```ruby\ndef increment(a)\n  a = a + 1\nend\n\nb = 3\np increment(b)\np b\n```\non line 1-3 the method `increment` is defined with one parameter `a`\n\non line 5 the local variable `b` is initalized in the integer object with value `3` is assigned to it.  \n\non line 6 the method `increment` is called with the variable `b` passed to it as an argument. the method `p` is then called with this return value passed to it as an argument. `p` calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs this string, and returns the string object \n\non line 1 the variable `a` local to the method `increment` is set equal to the same integer object that `b` is refrencing `3`.\n\non line 2 the value of variable `a` is added to `1`.  the result is the reassigned the the variable `a`.  this reassignment breaks the reference the integer object `b` which is referenced outside of the method. the method returns `4`\n\non line 6 `4` is output and `4` is returned\n\non line 7 the method p is called and the variable `b` is passed to it as an argument.  `b` was unmodified by the method so the orginal integer object value `3` is output and `3` is retiurned. \n\n\n```ruby\ndef append(s)\n  s << '*'\nend\n\nt = 'abc'\nputs append(t)    \nputs t \n```\non line 1-3 the method `append` is defined with one parameter `s`.\n\none line 5 the local variable `t` is initialized and the string object with value `abc` is assigned to it. \non line 6 the method `append` is called with the local variable `t` passed to it as an argument.\nthe return value of this method call is then passed to the method call `puts` as an argument.  \n\non line 1 the variable `s` local to the method `append` is assigned to point to the same string object that `t` is referencing. now `s` and `t` are referencing the same string object `abc`.  on line 2 the shovel method `<<` is called on the value of variable `s`, with the string ohject `*` passed to it as an argument.  The shovel method is mutating, so both the variable `t` outside the method and the `s` variable are now referencing `abc*`.  This is also the return value of the method call.\n\non line 6 `abc*` is output and `nil` is returned\n\non line 7 `abc*` is output and `nil` is returned the variable was mutated within the method. \n\n```ruby\ndef fix(value)\n  value.upcase!\n  value.concat('!')\n  value\nend\n\ns = 'hello'\nt = fix(s)\n\nputs s           \nputs t\n```\n\non line 1-4 the method `fix` is defined which takes one parameter `value`.\n\non line 6 the local variable `s` is initialized and the string object `hello` is assigned to it. \n\non line 8 the method `fix` is called and the local variable `s` is passed to it as an argument. the return value of this is then assigned to the local variable `t`.\n\non line one the variable `value` local to the method `fix` is set to reference the same value thich the variable `s` is referecing `hello`.  \n\non line two the mutating method `upcase!` is calle don the object being referencing by `value ` and `s`.  now both `s` and `value` are pointing to the string `HELLO`. \n\non line 3 the mutating method `concat` is called on the value which `value` and `s` are referencing, with the string `!` passed to it as a parameter.  `value` and `s` are now referncing the string object `HELLO!`.\n\non line 7 `HELLO!` is returned which is also the return value fo the method `fix`\n\non line 10 the `puts` method is called with `s` passed to it as an argument. `s` was mutated in the method and now is `HELLO!`, `nil` is returned\n\nline 11 does the same as line ten but passes in `t`, `t` and `s` are pointing to the same object `HELLO!` so that is output, `nil` is returned.\n\n\n```ruby\ndef fix(value)\n  value = value.upcase\n  value.concat('!')\nend\n\ns = 'hello'\nt = fix(s)\n\n\nputs s          \nputs t \n```\n\non line 1-4 the method `fix` is defined which takes one parameter `value`.\n\non line 6 the local variable `s` is initialized and the string object `hello` is assigned to it. \n\non line 8 the method `fix` is called and the local variable `s` is passed to it as an argument. the return value of this is then assigned to the local variable `t`.\n\non line one the variable `value` local to the method `fix` is set to reference the same value thich the variable `s` is referecing `hello`.  \n\non line two the non mutating method `upcase` is called on the object being referencing by `value ` and `s`. upcase returns a new object `HELLO`, this object is then reassigned to the `value` variable which breaks the reference the the object that `s` is referecning outsdie the method. \n\non line 3 the mutating method `concat` is called on the value which `value` is referencing, with the string `!` passed to it as a parameter.  `value` and are now referncing the string object `HELLO!`. \n\non line 7 `HELLO!` is returned which is also the return value of the method `fix`\n\non line 10 the `puts` method is called with `s` passed to it as an argument. `s` was not mutated in the method and still pionts to `hello`, which output, `nil` is returned\n\nline 11 does the same as line ten but passes in `t`, `t` is now pointing to `HELLO!`\n\n\n\n```ruby\ns = 'Hello'\nputs s.object_id\ns += ' World'\nputs s          \nputs s.object_id \n```\non `line 1` the local variable `s` is initialized and the string object with value `Hello` is assigned to it\n\non line 2 the method `object_id` is called which returns the numerical object id of the object that `s` is referencing.  The the return value of this is then passed to the method `puts` which displays the object id and returns `nil`\n\none line three the method `+=` is called on the value that `s` is pointing to, the string object with value ` World` is passed to it as a parameter.  `+=` is shorthand for `s = s + 'World'`.  Which is just reassignmnent reassignment returns a new array object, it is non-mutating.  so now the local variable `s` is pointing to a new string object with value `Hello World`,  `nil` is returned \n\non line 5 the method `puts` is called and the value of `s` is passed to it as an argument.  `Hello World` is output, `nil` is returned \n\nonce again the same thing happens on line 5 is line 2, however a different object id will be output because the object s is referencing was changed with reassignent on line 3.  `nil` is returned. \n\n```ruby\ndef fix(value)\n  value[1] = 'x'\n  value\nend\n\ns = 'abc'\nt = fix(s)\n\np s            \np t  \n```\non line 1-4 the method `fix` is defined which takes one parameter `value`.\n\non line 6 the local variable `s` is initialized and the string object `abc` is assigned to it. \n\non line 8 the method `fix` is called and the local variable `s` is passed to it as an argument. the return value of this is then assigned to the local variable `t`.\n\non line one the variable `value` local to the method `fix` is set to reference the same value thich the variable `s` is referecing `abc`.  \n\none line 2 the value of the `1` index of the string objec that `s` and value are refencing is ressigned to point the the string object `x`.  index reassignment is mutating with regards to the greater string.  \n\non line 3 the string object that `value` and `s` are pointing to are returned, `axc`. which is also the return value of the method because it is the last line of the method run. \n\non line 9 the method `p` is called and the local variable `s` is passed to it as an argument. `p` calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs this string, and returns the string object.  `axc` is output because the string was mutated within the method and the same is returned\n\nline 10 does the same as line 9 but passes in `t`, `t` is now pointing to `axc`, `axc` is output `axc` is returned. \n\n\n\n\n```ruby\ndef tricky_method(a_string_param, an_array_param)\n  a_string_param += \"rutabaga\"\n  an_array_param << \"rutabaga\"\nend\n\nmy_string = \"pumpkins\"\nmy_array = [\"pumpkins\"]\ntricky_method(my_string, my_array)\n\nputs \"My string looks like this now: #{my_string}\"\nputs \"My array looks like this now: #{my_array}\"\n```\n\non `line 1-4` the method `tricky_method` is definited with two parameters `a_string_param` and `an_array_param`.\n\none line 6 the local variable `my_string` is initialized and the string object with value `pumpkins` is assigned to it.\n\none line 7 the local variable `my_array` is initalized and the array object with value `[\"pumpkins]`\n\non line 8 the method `tricky_method` is called with the variably `my_string` passed to it as the first argument, and the variable `my_array` passed to it as the second argument. \n\non line 1 the variable local `a_string_param` to the method `tricky_method` is set to point to the same string object that `my_string` is refencing, `pumpkins`.\n\non line 1 the variable local `an_array_param` to the method `tricky_method` is set to point to the same array object that `my_array` is refencing, `[\"pumpkins\"]`.\n\non line 2 the method `+` is called on the value being referencing by `a_string_param` and the string `rutabaga` is passed in as an argument. The return value 'pumpkinsrutabaga' is the returned, this return value is then reassigned to the variable `a_string_param`, reasignment is non-mutating so the reference the the string object whith the variable `my_string` is pointing too is now broken.\n\none line 3 the shovel method is called on the array objec which is being referencing by the both, an_array_param and my_array, `[\"pumkins\"]`. the string object with value `rutabaga` is passed into the method as an arugument.  The shovel method is mutating and rturns, `[\"pumkins\", \"rutabaga\"]`  this is also the return value of the method becasue it is the last line run\n\non line 10  to `puts` is called and the string \"\"My string looks like this now: #{my_string}\" is passed in as an argumnet. this string uses interoplation which allows an imbedded ruby expression to be interpretted and returned within the string. in this case #{my_string} returns \"pumkins\".  puts then outputs this line and returns `nil`\n\non line 11 does the same but with #{my_array} insteadh which reatursn [\"pumpkins\", \"rutabaga\"] and then puts this into the string, outputs the string and returns nil\n\n\n\n```ruby\ngreetings = { a: 'hi' }\ninformal_greeting = greetings[:a]\ninformal_greeting << ' there'\n\nputs informal_greeting  \nputs greetings\n```\n\n```ruby\ngreetings = { a: 'hi' }\ninformal_greeting = {}\n\ngreetings.each { |key, value| informal_greeting[key] = value }\ninformal_greeting[:a] += ' there'\n\nputs informal_greeting\nputs greetings\n```\n\n```ruby\na = 7\narray = [1, 2, 3]\n\narray.each do |element|\n  a = element\nend\n\nputs a \n```\n\n```ruby\nfor i in (0..5) do \n  a = i\nend \n\nputs a\n```\n\n```ruby\ndef count_sheep\n  5.times do |sheep|\n    puts sheep\n    if sheep >= 2\n      return\n    end\n  end\nend\n\np count_sheep\n```\n\n```ruby\nreturn_value =  [1, 2, 3].select do |num|\n                  num + 1\n                end\np return_value\n```\n\n```ruby\nreturn_value =  [1, 2, 3].map do |num|\n                  num.odd?\n                end\np return_value\n\n```\n\n```ruby\nreturn_value =  [1, 2, 3].each_with_object([]) do |num, array|\n                  array << num if num.odd?\n                  puts array.inspect\n                end\np return_value\n```\n\n```ruby\ndef real_palindrome?(string)\n  string.downcase.delete!('^A-Za-z')\n  string\nend\n\np real_palindrome?(\"Madam, I'm Adam\")\n\n```\n\non `line 1-3` the method `real_palindrome?` is defined that takes 1 parameter `string`.\n\non `line 6` the method `real_palindrome?` is called with the local String object `Madam, I'm Adam` passed to it as an argument. The return value of this method call is then passed to the method `p`. `p`calls the method `inspect`, which returns a string object containing a human-readable representation of the object, this string is then displayed.\n\nOn `line 1` the variable ,`string`, local to the method defintion test is set to point to the same String `Madam, I'm Adam`.\n\non `line 2` the the method `downcase` which serveres the ability to mutate the original string, and returns a new object with all downcase version of the string.then the method `delete!` with a regex passed to it as an argument, mutates the copy of the string eliminateing anthing that is not in the alphabet. \n\nthe last line of the method the returns the value of the `string` variable.\n\nthe return value of the method is \"Madam, I'm Adam\".  line 6 ouputs this return value.  The string was not changed by line 2 because the mutating methods were acting on a copy. \n\n\n```ruby\ndef test(b)\n  b.map { |letter| \"I like the letter: #{letter}\" }\nend\n\na = ['a', 'b', 'c']\np test(a)\np a\n\n```\n on `line 1-3` the method `test` is defined that takes one parameter `b`.\n \n On `line 5` the local variable `test` is initialized and the array object with value `['a', 'b', 'c']` is assigned to it. \n \n on `line 6` the `test` method is called with the local variable `a` passed to it as an argument.  The return value of this method call is then passed to the method  `p`.  `p` calls the method `inspect` on the object it is called on displaying a string containing a human-readable representation of the obj.\n \n  On `line 1` the variable ,`b`, local to the method defintion `test` is set to point to the same array object which is being referenced by the local variable `a`, with value `['a', 'b', 'c']`.\n  \n  on `line two` the non mutating method `map` is called on the value of variable `b` (and `a`). a `{..}` block is passed to the method as an argument with one parameter `letter`.  map iterates through the array and moves the output of the block into a new array, finally returning that array. in this case the output is `[\"I like the letter:'a'\",\"I like the letter: 'b'\", \"I like the letter: 'c'\"]`.\n \n `line 6` outputs the return value of the method `[\"I like the letter:'a'\",\"I like the letter: 'b'\", \"I like the letter: 'c'\"]` \n \non `line 7` the variable a is passed to `p` method as an argument. `p` calls the `inspect` method on the object it is called on, which returns a string containing a human-readable representation of the object. The `p` method then outputs this string. In this case p outputs `['a', 'b', 'c']` because map is non mutating. \n\n\n"
    }
  ]
}