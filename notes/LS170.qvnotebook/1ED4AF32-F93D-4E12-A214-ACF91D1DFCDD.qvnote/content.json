{
  "title": "The Internet",
  "cells": [
    {
      "type": "markdown",
      "data": "AWS Cloud9 \n\nAs already mentiond, this course is somewhat emore theory-based than other courses in the curriculum. There are, though, still certain parts of the course where we explore various networking concepts in a practical way, using some bash scripting as well as certain network tools and the `netcat` command might require certain flags to be passed to it in one version of OSX, and slightly different flags in another version, or when using Linux or Windows operating systems.\n\nDue to these inconsistencies, we strongly advice you to use AWS Cloud9 when working through the practical parts of this course which require the use of these tools and utilities (with the exception of the HTTP GUI tools mentioned in the Introduction to HTTP book, since these need to be installed locally). If you do choose to use your own envicormnet when working through this coursethe code and utlitlies might still work as shown in the assignment,s but there's also a fairly good chance that you'll concounter porblems. Issues that occur as a result of variances in enviromental set-up are extremely difficult to diagnorse remotely, so unfortunately we won't be able to help you with these.\n\n### What is the internet\n\nThe word `internet` is one that many people use everyday without giving much thought to what it actually is.\n\nThe internet is a 'netwokr of networks'.\n\n#### what is a net work\n\nat the most basic levle, it's two devices connected in such a way that they can communicate or exchange data. A primitive implementation of this would be connecting two computers directly to each other using a LAN cable, and configuring their network settings in such a way that they form a distinct ntweork.\n\n#### Local Area Network (LAN)\n\nA much more common scenario would be mulitple computers and other devices connected via a network briding device such as a hub or more likely a switch.\n\nThe computers all alll connected to this device via network cables and this forms the ntweork.\n\nyour home network follows the same principles, but the central device will likely be a wireless hub or switch so that the devices can connect wirelessly rather than being plugged via a cable. This implementaiton is know as WLAN of Wireless LAN.\n\nThe key thing to understand here is the scope of communications is limited to dveices that are connected (either wired or wirelesly) to the netweork swithc or hub, which imposes some geographic limitations. That's the `local` in Local Area Network. As we know thoug, we're able to commujicate across much larger distances with devices that aren't connected irectly to our network. How does that happen?\n\n#### Inter-network communicaiton\n\nin order to enable communicaiton between networks we need to add retours into the picture. Routers are network devices that can route network traffic to other ntworks. Wihtin a Local Area Network, they effecitcly act as gateways into and out of the network.\n\n#### A Network of Netowrks\n\nWe can imagine the internet as a vast number of these ntworks connected together. In between all of the sub-networks are systems of routers that direct the ntwork traffaic.\n\nThe actual network topology of the overall network is a bit more complex than that, but in terms of having a mental model on which to build more abstract networking concetps it should suffice.\n\n### Protocols\n\nIf we zoommed into the vast network of networks that is the internet, we'd see that is made up of a huge array of disparate components. There are countless different types of device that can connect to the internet, from laptops, tablets, adn phones to kettles, toasters and lightbubls. All of thees devices connect via thousands of different makes and models of hubs, swithces, and routers, to endless different configurations of servcers. Added to this, these componenents will be running a massive variety of software.\n\nHow do we ensure that a MS Edge browswer running on Windows 10 or an Asus laptop connected to a Netgear router requesting a resource from an Apache webserver running on Dell hardware, works in the same way as Safari web browser running on a Mac connected to a Samsung router requesting a reouce form a NGinX webserver running on HP hardwar/\n\nThe answer to this quetiosn is by using *protocols*. In simple terms we can think of a protocol as a system of rules. In terms of computer networks we can be a bit more speific:\n\n**a set of rules governing the exchange or transmission of data**\n\nThere are numerous different protocols that are used to communicate over the internet. A short lis of some of thw more widely used protocls might include the following:\n\n* IP\n* SMTP\n* TCP\n* HTTP\n* Ethernet\n* FTP\n* DNS\n* UDP\n* TLS\n\nYou may already be familair with a few of these protocols. If not don't worrry, we'll be exploring osme of them in more depth during the rest of this course.\n\nThis list is only a smalle seleciton of the total number of networking protocls, but contains those that you are most likely to encounter. You might be worndering why there are so many differen tprotocls for network communicaiton. There are a number of different reasons for this, two fo the main ones are:\n\n* different protocls wre dedvelooped to address different saspects of network commu\u0010ncation\n* different protocols wre developed to address the same aspect of network communcaiton, but in a dfifferent way, or for a specific use-case.\n\nLet's look at both of these sistuations using the example of human speech.\n\n### Protocols for different aspects of communicaiton\n\nWhen we speak to someones else, we can perhaps think of a particular group of words as one message wihtin an overall conversation. to ensure that a partuclar message is understood we need to worder thw words within the message in a certain order. we can think of this word oredser as part the the **syntactical rules** that govern the **structure** of the message\n\n### Different protocols for the same aspect of communicaiton\n\nyou can probably think of various situations where different sets of message transfere rules are or aren't appropriate\n\n* in a classroom situation if a student wants to ask the terahc a qeustion we migth have a fairly strict rules for initiating and conducting the transfer of messages.\n* a different situation with less strictly defined rules mgiht be a social conversation between friends. Alll the partiicpants are peers with no hierarchy. Anyone can initiate a message excahgne and anyone can respond.\n* yet another situation muight be someone giving a presneation at a conference. The speaker might start stpeaking at a specific set time, and should no\u0010rmally be allowed to deliver the presneation without interruption while the audiencfe listens.\n\nall of these sitautaion are concenred with the same aspect of communicaiton, the flow and order of the message transfer, but use different sets of rules, or **protocols**.\n\nWe can think of network communcaiton protocls in the same way. TCP and UDP would be exampoles of two protocls that address different aspects of communicaiton; The the transfer of messages betweeen applications, and HTTP the structure of those msessages. TCP and HTTP would be examples of two protocls that address different aspects of communication; TCP there transfer of messsages between applicaitons, and HTTP the structure of those messges.\n\nIn the next assignment we'll look at how protocols dealing with different aspects of network communicaiotn work togterh to create and overall network commu\u0010nicaiotn system.\n\n### A Layered System\n\nin the previous assignment, we looked a how different sets of rules, or protocols address different aspects of communication. It can be usefule to group these protocols together in tems of the particular aspect of communication that they can address. Furthermore, we can think of these protocol groups as function within **layers** of an overall system of communication.\n\nIf we were to do that with our previous example of verbal human communication, with a couple of protocol group layers added, it might look something like this:\n\n    Protocol Group Purpose     Logical Message Structure Linguistics rules for how to structure a message, e.g. word order   Logical Message Transfer Etiquette rules ofr transfer of individual messages from one person to another, e.g. initiating conversations or turn to speak   physical message creation/Interpretation The physics and bilogy of speech and hearing, e.g contorl of vocal chords and function of the ear   Physical Message Transfer Transfer of the message across the phsyical medium e.g. sound waves carried through air    \n\nThe overall system outlined above is highly complex. Trying to understand every aspect of it as a single end-to-end process would be extremely difficult. By modularizing it and structuring it into a layered system, we can zoom in on a particular layer to more clearly understand what is happening at that level of the system.\n\nThe same idea can be applied to computer network communicaiton, and there are numerous different models which attempt to do this. Two fo the most popular are the OSI model and the Internet Protocol Suite (also know ast the TCP/IP model or the DoD model). There is some rough equivalency, albeit with some overlap, between the layers of the two models.\n\n- the tope layer of the internet protocol suite (application) mostely maps to the top three layers of the OSI Model (Application, Presenation, Session).\n- The seond layer of the Internet Protocol Suite (Transport) mostely maps to the fourth layer of the OSI model (Transport)\n- The third layer of the Internet Protocol Suite (Internet) mostly maps to the fifth layer of the OSI model (Network)\n- The fourth layer of the Internet Protocol Suite (Link) mostly maps to the bottomm two layers of the OSI model (Data Link and PHysical)\n\n![Screen Shot 2020-08-23 at 5.39.59 PM.png](quiver-image-url/7D117113CBC0D4BDD2268EF44824220F.png =731x554)\n\nthe reason for the different number of layers between the two models is due to the difference inapporach each model takes. The internet Protocol Suite divies the layers in terms of the scope of communications within each layer (within a local network, between networks, etc). The OSI model divides the layers in terms of the functions thate each layer provides (physical addressing, logical addressing and routing, encryption, compression, etc). The OSI model divides the layers in terms of functions that each layer provides (phsycial addressing, logical addressing and routing, encryption, and comkpression etc).\n\nAlthough there is utiltiy in both of these approaches, no single model will perfecty fit a real-world implementation. Such models are useful for gaining a borad-brush view of how a system works as a whole, and for modularizing different levels of responsibily within that system. However, attempting to stictly adhere to the model when drilling into the detail of how a speific protocl works can be counter-productive. More important is developing a clear idea of how a particular protocl works and how to use it at the implementaiotn levle.\n\nDuring this course, we'll use a commbiatnion of both these models. We'll take useful ideas freom each to build up a high-leel picutre of how the internet works. We'll also take a more detail looka the the specifics of certain important protocols.\n\n#### Data encapsulation\n\none concept used by both modesl ,a nd in fact by most network communication models is the idea of data encapsulation. You will already have encounteredthe term **encapsulation** in the context of programming, where it means hiding theinternal representatation of and object and preventing it from being accessed from outside the object.\n\nThe idea is similar in network models. Here we are essentially hiding data frome one layer by encapsulating it within a data unuit of the layer below. That might be a slightly diffeiicult concept to graps at first, so lets break it down.\n\n#### protocol Data units\n\nwihtin our network models, a Protocol Data Unit (PDU) is an amount or block of data transferred over a network. Different protocols or protocol layers refere to PDUs by different names. At the Link?Data Link layer for example a PDU is know as a frame. At the Internet/Netwrok layer it is known as a **packet**. At the Transport layer, it is known as a **segment** (TCP) or a datatgram (UDP).\n\nIn all cases, the basic concept is effectively the same; the PDU consists of a hdear, a data paylod and in some cases a trailer or footer.\n\n![Screen Shot 2020-08-23 at 5.47.47 PM.png](quiver-image-url/13423EF8B6A4B7D50DC71457875D9147.png =567x144)\n\n#### Header and Trailer\n\nThe exact structure of the header and, if included, trailer varies from protoocl to protocol, but the purpose of them is the same in each case: to provide protocol-specific metadata about the PDU. For example, an Internet Protocl (IP) packet header would include fields for the Source IP address and the Destititnation IP Addresss, which woul dbe used to corretly route the packet.\n\n#### Data Payload\n\nthe data payload portion of a PDU is simply the data that we want to transport over the network using a specific protocol at a particular network layer.\n\nThe data payload is the key to the way encapsulation is implemented. The entire PDU from a protocol at one layer is set as the data payload for a protocl at the layer belwo. For example, a HTTP Request at the Application layer could be set as the payload for a TCP segment at the transport layer.\n\n![Screen Shot 2020-08-23 at 5.49.09 PM.png](quiver-image-url/19534C8B49C386B02CE246B318A2BCB8.png =882x461)\n\n\nthe major beneifit of this approach is the separation it creates between the protocols at different layers.  This means that a protocol at one layer doens't need to know anything about how a protocol at another layer is implemented in order fot hose protocols to interact.  It creates as tsytem wehereby a lower layer effectively provides a 'servvice' to the layer above it.  in other works, a TCP segment isn't really concerned whether its data payload is an HTTP request, an SMTP command, or some other sort of Application layer data.  It just knows it needs ton encapsulate **some data** form the layer above and provie the result of this encapsuslation to the layer below.\n\nThis speration of layers provides a certain level of abstraction, which allows us to use different protocols at a certain lay3er without have to worry about the layers below.  This is especially apparent at the applicaiton layer, where many different protocls are used depending on the applicaiton and use case.  For example, an email client would use SMTP, and web broswer HTTP, and a file transfer program FTP, but all three of these programs could use TCP at the Transprot layer to transfer the applicaiton layer data. \n\n## THe physical Network\n\nIn the previous two assignemnts we've looked at several concepts:\n\n- protocols act as systems of rules for network communicaiton.\n- Groups of protocols work in a layered system.  Protocols at one layer provide services to the layer above\n- Data is encapsulated into a Protocol Data Unit, creating sepeartaion between protocols operating at different layers.\n\nThese are important networking conceptes which we'll continue to explore during the rest of this course.  Essentially, these ideas are logical abstractions that help us understand hwo network communicaiton works at a conceptual level.  If we drill down through these layers of abstractions, underlying everything at the most basic level is a 'physical' network made of tangible pieces such as networked device, cables, and wires.  Even the radio waves used in wirless networks, though we can't touch or see them, exist in the phsical realm and are bound by physical laws and rules. \n\nThese laws and rule sdetermine how data acutally gets transported from one place to another in a physical sense.  what happens at thislevel involves real-world limitations and boundaries, such as how fast an electrical signal or light can travel or the distance a radio wave can reach.  These limitaitons determine the physical characterstics of a network, and these characteristics have an impact on how protocols function further up a the conceptual level. If we want to work with these protocols, it is therefore important to have at least a basic understanding of how a network works at this leve. \n\n\n##### Bits and Signals\n\nThe OSI model defines a Physical layer as the bottommost layer of its model (Layer 1).  The internet Protocol Suite doesn't really concern itself directly with physical interfaces, though it does include some physical functions in the Link layer.  Either way, the functionality at this level is essentially concenrned with the transfer of bits (binary data).  In order to be transported, these bits are concverted into signals.  Depending on the transportation medium used, bits are converted to electircal signals, light signals, or radio waves. \n\n##### Characterisitics of a Physical Network\n\nthe two main characterisitics in terms of the performance of a physical network are Latency and Bandwidth.  In simple terms, latency is a measure of the **time** it takes for some data to get from one point in a network to another point in a network.  Bandwidth is the **amount** of data that can be sent in a particular unit of time (typically a second). \n\nImagine a single lane road with a car traveling along it from one town to anohter.  The distance between the towns is 10 miles, and the max speed that hte car can travel along the road is 50 mph.  It would take the car 12 minutes to travel form town A to town B. We can therefore say the road has a latency of 12 minutes.\n\nIf we added more lanes to the road, more cras can travel alont it at once. This incresa the bandwidtih of the road.  Alll the caras traval at 50 miles per hour.  so it sill takes each car 12 minutes fo travel form town A to town B.  The latency of the road is is still 12 minutes. Just increaisn the bandwidth doens' tnecessarily imporive the peformance of a network. We'll expolore the reaons for this when we look at TCP and UDP in a later lesson. \n\n### The elements of latency \n\n\nwe can think of latency as a measure of delay.  Data starts at one locaiton at a certain point in time.  At a later point in time, it reaches another locaiton.  the diffreence betwen those two points in time is the delay.  The earlier analogy wiht a car driving along a road was a very simplied verison of what constitues latency.  Terhe are actually different types of delay that go together to determine the overal latency of a network conneciton. \n\n-*Propgagation delay*:  This is the amount of time it takes for a meassage to travel from the sender to the receiver, and can be calculated as the ratio between distance and speed. Propagation delay is basiclaly what was explained by our car analogy earlier.\n\n-*Transmission Delay*:  The journey of data from piont A to point B on a network typically won't be made over one signle cable.  Istead, the data will travel across many different wires and cables that are all interconnected by swithiches, routers, and other nework devices.  Each of these elements within the network can be htought of as an individual 'link' within the overall system.  Tranmssion delay is the amount of time it takes to push the data onto the link.  In terms of our driving analogy, you can think og it as the time taken to navigate and interseciton or interchange between different roads.  we'll explore this idea furthere with the `traceroute` program later in this assignment. \n\n- **Processing delay**:  Data travelling across the physical network doesn't direclty cross from one linke to another, but is processed in vairous ways. we'll look at what this processing entails in more detail in a later assignment.  This is probably strecching our driving analogy somwehat, but imagine if ate very interchange there was some sort of checkpointl the amount of time it taks t be processed at the checkpiont is the processing delay. \n- *Queuing delay:* Network devies such as routers can only process a certain amount of data at one time.  IF theres is more data than the device can handle, then it queues or buffers the data.  THe amount of time the data is waiting in the queue to be processed is the queuing delay.  In our driving analogy, this would be the time spent in a queue or traffice waiting to cross the check point. \n\nThe total latency between two points, such as a client and a server, is the sum of all the dlays above.  This value is usually given in milliseconds (ms)\n\nThere are some other terms that you may encounter in a dicssion about latency:\n\n- *Last-mile altency:*  A lot of the dlays described above can take place within the parts of the network which are closest to th een dpoints.  This is often referred to as 'last-mile latency'  and relates to the dlays involved in getting th enetwork signal from you ISP's network to your home or office network.   The 'hops' within the core part of the network are longer with less interruptions for transmission, procssing, and queuing.  at the network edge, there are more frequent and shorter hops as the data is directed down the network hierarchy to the appropriate sub-network. You can think of hte network edge as the 'entry point into a network like a home or corporate LAN>\n- *Round-trip time (RTT):*  A latency calculation often used in networking is Round-trip Time (RTT).  This is the lenght of time for a signal to be sent, aded to the length of time for an acknowledgment or response to be received. \n\n\n#####Network Hops\n\nThe journy of a piece of data on the network isn't direct form the start point to the end point but will consist of several 'hops' or journeys, between nodes on the network.  You can think of the nodes as routers that process the data and forward it to the next node on the path.\n\nTo see this process in action, open yp your console and run the following command:\n\n```ruby\ntraceroute google.com\n```\n\n`traceroute` is a utility for displaying the route and latency of a path across a network. Runnning hte command should return a list of hops taken for the test data to get form your PC or laptio to the Google server.  The values indicated here are the Round-Trip Time (RTT) for each hop.\n\n##### bandwidth\n\nband width varies acreoss the network, and isn't going to be a constant level between the start point and the end point of our data's journey.  for example, the capacity of the core network is going to be much higher than the part of the network infrastructure that ultimately connects to your home or office building. \n\nThe bandwidth that a connection reveives is the lowest amount at a particular point in the overall connection.  A point at which bandwithd changes from relatively high to relatively low is generally referred to as a bandwidth bottleneck.\n\nLow bandwidth can be an issue when dealing with large amounts of data.  As we'll see later in the cours, however, in many istuation, latency can be a much more serious limitation on the perfromance of a networked applicaiton. \n\n####Limitations of the Physical Networks\n\nAs developers and software engineer,s there's really not a lot ewe can do about the limitations of th ephysical network itself.  IF we want to improve th eperformance of the applicaitons we build, then our influence is limited to the implmenation of the applicaiton in terms of how we use the higher-level protocols.  As we'll see later in the course, however, and understaning of these physical limiations can impact the way we think about those higher-level protocols, and therefore the decision,s we can make about how we use them within our applciations. \n\n\n\n### The Link/ Data Link Layer \n\nIn the last assignment, we looked at the idea of a network at the physical level being lots of devices connected by cables, transmitting binary data in the form of electrical signals, light, or radio waves.  Simply having these devices being physically connected to each other isn't sufficinet for them to communicate.  THey don't know how to communicate as they haven't established any rules for communicaitons.\n\nOne of the most import rules for transferring data from one place to anohter is identifying the device to which we want to send the data.  The protocls operatin at this layer are primarly concerned with the identificaion of devices on the physical network and moving datat ove rht ephysical network between the devices that comprise it, such as hosts (e.g. computers) swithces and routers. \n\nWithin the OSI model, the Data link layer is Layer 2, and comes in between the Physical layer (1) and Network layer (3).  Within the internet Protocol suite, the Link layer is laeyer 1, since this model doesn't define a specific layer for the physical network.  Within both of these models though, we can think of what happens at this layer as an interface between the workings of the physicla networks and the more logical layers above.\n\nThe most commonly used protocol at this layer is the Ethernet protocol.  You may have heard of Ethernet cables.  These are network cables used to connect devices on the network such as computers, switches and routers.  The technical specificaiton of these cables is governed by the same IEEE standards that include the Ethernet communcation protocls that operate at this layer of the network.\n\nTwo of th emost important sapects of Ethernet are *framing* and *addressing*\n\n#####Ethernet Frames \n\nEtherenet Frames are a Protocol Data Unit, and encapsulate data from the Internet/Network layer above.  The Link/Data Link layer is the lowest layer at which encapsulation takes place. At the physical layer, the data is essentially a stream of bits in one form or another without and logical structure.  An Ethernet Frame adds logical strucutre to this binary data. The data in the frame is still in the form of bits, but the struture defines which bits are actually the data payload, and which are metadata to be used in the process of transporting the frame.\n\nAn Ethernet-compliant network device is able to identify the different parts of a frame due to the fact that the different 'fields' of data have specific lengths in bytes and appear in a set order. \n![Screen Shot 2020-08-23 at 9.41.37 PM.png](quiver-image-url/4934D6750706AD97FDB92311496B6B25.png =860x162)\n\n- *preamble and SFD*:  The Preamble and start of Frame Delimieter (SFD/SOF) generally aren't considered part of the actual grame but are set just prior to the frame as a synchronization measure which notifies the receiving device to expect grame data and then identify the start point of that data.  The preamble is seven bytes (56 bits) long and the SFD is one byte (eigh bits).  Both use a repeated pattern that can be recognised by th ereceiving device, which then knows that the data following after is the frame data.\n\n- *source and destination mac address:* The next two fields, each six bytest (48 bits) long are the source and desitination MAC addresses.  The source address is the address of the device which created the frame (as we'll see later on in this assignment, this can change at various points along th edata's journey).  The destination MAC address is the address of the device for which the data is ultimately intended.  MAC Addresses are a key part of the Ethernet protocol; we'll look at them in more detail shortly. \n- *Length*  The next field is two bytes (16 bits) in length.  It is used to indicate the size of the Data Payload.\n\n- *DSAP*, *SSAP*, *Control*:  The next three fields are all one byte (8 bits) in length.  The DSAP and SSAP fields identify the Network Protocol used for the Data Payload.  The control field provides inforamtion about the speicific communcation mode for the frame, which helps faciliate flow control. \n- *Data Payload*:  The data payload field can be between 42 and 1497 bytes in length.  It contains the data for the entire Protocol Data Unit (PDU) form the layer above, and IP Packet for example. \n- *Frame Check Sequence (FCS)*:  The final four bytes (32 bits) of an Ethernet Frame is the Frame Check Sequence.  This is a checksum generated by the device which creates the frame.  It is calculated from the frame data using an algorithm such as a cyclic redundancy check.  The receiving device uses the same algorithm to generate a FCS and then compares this to the FCS in the sent frame.  IF the two don't match, then the frame is dropped.  Ethernet doesn't implement any kind of retransmission funcitonality for dropped frames;  it is the responsiboity of higher level protocls to manage retransmisison of lost data if this is a requiremnt of the of the protocol. \n\n\nYou don't need to memorize all of these fields.  we list them here mainly to buil a picture of an Ethernet Frame as **structured data**.  The key componenets to remember are the Source and Destination MAC address and the Data payload. \n\n#####Interframe Gap\n\nAs weel ass using the Preamble and SFD to prepare a receiving device to process the frame data.  Ethernet aslo specifies an **interframe gap (IFG)**.  This gap is a brief pause between the transmisison of each frame, which permits the receiver to prepare to receive the next frame.  The lenght of this gap varies according to the capability of the Ethernet connection.  For example, for 100 Mbps ethernet the gap is 0.96 microseconds (or just under one millionth of a second).\n\nThis interframe gap contributes to the Tranmisison Delay element of latency we looked at in the previous assignemnt/\n\n### Differences Between Ethernet Standards\n\nNote that the fields listed above, and shown in the accompanying graphic, descibe the structure of a frame under the IEEE 802.3 Ethernet standard, which is the most popular and widely used.  Other vesions of Ethernet have slightly different framing structures.  For example the older Ethernet II standard doesn't include the DSAP, SSAP, and Control fields, and the Lenght fied is replaced by a Type field which indicates the type of Protocol used for the Data Payaload.  \n\nIn terms of understanding the general funciton of an Ethernet frame, these differences between standards dont' matter too much.  The main elements fo focus on are the Data Payload field being used as an encapsulation mechanism for the layer above, and the main elemtns to focus on are the data payload fieldn being used as an ecnapsulstion mehcanims for th elayer above, and the MAC Address fields being used to direct the frame between network devices.  These particular fields exist across all the different Ehthernet standards. \n\n#### MAC Addresses \n\nIn an earlier assignment, we looked at the idea of the most basic network being two devices connected to each other.  In this situation, if one device wants to send a message to another device, there is no kind of identificaiton needed.  The recipient can just assume that the msessage is intended for it since it is the only possible recipient.\n\nOnce we start adding more devices to our network, the picture becomes more complicated.  One such situation is several computers connected via a network hub.  A hub is a basic piece of network hardware that replicates a message and forwards it to all of the devices on the netowrk.  This is fine if you want to send a particular message to the entire network.  Most of the time this is not the case and the message is intended for a specific device. Thsi is where addressing comes in. \n\nEvery network-enabled device, e.g. a Network Interfeace Card (NIC) that you would find in a PC or laptop is assigned a unique MAC Address when it is manufactured.  Sinc ethis address is linked to the specific physical device, and (usually) doesn't change, it is sometiems referred to as the **physical address** or **burned-in address**.  MAC Addresses are formatted as a sequence of six two-digit hexadecimal numbers e.eg `00:40:96:9d:68:0a` with different ranges of addresses being assigned to different network hardware manufacturers. \n\nIn our hub scnario, each receiving device would chekc its MAC Address agiainst he Desitination MAC Address in the Frame to check if it was the intended recipient.  IF it wasn't then ti would just ignore the frame. \n\n![Screen Shot 2020-08-23 at 10.21.29 PM.png](quiver-image-url/41187088EB31C5A7736703D8A43C0807.png =897x434)\n\nsending every frame to every device on the network isn't very efficeint, espcially for large networks.  THese days it is rare that you'll find a network that uses a hub; most modern networks instead use swithces.  Like a hub, a swithc is a piece of hardware to which you connect devices to create a network.  Unlike a hub however, a swithc uses the destination address in order to direct a frame **only** to the device for which it is intended. \n\n![Screen Shot 2020-08-23 at 10.24.00 PM.png](quiver-image-url/0714FB6995BB620DD8BD2DD09D6448DB.png =878x437)\n\nA swithc directs the frame sto the correct device by keeping and updating a record of the MAC addresses of the the devices connected to it, and associating each address with the Ethernet port, to which the device is conncted on the switch.  It keeps this data in a MAC Address Table, a simple represntation of which might look somethig like this: \n\n\n| *Switch Port* | *MAC Address*|\n|---|---|\n|1|\t00:40:96:9d:68:0a|\n|2 |\t00:A0:C9:14:C8:29|\n|3|\tD8:D3:85:EB:12:E3|\n|4|\t00:1B:44:11:3A:B7|\n\n### A problme of Scale\n\nThe MAc Addressing systme works well for local networks, where all the devices are connected to a swithc that can keep a record of each device's address.  In theroyr, we coould inter-ntwork communcaiton just using MAC addresses.  FOr example, we could design routers that kept records of which MAC Addresses could be accessed via other routers on the wider network.  In practice howve,r there's and issue that prevents us from doing this: scale.  This approach isn't scalable due to certain characteristics of MAC addresses:\n\n- they are physical rather than logical.  Each MAC Address is tied( Burned in) to a specific physical device\n- -they are flat rtaher than heirarchical.  The entire anddress is a single sequence of values and can't be broken down int sub-divison.\n\nImaing eyou laptiop is connected to a local network in Ne york. You then take tha laptop to Tokyo and plug it into a lcoal network there.  In bothe location, the phsyical mac address would be the smae. Keeping tack of which MAC saddresses were part of which local netowrks would be an impossibble task.  Even if we were able to do this, the fact that addressses are non-hierarchical means that routing devices would need a record of each single address that existed womewher ein the world; that would mean storing imopssibly large tables.\n\nIf we want to solve these problesm, wee need a different system of rules that doens't have these limitatios and that can scale in such a way that we can build a network of ntworks which spans the entire glodbe.  The internet protocl provides just a set of rules. \n\n"
    }
  ]
}