{
  "title": "Study Guide for RB139",
  "cells": [
    {
      "type": "markdown",
      "data": "please be comfortable with the following tuppics \n\n##Blocks\n[] Closures and scope\n  - a *closure* is a general programming concepts that lets programmers save an unnamed chunk of code an execute it at a later time. It's called a closure because it is said to bind its surrounding artifacts (variables, methods, objects etc) and build an \"enclosure\" around everything so they can be referenced when then closure is later executed. It's sometimes useful to think of a closure as a method that you can pass around an execute but it is not defined with a specific name.  \n  \n  In ruby a closure is implemented through a Proc, a lambda or a block. that is we can pass around these items as chunks of code an excute them later.\n\n  there are three main ways to work with closures in ruby. \n  \n  1. instantiating an object from the `Proc` class\n  2. using *Lambdas*\n  3. using *blocks*\n\n  \n[]- How blocks work, and when we want to use them.\n   - all methods take an implicit block\n   - blocks have linient arity rules, meaning the number of arguments passed to the block can be more or less than the number of block parameters. \n   - within the method implementaiton you `yield` to the block, and you can pass the `yield` areguments, which will inturned be passed to the block as an argument. \n   There are two main uses cases for blocks:\n     1. defer some inplementation code to method invocation decision. this gives significant flexibility.\n     2. Methods that need to perfrom some \"before\" and \"after\" actions- sandwich code. \n       - opening and closing a file that will be used in a block\n       - get before and after time to time how long a block execution takes \n[]- Blocks and variable scope\nA block creates a new scope fore local variables, and only outer local variables are accessible to inner blocks.\n\n```ruby\nlevel_1 = \"outer-most variable\"\n\n[1, 2,3].each do |n|  # block creates a new scope\n  \n  level_2 = \"inner variable\"\n\n  [ 'a', 'b', 'c'].each do |n2|  #nested block\n    leve1_3 = \"inner-most variable\"\n    \n    # all three level_x variables are accessible here\n  end \n  \n  # level_1 is accessible here\n  # level_2 is accessible here\n  # level_# is not accessible here\nend\n\n#level_1 is accessible here\n#level_2 is not accessible here\n# level_3 is not accessible here\n```\n\n#####Procs\nsuppose that we have had the following\n\n```ruby\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name}\"}\n\ndef call_me(some_code)\n  some_code.calll   # call will exectue the chunk of code\" that gets passed in \nend\n\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name}\"}\n\ncall_me(chunk_of_code}   \n\nhi Robeert\n=> nil\n\n```\n\nThe above is curious because `name` variable was initialized **outside** the method definition, and we know that in ruby local variables initailzied outside the method aren't accessible inside the method, unless it's explicitly passed in as an argument. \n\nMaybe the Proc was pre-prossed somehow. let's test that theory\n\n```ruby\ndef call_me(some_code)\n  some_code.call\nend\n\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #[name}\"}\nname = \"Griffin III\"  # re-assign name after Proc initialization\n\ncall_me(chunk_of_coded)\n\n# hi Grifiin III\n# nil \n```\n\nso even re-assigining the variable after the Proc is initailzied updates the `chunk_of_code`.  This implies that the Proc keeps trakc of its surrounding context, and drags it around wherever the chunk of ode is passed in.  In rub we call this *binding* or surrounding enivroment/cpntext. A closure binds local variables, method references, constants and other artifacts- wahtever it needs to execute correctly. \n\n###closure and binding \n\n\n[] Write methods that use blocks and procs\n\nyou can create a `proc` by writing `new_proc = Proc.new {pus \"hi #{name}\"}` you will later need to call to call the proc by doing `new_proc.call`\n\n[] Methods with an explicit block parameter\n  - You allow this by defining a method that takes a parameter with a prefix `&` character in the method definition. \n  ex:  \n  ``` ruby\n  def test(&block)\n    puts \"what's &block? #{block}\"\n  end\n  ```\n  \n  The `&block` is a special prameter that convernts the block argumnet to a \"simple\" `Proc` object.  Notice we drop the `&` when referring to the parameter inside the method.  Note that name can be whatever you plesae, it doesn't have to be `block` just as long as we define it with a leading `&`.\n  \n  doing this provides added flexibility.  before we din't have a `handle` (a variable) for the implicit block, so we couldn't do much with it except yield to it and test whethere a block was provided.\n  \n  ```ruby\n  def test2(block) \n    puts \"hello\"\n    block.call   #calls the block that was originally passsed to test()\n    puts \"good-bye\"\n  end\n  \n  def test(&block)\n    puts \"1\"\n    test2(block)\n    puts \"2\"\n  end\n  \n  test {puts \"xyx\"}\n  # => 1\n  # => hello\n  # => xyz\n  # => good-bye\n  # => 2\n  ```\n  \n  Note that you only need to use `&` for the `block` parameter in `#test` since `blcok` is already a `Proc` object when we call `test2` no conversion is needed. \n  \n  Note that we also us `block.call` inside `test2` to incoke the `Proc` instead of `yield`.  ( if you wanted to invoke the `Proc` form the `test`, you would do the same thing:  `block.call`.) \n  \n###[] Arguments and return values with blocks\n\n###[] When can you pass a block to a method\n\n\nyou can pass a block to a method expicitly when it its definted in method the method implmenation with a `method(&block)`.  all methods implicitly take a block.\n\n###[] &:symbol\n\n```ruby\n\n[1, 2, 3, 4, 5].map(&:to_s)   # => [\"1\", \"2\", \"3\", \"4\", \"5\"]\n\n```\n\nThe above code iterates through every element in the array and calls `to_s` on it the saves the result in a neo array.\n\nif you look closely, somehow this code:\n\n```ruby\n(&:to_s)\n```\n\ngets converted to this code:\n```ruby\n   { |n| n.to_s }\n```\n\nlets break it down.  Firest when we add `&` in front of an object, it tess Ruby to try to convert this object into a block.  to do so, it's expecting a Proc object.  If this object is not a Proc object, it will call `#to_proc` on the object. \n\n- Ruby checks wherether the object after `&` is a `Proc`.  If it is, it uses the object as-is.  Otherwise it tries to calll `#to_proc` on the object, which should return a `Proc` object.  An error will occur if the `#to_proc` fials to return a `Proc` obj.\n- If all is well, the `&` turns the `Proc` into a block.\n\nlets looks at `&to_s`.  this means that Ruby is trying to turn `:to_s` into a block.  However it's not a Proc, it's a Symbol.  Ruby will then try to call the `Symbol#to_proc` method --- and there is one!  this method will return a `Proc` object, which will eaccute the method based on the name of the symbol.  In other words `Symbol#to_proc` retursn a `Proc`, which `&` turns into a block, which turns our shortcut inot th elong form block usage. \n\nexamples of this\n\n```ruby\n  def my_method\n    yield(2)\n  end\n\n  # turn the symbol into a Proc, then & turns the Proc into a block \n  my_method(&:to_s)\n```\n\nthe code example below will try to break up the 2 steps\n\n```ruby\ndef my_method\n  yield(2)\nend \n\na_proc = :to_s.to_proc     # explicitly call to_proc on the symbol \n\nmy_method(&a_proc)        # convert Proc into block, then pass  block in, returns \"2\"\n\n```\n\n\n##Testing with minitest \n\nwe write tests to prevent regression.  we want to write test so that when we make changies in our coude, we don't have to manually verify everything still works. \n\ntests have the following structure\n\n```ruby \nrequire 'minitest/autorun'\nrequire_relative 'car'\n\nclass CarTest < MiniTest:: Test\n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end\nend\n```\nline 1 `require minitest/autorun`, loads all the necessary files from the `minitest` gem.  \nwe use `require_relative` to specify the file name from the current file's directory.  Now when we make refrences to the `Car` class, ruby know where to look for it \n\non linke 5 we create our test classe. Note that this class must subclass 'MiniTest::Test`.  This will allow our test class to inherit all the necesssary methods fro writting tests. \n\nthe \"seed\" is how you tell Minitest to run the entire test suite n a particular order.  the dot, means the test was run and nothing went wrong.  If you skip a test with the \"skip keyword, it'll say \"S\" a failure it will say \"F\"\n\n### []testing terminology\n\n- we are learning *unit testing**\n- *Test Suite:*  This is the entire set of tests that accompanies your program or application. you can think of this as all the tests for a project. \n- *Test:* this describes a situation or eonctext in which tests are run.  For example this test is about making sure you get an error message after trying to log in with the wrong passwod.  A test can contain mulitple assertions. \n- *Assertion:*  this is the actual verification step to confirm that the data returned by your program or applicaiton is indeeed what is epxected. you make one or more assertions with a test. \n\n- $std -in, StringIO\n\n### [] Minitest vs. RSpec\nMinitest is the default testing library that comes with Ruby.  Minitest can do eveyrhting RSpec can, execept Minitest uses a more straight forward syntax.  Respecs uses a *Domain Specific Language* or a DSL for writing tests, Respec bends over backwards to allow developers to write code that reads like antural english, but at the cost of simplicity. \n\nWe use minitest because it reads just like normal Ruby code, withou a lot fo magical syntax.  It's not a DSL, it's just ruby\n \n###[] SEAT approach\n\n1. Set up the necessary objects\n2. Execute the code agaisnt ht eobject we're testing\n3. Assert the resluts of the execution\n4. Tear down and clean up any lingering artifacts.\n\nwe can refactor our code so we dont have to set it instntiate an new `Car` object before every test\n\ndo this with `setup method`  ex:\n\n```ruby\nrequire 'minitest/autorun'\n\nclass CarTest < MiniTest::Test\n  def setup\n    @car = Car.new\n  end \n  \n  def test_car_exits\n    assert(@car)\n  end\nend \n\n```\n\nwe use a instance variable because we would not be able to access a local vriable. \nNote that in the `setup` method wil be called before running every test, and the `teardown` method will be called after running every test.  \n\n###[] Assertions\n\nthis is the actual verification step to confriem that the data returnbed by your program or applicaiton is indeed what is espected. \n\n`assert_equal` test value equality \n` assert_same` test object equality \n\nif you are trying to `assert_equal` a custom class, you will need to make an `==` instance method to tell ruby which values to compare. \n\n\n\n## Core Tools/ Packaging Code\n\n- Purpose of core tools\n### rubygems:\n\nthese are packages of code that you can download, install and use in your ruby programs or from the command line.  There are thousnad so fgems, you already be familar with some of them:\n\n- rubocop\n- pry\n- sequel\n- rails\n\nthese are all gems\n\n#### rvm and rbenv\n\nruby version managesrs. are progreams that let you install, manage, adn use multiple version of ruby.   Eventually you will write or use a Ruby program that needs a different version of ruby, that's when you find that you need a Ruby version manager.\n\n#### bundler\n\nbunlder lets you describe exactly which Ruby and Gems you want to use with you ruby apps.  speicifcically it lets you install multiple versions of each gem under a specific version of Ruby then use the proper version in your app. Bundeler is a ruby gem, so you must install it like a normal gem:  `gem install bundler`\n\nto use bundler, you provide a file name `Gemfile` that describes the Ruby and Gem versions you want for your app.  you use a DSL described on the bundler website to provide this information.  bundler uses the `Gemfile` to generate a `Gemfile.lock` via the `bundle install` command.  `Gemfile.lock` describes the actual versions of each Gem that our app needs including any gems that the gems listed in `Gemfile` depend on.  the `bundler/setup` package tells your ruby program to use `Gemfile.lock` to determine which Gem versions it should load.\n\nthe `bunlde exec` command ensures that the executable programs installed by gems don't interfere with your app's requirments.  For instance if your app needs a specific version of `rake` but the default version of `rake` differs `bundle exec` ensures that you can still run the specific `rake` varions compatible with your app. \n\nAfter you create `Gemfile` the `bundle install` scans it, downloads, and installs all the dependencies listed and process a `Gemfile.lock` which shows all the dependencies for your program; this includes the them gems listed in the `Gemfile` as well as the gems they depend on which may not be expcitley listed in the `Gemfile`\n\nonce bundler creates your `Gemfile.lcok` add:\n\n```ruby\nrequire 'bundler/setup'\n```\nto the beginning of your app before any other gems \n\n`bundler/setup` first removes all Gem directories form the Rubys `$LOAD_PATH` to list the directories that it seraches when it needs to locate a required file.  When `bundler/setup` removes those driectories from `$Load_Path` ruby can no longer find Gems.\n\nTo fix this, `bundler/setup` reads `Gemfile.lock`; for each Gem listed it adds the direcotyr that contains the Gme back to `$LOAD_PATH` when finished, `require` only finds the proper versions of each gem. \n\n`bundle exec`, using `bundle exec` with `bundle exec reake` will resolve dependeey conflicts when issuing shell commands.\n\n### rake\n\nrake is a ruby gem that automates many common functions required to build, test, package, and install programs;  it is part of every modern Ruby installation, so you don't need to install it yourself. \n\nhere are some common rake tatks that you may encounter:\n\n- set up required enviromen tby creaing directories and files\n- set up and initialize databases\n- run tests\n- package your application and all of its files for distribution\n- install the applicaiton\n- perfrom common git tasks\n- rebuild certian files and directories (assets) based on changes to other files and directories\n\n###how to use rake\n\nRake uses a file named `Rakefile` that lives in your project directory;  this file describes the tasks that rake can pefrom for your progra,t and how to perform those task.\n\n```ruby\ndesc 'Say hello'\ntask :hello do\n  puts \"Hello there.  This is the `hello` task.\"\nend\n\ndesc 'Say goodbye`\ntask :bye do \n  puts 'Bye now!'\nend \n\ndesc 'Do everything'\ntask :default => [:hello, :bye]\n```\n\nRake rusn the default task if you don not provide a specific task name when you invoe Rake.\n\nThe first thing you should do with any Rake files is find out what task it can run.  Do this with `rake-T`\n\n```ruby\nbundle exec rake - T\nrake by #say goodby\nrake default # do everything\nrake hello # say hello \n\n```\n\n`Rakefile` is acutally a ruby program. you can put any ruby code you want in a `Rakefile` and run it as part of a task.  Commands liek `desc` and `task` are just method calls to part of Rake;  these method calls comprise a dsl for writting automated Rake tasks.\n\nyou can run Rake tasks like below\n\n```ruby\nbundle exec rake bye\nBye now!\n```\n\nyou cna use rake to automate repetitive task such as \n\n- run all tests associated with the program\n- increment the version number\n- create your release notes\n- make a complete backup of your local repo\n\n### Gemfiles\ngemfiles looks like this \n\n```ruby\nsource 'https://rubygems.org'\n\nruby '2.3.1'\ngem 'sinatra'\ngem 'erubis'\ngem 'rack'\ngem 'rake', '~>10.40'\n\n```\n\n\n#### relationship of ruby tools\n\nyour ruby version manager is a top level --- it controls multiple installations of ruby and all the other tools.\n\nwithin each installation of ruby you can have multiple gems.  each gem beceomes accessible to the ruby version under which it is installed.  if you want to run a gem in mulitple version of ruby, you need to install it in all of the versions you want to use it with.\n\neach Gem in a ruby installation can itself have multiple versions. This frequently occurs naturally as you install updated Gemsb, but can also be a rquirement;somtimes you jsut need a specific version of a gem for one project, but want to use another verions for your other projects.\n\nthe bundler program is a gem that is used to manage the gem dependencies of your project.   that is it determines and controls the ruby version and gems that your project uses and attempst to ensure that th eproper items are installed and used when you run the program.\n\nFinally, rake is another Gem.  It isn't tied to any one ruby project, but is, instead a tool that you use to perform repetitive development tasks such as running tests, building databases packaging and releasing the software etc.  The tasks that rake perforems are varied and frequently change from one project to anyother you ust hte `Rakefile` fiel to control which task your project needs. \n\n\n## Regular Expressions\nRegular expersion aren't offically a part of this assesment nor are thy covered in detail in the course material.  You will find them useful though, when you work on the practice Coding Challenge problems.  Before you begin the practice challlenges, we recommned that you take some time to study our [introduction to regular expression](https://launchschool.com/books/regex) book\n\n## Precision of Language \n\nsome questions rquire that you explain code or concepts with words.  It's important to explain how code works using precise vocabulary and to pinpoint the causal mechanims at work.  In other words, us the right words and don't be vague.\n\nfor example let's take the following pieve of code\n\n```ruby\n\ndef a_method\n  puts \"hello world\"\nend\n```\n\nif we ask you to dscribe this cod youmay say \"the resul of the method is hellow world\"  This description isn't wrong but its impricess.  A more precise answer sayws \"the method outputs the string hello world, and returns nil.\"\n\n### The Coding Challenge\n\nthe final question of the assessment asks you to write a program that solves a coding challenge.  The program has about the same diffulty leve as the problems form the [challenges section of exercises](https://launchschool.com/exercises#challenges) and has the same Minitest-driven format\n\nto practice for the code cahllenge you shold do a least ten different problems from the Exercis  Challgnes, including at least three from the Medium section.  Be sure to mark which ones you completed.  Make sure you save you practice code on Github or somewher so we can look at it.\n\nTo beigin pracitiv,e visit the challenges section of the exercise page.  We rcommend taht you start with the easy challgnes before trying some of the harder ones.  Make sure you read the GGAQ first\n\n\n####procs blokcs and lambdas with examples\n\n```ruby\n#Group 1\nmy_proc = proc { |thing| pus \"This is a #{thing}.}\nputs my_proc  #<Proc:0x00007ff67580ac00:1>   => nil \nputs my_proc.class  #Proc => nil\nmy_proc.call   # this is a .\nmy_proc.call('cat')  # this is a cat.\n\n```\n\nGroup 1:\n\n-a new Proc object can be created with a call of proc instead of Proc.new (both work) ex:\n   my_proc = Proc.new {|cat| \"this is a #{cat}\"}\n   my_proc_2 = proc {|cat| \"this is a #{cat}\"}\n- a Proc is an object of class Proc\n- A proc object does not require that the correct number of arguments are passed to it.  If nothing is passed, then nil is assigned to the block variable. \n\n\n```ruby\n#Group 2\nmy_lambda = lambda { |thing| puts \"this is a #{thing}.\"}\nmy_second_lambda = -> (thing) { puts \"This is a #{thing}.\"}\nputs my_lambda #<Proc:0x00007f9252a768b8 (lambda)  => nil \nputs my_second_lambda #<Proc:0x00007f9252a768b8 (lambda)  => nil \nputs my_lambda.class  #Proc  => nil \nmy_lambda.call('dog') #This is a dog.  => nil \nmy_lambda.call #wrong number of argumnets, expectng one \nmy_third_lambda = Lambda.new { |thing| puts \"this is a #{thing}.\"}  #uninitialized constant Lambda\n\n```\n\nGroup 2\n\n- a new lambda object can be created with a call to lambda or `->` \n- we annot create a new Lambda object with Lambda.new \n- A Lambda is actually a different variety of Proc. \n- While a Lambda ia a Proc, it maintains a separate identity from a plain proc.  This can be seen when displaying a Lambda:  the string displayed contains an extra \"(lambda)\" that is not present for regular Procs.   \n- A lambda enforces the number of arguments.  If the expected number of arguments are not spassed to it, then an error is thrown. \n\n```ruby\n#Group 3\n\ndef block_method_1(animal)\n  yield\nend\n\nblock_method_1('seal') { | seal| puts \"this is a #{seal}.\"}   # this is a .\nblock_method_1('seal')   # local jump error\n\n```\nGroup 3\n\nA block passed to a method does not require the correct number of arguments.  If a block variable is defined, and no value is passed to it, then nil will be assigned to that block variable.  \nIf we have have a yield and no block is passed, then an error is thrown. \n\n```ruby\n#Group 4\n\ndef block_method_2(animal)\n  yield(animal)\nend \n\nblock_method_2('turtle') { |turtle| puts \"This is a #{turtle}.\"}   # this is a turtle => nil\n\nblock_method_2('turtle') do |turtle, seal|\n  puts \"this is a #{turtle} and a #{seal}.\"      # this is a turtle and a .   => nil \nend\n\nblock_method_2('turtle') { puts \"this is a #{animal}.\"}  # Error Undefined local variable \n\n\n```\n\nGroup 4\n\nIf we pass too few arguments to a block, then the remaining ones are assigned a nil value.  Blocks will throw an error ir a variable is referenced that doesn't exist in the block's scope.\n\nLamdas are types of Proc's.  Technically they are both Proc objects. An implicit block is a grouping of code, a type of closure, it is not an Object.  Lamdas enfore the number of argumetns passed to them.  Implicit blocks and Procs do not enforce the number of arguments passed in. \n"
    }
  ]
}