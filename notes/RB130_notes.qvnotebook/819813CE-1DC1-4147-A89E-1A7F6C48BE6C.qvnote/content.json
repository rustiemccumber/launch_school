{
  "title": "Regex review",
  "cells": [
    {
      "type": "markdown",
      "data": "At there most basic regex are strings of characters between two `/` characters, e.g., `/cat/`.  This regex matches the string `cat` anywhere it coccurs in some text. \n\n\n##Basic Matching\n\n`/s/` matchse sthe letter `s` where it appears inside a string.  It matches `s`, `sand`, `cats` and `cast` and even `Mississippi`.  IN this last example `/s/` matches four times.  Not however that `/s/` does not match `S` or `KANSAS`.  Regex are case sensitve by default. \n\nyou can use `match` method to check a match\n\n```ruby\nstr = 'cast'\nprint \"match 's'\" if str.match(/s/)\n```\n###speical characters\n\nthe following special characters have special meaning in a Ruby or a JavaScript regex:\n\n`$ ^ * + ? . ( ) [ ] { } | \\ /`\n\nThese are called meta-characters. if you want to match a literal meta-character you must **escape** it with a leading backslash (`\\`).  to match a qeustion mark us the regex `/\\?/`\n\nyou can concatenate two or more pattersn into a new pattern that matches each of the originals in squale.  `/cat/` is the concatentaiton of the `c`, `a` and `t` pattersn, and matches any string that contains a `c` fllowed by and `a` followed by a `t`\n\n###Alternation\n\na simple way to construct a regex that mathces one of several sub-patterns\n\n`/(cat|dog|rabbit)/`\n\nThe lazy `cat`.\nThe `dog` barks.\nDown the `rabbit` hole.\nThe lazy `cat`, chased by the barking `dog`,\ndives down the `rabbit` hole.\ncatalog\nThe Yellow Dog\nMy bearded dragon's name is Darwin\n\n### Control Character Escapes\n\nMost mondern computing languages use control charcater excapes in strings to represent characters that don't have a visual representation. for example `\\n`, `\\r` and `\\t` are nearly universal ways to represent line feeds, carriage returns, and tabs.\n\n### Ignoring Case\n\nappend an `i` to the close `/` of a regex, which makes the entire regex ignore case. the documentation calls these options **flags** or modifiers, but we can use all three tersm interchangeably.\n\n###Set of Characters\n\ncharacer class patterns use a list of characters between square brackets `/[abc]/` such a pattern matches a single occurrence of any of the charcters between the brackets.  so the above would match individual characters `a`, `b` and `c` within a setence \n\nthis is useful in scenarios where for example a program wants a user to choose between five different options by entering a numebr between 1 and 5, you can validate that input with eht regex `/[12345]/`.  Likewise, you can validate a `y/n` prompt respones with `/[nyNY]/`\n\nCharacater classses also come in handy when you need to check for uppercase and lowercase letters, nut can't use the `i` flage to make the entire regex case insensitive.  For example `/[Hh]oover/` matches `Hoover` or `hoover`, but not `HOOVER`\n\nWhen writing character classes, it's good practice to groupd characters by type:  digits uppercase letters, lowercase letters, whitesepace, and non-alphanumeric characters.  YOu can arragne the groups in any order though typically the non- alphanumerics come first or last in the character class.  \n\nyou can concatenate characeter classes.  the regex `/[abc][12]/` matchs any two characters where the first charcter is an `a`, `b` or `c` and the second is a `1` or a `2`.\n\n\nMeta-characters within dwindle to a handful inside of a character class:\n\n`^``\\``-``[``]` are all meta characters.\n\nyou can excape any of the special characters even i fyou don't have to. THus `/[\\*\\+]/` is an acceptable, albeit less readable equivalent to  `/[*+]/`.\n\n###Range of characters\n\nsometims you'll find that your character class is a natural sequence of characters such as the letters `a` through `z`.  You can abbreviate these ranges inside character classes by specifying the starting chracter, a hyphen (`-`) and the last character.  Thus `/[a-z]/` matches any lowercase alphabetic charcter, `/[j-p]/` limits that to the letters `j` through `p` while `/[0-9]/` matches any decimal digit. YOu can even combine ranges; suppose you need to match hexdecimal digits.  If so the following you could using the following\n\n`/0-9A-Fa-f]/`\n\n###Negates Class \n\nanother useful feature of feature of character class ranges is range negation.  Negations look like ordinary character classes, except the first character between the brackets is a (`^`).  THe negated class matches all characters not identified in the range. \n\nat its simplest, you can have a negated charcater range for one characeter. for example `/[^y]/` will match everything that is not `y`\n\nor you can negate multiple characters. for example `/[^aeiou]/` matches any character but `a` `e` `i`, `o`, or `u`. \n\n###Character Class Shortcuts\n\n\nthe most commonly need character class is the class that represents **any** character.  If you don't care whether a character is alphanumeric, punctuation, whitespace, some control character, or something else entirely, you need a character class that represts andy character that's whet eh `.` meta character comes in. \n\nthe `/./` does not match newline characters which is usefull: you typically don't wan them.  Us the `/m` (multiline) opeiton when `.` should match newlines; see the documentation for your language. \n\n###Whitespace\n\ntwo additonal character class shortcuts that are frequaently needed are `\\s` for whitespace characters and `\\S` for non-whitespace cahracters.  By defintion, the whitespace characters are teh space (' ') tabe ('\\t') vertical tab ('\\v') carrigage return ('\\r') and line feed ('\\n') and form feed ('\\f').  Thus `/\\s/` is equivalent to `/[ \\t\\v\\r\\n\\f]` while `/\\S/` is equivalent to  `/[^ \\t\\v\\r\\n\\f]/`\n\nThe decimal digts 0-9 and teh hexadecimal digits, `0-9` `A-F`  and `a-f` also show up often in character classes, so we have shortcuts form them\n\n|Shortcut|Meaning|\n|---|---|\n|\\d| ANy decimal digit (0-9)|\n|\\D| andy Character but a decimal digit|\n|\\h| Any hexadecimal digit (0-9, A-F, a-f)(RUBY)|\n|\\H | Any character but a hexadecimal digit (ruby)|\n\nas with `\\s` and `\\S` you can use these shortcuts in or out of square brackets.\n\n##Word Characters\n\nThis last pair of shortcuts may be confusing.  `/\\w/` matches \"word characters\", while `/\\W/` matches \"non-word characts\".  At first glance, most people assume that word characters are alphabetic.  In fact, the defintion of word cahracts for `\\w` is a bit broader than that; they include all aphabetic characters (a-z, A-Z) all decimal digits(0-9) and ondly an underscore (`_`). you can use  \n\nAs with `\\d` and `\\D` you can use `\\w` and `\\W` in or out of square brackets. \n\n###Anchors\n\n\nanchors ensure that a regex matches a stringat a specific place: the beginning or end of the string or end of a line or on a word or non-word boundary. \n\n### Start/End of Line\n\n`^` and `$` meta-characts are anchors that fix a rgext match to the begining (`^`) or ending (`$`) of a line of text.  In ruby, there's some subtlety to that definition which we will circle back to in the next subsection; for now though, you can think of it as meaning that `^` and `$` anchor a regex to the beginnin gor end of a string.\n\n###lines vs Strings\n\n`^` anchors the regex to the beginning of each line the in the string, not only the beginnin gof the string.  for ruby's purpose each new line occurs after a `\\n` character with the begiing of the string marking th ebegiing of the first line.  \n\n###start/end of stirng\n\nfor mactching at the begining of the string, and not the beginning/end of a new line use\n\n`\\A`, `\\Z\\` and `\\z` anchors note that there is no \\a anchor \n\n\n\nthe `\\A` anchor ensures that a regex matches at the beginning of the string, while `\\Z` and `\\z` match at the end of the stirng.  the difference betwen `\\Z` and `\\z` is somewhat subtle and seldom of concern;  `\\z` always matches at the dn of a stirng, while `\\Z` matches up to but not including a newline at the end of the string.  as a url us `\\z` until you determien that you need `\\Z`\n\n###Word Boundaries\n\nThe last two anchors anchor regex matches to word boundaries (`\\b`) and non-word boundaries (`\\B`).  FOr these anchors, words are sequences of word charcters(`\\w`) while non-words are sequences of non-word characters (`\\W`).  A word boundary occurs:\n\n- between any pair of characters, one of which is a word character and one which is not.\n- at the beginning of a string fi the first charcter is a word character.\n- at the end of a string if the last character is a word character. \n\na non-word boundary matches any place else:\n\n- between any pair of characters, both of which are word charcters or both of which are not word characters.\n- at the beginning of a string if the first character is a non-word character.\n- at the end of a string if the last character is a non-word character. \n\n\n`\\b` and `\\B` doe not work as word boundaries inside of  charcater classes (between square brakcets).  `\\b` means to match backspace cahracter when insdie of square brackets.\n\n###Quantifiers\n\n```\nFour and 20 black birds\n365 days in a year, 100 years in a century.\nMy phone number is 222-555-1212\nMy serial number is 345678912\n```\n\nyou can use the pattern `/\\b\\d\\d\\d\\d*\\b/`. aganst strings in rubular\n\n`*` is a quantifier that matches zero or more occurrences of the pattern to its left\n\nyou can use parentheses to define the pattern to which you want to apply the `*`, for instance try `/1(234)*5/` against\n\n```ruby\n15\n12345\n12342342345\n1234235\n```\n\nall should be a match\n\n\n###One or More\n\nTehh `+` quantifier is nearly identical to the `*` qauntifier, but instead, of matching zero or more occurrences of something, it matches one ore more occurences of that thing.\n\n###Zero or ONe\n\nsometimes you need an optional pattern in a regex;  a pattern that either occurs once or doesn't occur at all.  For these situations, you need the `?` quantifier.  As with `*` and `+`, `?` applies to the pattern to its left.\n\nsuppose you need to test whether a string cotiasn the words `cot` or `coot` but don't want to match against `ct` or `cooot`. In this case, you can use `/coo?t/`which matches a `c` fllowed by and `o` followed by an optional `o` followed by a `t`. \n\n###ranges\n\nsometimes you need to specify the repeat count more precisely.FOr example,you may want to test a phone number to see if it contails presicely ten digits or perhaps you want to look at all the words taht contain at least seven characters.  Or you want words that are 5-8 characters long.  \nthe range quantifier consists of a pair of curly braces `{}` with one or two numbers and an optional comma between the braces:\n\n-`p{m}` matches pricsely `m` occurencse of the pattern p\n-`p{m,}` matches `m` or more occurences of `p`\n- `p{m,n}` matches `m` or more occurrences of `p` but not more than `n`\n\n###Greediness\n\nTHe quantifiers we've discussed thus far are **greedy** they alwasy match the longest possible string they can.  For instance, trying try matching `/a[abc]*c/` against `xabcbcbacy`  you ses the pattern matches `abcbcbac` not `abc` or `abcbc` both of which could match the pattern bt are shorter than th efinal match string. \n\nIn most casses greediness is what you want.  However, sometiems it isn't, and you need ot match the fewest number of characters possible; we call this a *lazy* match.  In Ruby and JavaScript, you can request a lazy match by adding a `?` after the main quantifier.  For example `/a[abc]*?c/` matches `abc` and `ac` in `xabcbcbacy`\n\n\n\n"
    }
  ]
}