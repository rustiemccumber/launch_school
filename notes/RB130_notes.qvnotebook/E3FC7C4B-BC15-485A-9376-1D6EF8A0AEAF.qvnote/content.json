{
  "title": "Study topics RB139Â ",
  "cells": [
    {
      "type": "markdown",
      "data": "##Blocks Closure and Scope\n\n###summary of all below\n\nClosures as a whole is at the core of many programming languages, so start to get comforable with idea of unnamed \"chunks of code\" you can pass aroudn and execute later.\n\nSpecifically, we saw:\n\n- blocks are jsut one way Ruby impolemnts closure.  Procs and lambdas are others\n- you can pass more arugmnets thatn the block parameter list shows.\n- you can pass fewer arguments than the block parameter list shows, the omitted arguments will be `nil`\n- passing in `&block` (or other word) lets you explicitly pass in the bock to the method.  it converts the blco to a Proc object  and assigns it to a local variable\n- closures drag their surrrounding context/enviroment around, and this is at the core of how variable scope works.\n- blocks are great for pushing some deicison to mehtod invocation time.\n- blocks are great for wrapping logice, where you need to perform some before/after actions\n- we can write our own method that take a blcok with the `yield` keyword.\n- when we `yield`, we can also pass arguments to the block.\n- when we `yield`, we have to be aware of block's return value\n- once w eunderstand blcoks, we can re-impoment many of th ecommon mehtods in the RUby core library in our own classes\n- the `Symbol#to_proc` is a nice shortcut when working with colletions \n\nsee below for intersting case\n\n```ruby\n\ndef call_chunk(code_chunk)\n  code_chunk.call\nend\n\nsay_color = Proc.new {puts \"the color is #{color}\"}\ncolor = \"blue\"\ncall_chunk(say_color)\n\n# this code will raise and error since the closure created by `say_color` doesn't include `color` as part of the binding. \n# If you swap lines 5 and 6 with each other, this code will run and output `the color is blue.`\n```\n\nin the code below , there are several bindings (illustrated in code)\n\n```ruby\nARRAY = [1, 2, 3]\n\ndef abc\n  a = 3\nend \n\ndef xyz(collection)\n  collection.map { |x| yield x}\nend\n\nxyz(ARRAY) do \n  # blcok body\nend\n\n# from above the follwing names are part of the binding for the block body on `line 12`\n\n# ARRAY\n# abc\n# xyz  (why does it have bindings to xyz)\n\nit does not have bindigns to `collection`, or `a`\n\n\n\n```\n\n####Closure and scope\n\nAny variablse that need to be accessed in a proc (or block/lambda) must be definied before the proc is created (or passed as an argument when the proc is called). examples\n\n```ruby\na = 1\nb = 2\nmy_proc = Proc.new do \n  p a \n  p b\nend\nmy_proc.call\nc = 3\n\n# this works, and outputs the values of a and b \n```\nexample 2\n\n```ruby\nmy_proc = Proc.new do \n  p c\nend\nmy_proc.call\nc = 3 # => undefined local variable or method `c` for main:Objet (NameError)\n\n#this doesn't work because c was not in scope ( and so not part of the proc's binding). \n#when the proc was created\n\n```\nexample 3:\n\n```ruby\nmy_proc = Proc.new do \n  p c\nend\n\nc = 3 #=> undefined local variable or method `c` for main: Object (NameError)\n\nmy_proc.call\n\n# this doesn't work, for the same reason as example 2\n# even though we call the proc after c is defined it wasn't in scope when the \n#proc was created so is still not part of the binding\n\n```\n\nexample 4\n\n```\nmy_proc = Proc.new do |num|\n  p num\nend\n\nc = 3\nmy_proc.call(c)\n\n# this works, but only bvause we are passing in c as an argument to the \n# the Proc.call method, *not* because c is part of the proc's biding. \n```\n\nA closure retains acess to variables, constants, and methods that were in scope at the time and location you created the closure.  It binds some code ith the in-scope items.\n\nA **closure** is a general porgramming conept that allows proramers to save a \"chunk of code\" and execute it at a later time.  It's called a \"closure\" becasue it's said to bind it's surrroundign aritifacst (i.e variable ethids, objects etc) and buil and \"enclosure\" around everything so that they van be referecne when the closure is later executed.  It's somtimes useful to think of a closure as a method that you can pass around and execute, but it's not defined with an explicit name.  different programming languages implement closures in different ways. some languages will have first class supoort for it whie other languages won't deal with it at all. \n\nIn ruby a closure is is implemented through a `Proc` object, a lambda or a block.  That is we can pass around these times as a \"chunk of code\" and execute them later.  This may seem like a crazy idea.  If you have the need for a \"chunkc of code\" why not just create a method and aclall taht method later?  doesn't that do the same thing? as we'll explore in this lesson the idea of having an unname chunk of code that we can pass around is very handy, especially when we pass them into exitisng methods.  the only thing to remember is that this \"chunk of code\" retians references to its surrounding aritifacts --- its **binding**\n\nthere are three main ways to wrok with closures in Ruby:\n\n1.  Instantiating an object from the `Proc` class\n2.  Using lambdas\n3.  using `blocks`\n\nA block creats a new scope for local variabls and only outer local variabls are accessible to inner blocks\n\n#####closure and binding\n\nas we talked about before a block is how ruby implements the idea of a **closure** which is a general computing concept of a \"chunk of code\" that you can pass around and execute at some later time. In order for this \"chunk of code\" to be executed later, it must understand the surrounding context from when it was intiialized.  In ruby this \"chunk of code\" or closure is represented by a Proc object, a lambda, or a block. Remeber that blocks are a form of Proc\n\nexample\n\n```ruby\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name}\"}\n```\n\nif you try to run the code, nothing will happen.  than's because we've created a Proc and saved it to a `chunk_of_code`, but haven't eecuted it yet.  We can now pass around this local variable, `chunk_of_code` and execute it at any time later.  Suppose we have a completely different mehtod, and pass in this `chunk_of_code`into that mehtod, then the method executes that `chunk_of_code`.  Think it through, and take a guess at what would happen \n\n```ruby\ndef call_me(some_code)\n  some_code.call\nend \n\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name\"}\n\ncall_me(chunk_of_code)\n```\nRead the above think about what you know about variable scoping rules and try to guess the output.\n\nthe output of the above is:\n\n```ruby\nhi Robert\n=> nil\n```\n\nthen `name`initailized **outside** the mehtod definition, and we know that in ruby local variables initialized utside the method aren't accessible inside th emethod, unless it's explicityly passed in as an argumnent.  so again, how did that code we pass in know how to process the `name` variable?\n\n\nmaybe the Proc was pre-processed somehow?  let's see if the chunk of code retains its old value \"Robert\" or our new value of `\"griffin III\"`\n\n```ruby\ndef call_me(some_code)\n  some_code.call\nend \n\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name}\"}\nname = \"Griffin III\"  # re-assign name after Pro initialization\n\ncall_me(chunk_of_code)\n\n```\nthe output is:\n\n```ruby\nhi Griffin III\n=> nil\n```\nso even re-assinging the vairable after the Proc is initalized updates the `chunk_of_code`.  This implies that the Proc keeps track of its surrounding context, and drags it around whever the chunk of code is passed to.  In ruby we call this **binding** or surrounding environment/context.  A closure must keep track of its surroudning context in order to have all the info it needs in order to be executed later.  This not only includes local variabls, but also method references, constants and other artifacts in your code. \n\nthis is why \"inner scopes can access ourter scopes\", and is at the core of how ruby works. (REMEMBER THIS ABOVE)\n\n####how blocks work and when we want to use them\n\nblocks are a way to defere some inplmentation decicions to method invocaiton time.  It allows method callers to frefine a method at invocation time for a specific use case.  IT allows method implmentors to build generic methods that can be used in a variety fow ways.\n\nblcoks are good use case for \"sandwich code\" scenarios, like clsing a `File` automatically. \n\nblocks are one way that RUby implemetns closures.  Closures are a way to pass around an unnamed \"chunk of code\" to be executed later.\n\nThere are many ways that blocks can be useful, but the two main use cases are:\n\n1. Defer some implementaiton code to method invocation decision. \n\n  There are two roles invocled with any method:  the **method implmentor** and the **method caller** (note that this could eb the same person/developer).  There are times when the method implementor is not 100% certain of how the method will be called.  Maybe the method implementor is 90% certain, but watns to leave that 10 % decision up to the mehtod caller at method invocation time. \n  \n  By using blocks, the mehtod implementor can defer the decision of which flags to support and let the method caller decide at method invcation time.  \n  \n  setting it up this way creates great flexibility\n  \n2.  Methods that need to perform some \"before\" and \"after\" actions - sandwich code.\n\n  Sand wich code is a good esample of the previous point about deferring implementation to method invocation.  There will be times when you want to write a generic method that perfoms some \"before\" and \"after\" action.  Before and after what?  That's exactly the piont -- the method implementor doesn't care:  before and after anything.  Let's explore an example.  Suppose we want to write a method that outputs how long something takes. out mehtod doens't care what that something is; our method just cares about displaying how long it took.  THe outline of our mehtod could look like this:\n  \n  ```ruby\n  def time_it\n    time_before = Time.now\n    \n    time_after= Time.now\n    \n    puts \"It took #{time_after - time_bore} seconds.\"\n  end \n  ```\n  The question for the method implementor is what do we fill in for \"do somehting\" the answer is nothing.  As the mehtod implemntor, we dont' care about what code goes there.  THe responsibiliyt fo our mehtod starts and stops at timing the action, without regard to what the actual action is.  This is a good use case for blocks. lets update the method implementaiton to yield to the blcok\n  \n  ```ruby\n  def time_it\n    time_bfore = Time.now\n    yield   # execute the implicit block\n    tiem_after - time.now \n    puts \"It took #{time_after - time_before} seconds.\"\n  end\n  \n  time_it { sleep(3) }                    # It took 3.003767 seconds.\n        # => nil\n\ntime_it { \"hello world\" }               # It took 3.0e-06 seconds.        # => nil\n  ```\n\nThe `sleep` method there jus pauses execution for however many seconds you pass in.  YOu can see that out `time_it` method does exactly what we want.  There are many usefule cases for \"sandwich code\".  Timing, logging, notification systmes are all examples where before/after actions are important. \n\nanother area where beofore/after actions are important is in resource management, or interfacing wiht the operating system.  Many Os interfaces require you, the devloper to first allocate a portion of a resource then perform some clean-up to free up that resources.\n\nin the example \n```ruby\n[1,2,3].each {|num| puts num}\n```\nis actualy passig in the block of code to the `Array#each` method.  the entire block is **passed** in to the methold like any other arugment, and it's up to the mehtod implementation to decide what to do with the block, or chunk of code, that you passed in.  The method could take that bock an dexecute it, or just as likely it could copletly ignore it.\n\nIn order to allow calling the method with our without a block, we must somehow wrap the `yield` call in a conditioanl: only call `yield` when a block is passed to the method and don't call `yield` call `yield` when there's no block. we can achieve this with the `Kernel#block_given?` method. \n\n```ruby\ndef echo_with_yeld(str)\n  yielf if block_given?\n  str\nend \n```\n\nif you don't do the above, a `LocalJumpError: non block given (yield)` will be raised. \n\nhowever we want to allow for some flexibility at method usage or invcation time.  Blocks are perfect for this.  Let's update the implementaiton to yield to a block and pass in the incremented number into the block. \n\n\n####blocks and variable scope\n\n#####yielding with an argumnet\n\nsometimes the block we pass into a method requires and argument.  \n\n\n```ruby\n3.times do |num|\n  puts num\nend\n```\nin the code above the `num` variable between the two `|`'s is a parameter for the bock, or more simply, a block parameter.  Within the block, `num` is is a block *block local variable*.  This is a special type of local variable where the scope is constraned to the block.\n\nIt's important to make sure the lock parameterhas a uniqure name and doesn't conflict with any local variables outisde the scope of the block.  Otherwise, you'll encounter variable shadowing.  Shadowing makes it impossible to access the variable defined in the outer scope, which is usually not what you want. \n\n\n####write methods that use blocks and procs\n\n\n```ruby \ndef say(words)\n  yield if block_given?\n  puts \"> \" + words\nend \n\n# mehtod invocation\nsay(\"hi there\") do \n  system 'clear'\nend \n\n```\n\n1. execuation starts a method invoation on linne 8.  THe `say` method is invoked with two arugmenst,: a string and a block (the block is an implicit parameter and not part of the method definition). \n\n2.  Execution goes to the line 2, where the method local varaible `words` is assigned the string `\"hi there\"`.  THe block is passed implicitly wihtout being assigend to a variable. \n\n3. execution continues into the first line of the method implementaiton, line 3, which immedieately yields to the block. \n4.   the block line 9 is now exdcuted which clears the screen.\n\n5. after the block is done executing, execution continues in the method iplemenation one line 4.  Executing the line 4 results in output being diplayed. \n6. the mehtod ends, which means the laste expression's value is returned by this mehto.d  THe last expression in th emehtod invokes the puts method so the retunr value fo the method is `nil` \n\nexecution went like this:\n\n```ruby\nline 8 -> line 2 -> line 3 -> line 9 -> line 4\n```\n\n####methods with explicit block parameters\n\nthe last topic we want to discuss is passing a block to a method explicitly.  Until now, we've passed blcoks to methods implicitly.  Everyt method, regardless of its definition, takes and implcit block.  It may ignore the implicit block, but it still accepts it.  However, there are times when you want a method to take an explicit block; you do that by defining a parameter prefixed by an `&` character in the method definition:\n\n```ruby\ndef test(&block)\n  puts \"what's &block?  #{block}\"\nend\n```\nwhoa that looks a bit odd.  The `&block` is a special parameter that converts the block argument to what we call a \"simple\" `Proc` object (the exact definition of a simple `Proc` object isn't importatnt at this time).  Notice that we drop the `&` when referring to the parameter inside the method.  Let' invoke the mehtod to see what happens\n\n```ruby\ntest { sleep(1) }\n\n# What's &block? #<Proc:0x007f98e32b83c8@(irb):59>\n# => nil\n```\nAs you can see the `block` local variable is now a `Proc` object. Note that we can name it wheatever we please; it doesn't have to be `blcok`, just as long as we define it with a leading `&`. \n\nwhat's the point, we were doing fine yielding to an implicit block.  Wwhy do we now need an explicit block instead?  Chiefly, the answer is that it provides additonal flxibiliy.  BEfore we didn't have a handl (a variable) for the implicit block, so we could't do much with it expcet yield to it and test wheter a block was provided.  Now w have a variable that represents theblock, so we cna **pass the blcok to another method:**\n\n```ruby\ndef test2(block)\n  puts \"hello\"\n  block.call   # calls the blcok that was originally passed to the test()\n  puts \"good-bye\"\nend\n\ndef test(&block)\n  puts \"1\"\n  test2(block) \n  puts \"2\"\nend \n\ntest { puts \"xyz\" } \n\n# => 1\n# => hello\n# => xyz\n# => good-bye\n# => 2 \n\n```\nnote that you only need to use `&` for the `block` parameter in `#test`.  Since `block` is already a `Proc` object when we call `test2`, no conversion is needed.\n\nNote that we also used `block.call` insde test2 to invoke the `Proc` instead of `yield`.  if you wanted to invoke the `Proc` from `test` you would do the same thing: `block.call`) \n\n\n\n####arguments and return values with blocks\n\nblocks can take arguments, just like noraml methods.  But unlike normal methods, it won't complain about the worng number of arguments passed to it. \n\nblocks return a value, just like noraml methods. \n\nLet's write our own method that takes ablock with an argumnet.  Suppose we want to write a method called `increment` that takes a number as an argumnet, and returns the argument incremented by 1.  At implementation time, we don't want to output the incremented number becasue we aren't sure how users will us this method\n\n```ruby\n# method implementation \n\ndef increment(number)\n  number + 1\nend \n\n# method invocation\nincrement(5)   # => 6 \n```\nhowever we want to allow for some flexibility at method usage or invcation time.  Blocks are perfect for this.  Let's update the implementaiton to yield to a block and pass in the incremented number into the block. \n\n```ruby\n# method implementation \n\ndef increment(number)\n  if block_given?\n    yield(number + 1)\n  end\n  number + 1\nend\n\n#method invocation\n\nincrement(5) do |num|\n  puts num\nend \n\n```\nThe above method invocation outputs `6`.  Notice the use of `block_given?`,  which allows us to continue to call the method without a block.  Let's trace the code execution in the above code snippet.\n\n1. execution starts at meethod invocation on line 10.\n2. execution moves to the method implmentation on line 2, which sets `5` to the local variable `number`, and the block is not set to any variable; it's just implicitly available.\n3. Esxecution continues on line 3, which is a conditional.\n4. our method invcation has indeed passed in a block, so the conditional is true, moving execution to line 4.\n5. on line 4, execution is yielded to the block (or the block is called), and we're passing `number + 1` to the block.  This means we're calling the block withe `6` as the block argument.\n6. execution jumps to line 10 where the block local variable `num` is assigned `6`.\n7. Execution continues to line 11, where we output the block variable `num`.\n8. execution continues to line 12, wehre the end of the block is reached.\n9. execution now jumps back to the method implementation, where we just finished executing line 4. \n10. Execution continues to line #5, the end of the `if`.\n11. line 6 returns the value of the incremented argument to line 10. \n12. the prgram ends (the return value of `#increment` is not used)\n\nthe sequence of execution looks something like this \n\n```ruby\nline 10 -> line 2 -> line 3 -> line 4 -> line 10 -> line 11 -> line 12 -> line 4 -> line 5 -> line 6 -> line 10 -> program ends \n```\n\nnow that you understand how passing an argumnet to a block works, maybe you're thinking \"what would happen if  I pass in the wrong number of arguments to a block?\".  Would Ruby rais and `ArgumentError`, like it would for normal methods?  Let's give that scenario a tyr.\n\n```ruby\n# method implementation \n\ndef test \n  yield(1, 2)    # passing 2 block arguments at block invocaiton time \n  \n  # method invocation \n  test { |num| puts num }  # expecting 1 parameter in block implementation \nend \n```\nsurprsingly the extra block areumnet is ignored!  what if we pass in 1 less block argument, instead of passing in 1 more?\n\n```ruby\n# method implementation \ndef test\n  yield(1)     #passing 1 block argumnet at block invcation time\nend\n\n# method invocation\ntest do |num1, num2|\n  puts \"#{num1} #{num2}\"  # expecting 2 parameters in block implementaiton\nend \n\n```\n\neven more surprisingly this also outpus `1`.  But htis output is different from the previous one.  in this casw `num2` blcok local variable is nil so the string interpolcaiton converted that ot an empyt string which is why we get `1 ` (there's an extra space)\n\nthe rules regarding the number of arguments that you can pass to a block, `Proc` or `lambda` in Ruby is called its **arity**.  In ruby, blocks have lenient arity rules, which is whey it doesn't complain when you pass in different number of arguments; `Proc` objects and `lambda `s have different arity rules.  FOr now, don't worry too much about this but just realize that blocks don't enforce argument count, unlike noramal methods in Ruby. \n#####Return value of yielding to the blcok \n\nSuppose we want to write a method that outputs the before and after of manipulating the argument to th emethod.  For exoample, we'd like to invoke a `compare`.\n\n```ruby\ndef compare(str)\n  puts \"Before: #{str}\"\n  after = yield (str)\n  puts \"After: #{after}\nend\n\n#method invocation\ncompare('hello') { |word| word.upcase }\n```\nthe output from the method invocation is :\n\n```ruby\nBefore: hello\nAfter: HELLO\n=> nil \n```\n\nform the above example you can see that the `after` local variable in the `compare` mehtod implementation is assigned the **return value from the block**.  This is yet another behavior of blocks that's similar to normal methods:  they have a return value, and that return value is determined based on the last expression in the block. This imples that just like normal methods, blocks can either mutate the argument with a destructive method call or the block can return a value, just liek writing good normal methods. writing good blcoks requires you keep this disticntion in mind. Note that the last line `=> nil` is the return value of the `compare` method, and isn't related to what we're doing in the block.  The last expression in the `copare` method is a `puts` and therefore the return value of calling `compare` is alwasy `nil`\n\n\n####when can you pass a block to a method\n\nevery method you have ever written in Ruby already takes a block, let's impolment a simple method. \n\n```ruby\ndef hello \n  \"hello!\"\nend \n\nhello # => \"hello!\"\n```\n\nwhat if we called it with a block \n\n```ruby\nhello { puts 'hi'}        # => \"hello!\"\n```\n\nit's almost as if the block wasn't even bening passed to them method.  How can we be sure that the method actulaly has acccess to the block?\n\n###yielding \n\none way that we can invoke the passed-in block argument from wihtin th emehtod is by using the `yield` keyword.   Let's modify our `echo` mehtod implemenaiton and yield to the blokc\n\n```ruby\ndef echo_with_yield(str)\n  yield\n  str\nend\n```\n\nWhen you read a method's implementaiton, that's not the end of the stoyr.  IF your method implenations ocntains a `yield` a developer using the mehtod can come in after this method is fully implmented an inject additional code in the middle of this method (without modifying the method implmenetation), by passin g in a block of code.  This is indeed on of the majore use cases of using blocks, which we'll talke more about later. \n\n\n\n####`&:symbol\n\n\nsummary\n\nwhen you using `&:to_s` or other method, first it converts the symbol into a proc, then the proc is converted into a block, which is `yield`ed to by the method call (map, each etc). \n\n\n##### symbol to proc \n\nif you look closly, somehow this code:\n\n```ruby\n(&:to_s)\n```\n\ngets converted to this code:\n\n```ruby\n{ |n| n.to_s }\n\n```\n\nwhat's the mechanism at work here?  It's related to the use of `&` with explicit blocks, but since it isn't applied to a method paramter, its also different.  Let's break down the code: `(&:to_s)`.  First when we add a `&` in front of an object, it tells Ruby to try to conver this object into a block.  to do so, it's expecting a Proc object.  If this object is not a Proc object it will call #to_proc` on the object. So two things are happending\n\n- RUby checks whether the object after `&` is a `Proc`.  If it is, it uses the object as-is.  Otherwise it tries to call `#to_proc` on the object, which should return a `Proc` object.  An error will occur if the `#to_proc` fails to return a `Proc` object\n- If all is well, the `&` turns the `Proc` into a block. \n\nlet's paaus and look again at `(&:to_s)`  This means that Ruby is tyring to turn `:to_s` into a block.  However, it's not a Proc; it's a Symbol.  Ruby will then try to call the `Symbol#to_proc` method -- and there is one!  This method will return a `Proc` object, which will execute the method based on the name of the symbol. In other words `Symbol#to_proc` returns a `Proc`, which `&` turns into a block, which turns our shortcut into the long form block usage. \n\nexamples\n\n```ruby\ndef my_method\n  yield(2)\nend\n\n#turns the symbol into a Proc, then & turns the Proc into a block \n\nmy_method(&:to_s)  # => \"2\"\n\n# the above we will try to illustare in two steps\n\na_proc = :to_s.to_proc # explicitly calle to_proc on the symbol\n\nmy_mehtod(&a_proc) #convert Proc into block, then pass block in.  Returns \"2\"\n\n\n```\n\n##Testing with minitest\n\n###using mini test  \n\n**Minitest** is a testing framework that comes with every standard Ruby distribution, its not quite as powerful or flexible as RSPec but fore most case Minitest will do everything you need.\n\nexample \n\nsay you create a file `car.rb` on you file systme which includes the folliwng code.\n\n```ruby\nclass Car\n  attr_accessor :wheels\n  \n  def initialize\n    @wheels = 4\n  end\nend\n```\n\nNow, in the same directory, create another file called `car_test.rb` with the following code.\n\n```ruby\nrequire `minitest/autorun`\n\nrequire_relative `car`\n\nclass CarTest < Minitest::Test\n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end \nend\n```\n\nif you run the test file wiht `ruby car_test.rb` you should see this output:\n\n```ruby\n$ ruby car_test.rb\n\nRun options: --seed 62238\n\n# Running:\n\nCarTest .\n\nFinished in 0.001097s, 911.3428 runs/s, 911.3428 assertions/s.\n\n1 runs, 1 assertions, 0 failures, 0 errors, 0 skips\n```\n\nlets take a closer look at what's int he acutal test file `car_test.rb` and break it donw liner bey line\n\nOn line `require 'minitest/autorun'` loads all the necessary files from the `minitest` gem.  That's all we need to use Minitest.  Next, on line 3 we require the file that we're testing, `car.rb` which contains the `Car` class.  We us the `require_relative` to specify th efile name from the current file's dircetly. Now when we make references to the `Car` class ruby knows where to look for it. \n\nFinnnaly, line 5 is where we create our test class.  NOt this calsss must ubclass `Minitest::Test`.  THis will allow our test class to inherit all the necessary methods for wrting tests.\n\nWithin our test class `CarTest` we can write tests by creating an instance method that stares with **test_**.  Through this naming convention, Minitest will know that these methods are individual tests that need to be run.  Within each test (or instance method that starts with \"test_\") we will need to make some assertions.  These assertions are what we are tyring to verify. Before we make any assertions, we have to first set up th eappropriate data or objects to make assertions against. for example on line 7, we first instantiate a `Car` object, we then use this car object in our assertion to verify that newly created `Car` objects indeed have 4 wheels. \n\nThere are many types of assertions but for now, just focus one `assert_equal`.  Since we are inside and instance method, you can guess that `assert_equal` is and inherited instance method from somwher eup the hierary. \n\non the test ouput if there is a dot `.` then nothing when wrong if you skip a test with the \"skip\" keyword, it'll say \"S\".  If you have a failure, it'lls say \"F\".  Pay attion to see i you have a fialing test. \n\nyou can colorize minitest results using the following (note: `minitest/reporters` suppresses the line that shows S, F and dots that indicate what happened with the test:\n\n```ruby\nrequire \"minitest/reporters\"\nMinitest::Reporters.use!\n```\nyou can skip a st by adding `skp` to the top of the test (you can also pass a string into `skip` if you want a more custom display message. \n\n```ruby\ndef test_bad_wheels\n  skip\n  car = Car.new\n  assert_equal(3, car.wheels)\n```\n\n\n\n### testing terminology\n\n- **Test Suite**:  this is the entire set of tests that accompanies your program or applicaiton. you can think of this as all the test for the project.\n-  **Test or test step**: This describes a sistuation or context in which tests are run.  For example this test is about making sure you get an error message after tyring to log in with the wrogn password.  A test can contain mutliple assertions. Test steps employ either and assetion or an expectation depending on your testing framework. \n- **Assertion**: this is the actual verification steop to confirm that the data returned by your program or application is indeed what is expected.  YOu make one or meore assetions within a test.\n-  **Testing Framework** is a software that provides a way to test each of the componenets of an application.  These can be methods or entire programs; the framework should be able to provide appropriate input, check return values, examine outputs, and even dtermine if errors occur when they should. \n- **test case** is a set of actions that need to be tested combined with any appropriate teststeps.  For example, a test case for the above test step may include creation of the to-do object, a call to the `#completed?` method on that object, and  finally, an assertion that the return value of the `#completed?` method is false.  \n\n### Minitest vs. RSpec\n\nfrom a functionality stanpoint, Minitest can do eveyrthing Respec can, except Minitest uses a more straight forward syntax.  RSpec bends over backwards to allow developers to write code that reads like english.  RSpec is what we vall a **Domain Specific Language**; it's a DSL for writitng tests.\n\nRSpec uses a syntax called *expectation* or *spec-style* syntax.\n\nin expectation style, tests are grouped into `describe` blocks, and individual tests are written with the `it` method.  we no longer use assertions and instead use **expectation matchers**. example:\n\n```ruby\nrequire 'minitest/autorun'\n\nrequire_relative 'car'\n\ndescribe 'Car#wheels' do \n  it 'has 4 wheels' do \n    car = Car.new\n    car.wheels.must_equal 4    # this is the expecatation \n  end \nend \n\n```\n\n\n### SEAT approach\n\nin larger projects there are usually 4 steps to wrting a test:\n\n1. Set up the necessary objects\n2. Execute the code against hte object we're testing\n3. Assert the resutls of the execution\n4. Tear down and clean up any lingering artifacts\n\nThis is called the SEAT approach and looks like this:\n\n```ruby\nrequire 'minitest/autorun'\nrequire_relative 'car'\n\nclass CarTest < MiniTest::Test\n\n  def setup\n    @car = Car.new\n  end\n  \n  def test_car_exists\n    assert(@car)\n  end\n  \n  def test_wheels\n    asssert_equal(4, @car.wheels)\n  end\n  \n  def test_name_is_nil\n    assert_nil(@car.name)\n  end\n  \n  def test_raise_initalize_with_arg\n    assert_raises(ArgumnetError) do \n      Car.new(name: \"Joey\")\n    end\n  end\n  \n  def test_isntace_of_car\n    assert_instance_of(Car, @car)\n  end\n  \n  def test_includes_car\n    arr = [1, 2, 3,]\n    arr << @car\n    assert_icludes(arr, @car)\n  end\nend\n```\n\nNOte that in the `setup` method, we must now use an instance variable `@car`.  We can't use a local variable in `setup`, becuase the tests, which a just instance methods, won't have access.  \n\nthe `setup` method will be called before running every test, and the `teardown` method (which we don't have) will be called after running every test.  In our case we don't have any tear down activity, so it's not necessary.  In some cases, we will need a tear down for cleaning up files or loggin soem information, or clsing database connections\n\nIn the simpliest cases, we won't need either set up or tear down, but just keep in mind that there a 4 stesp to running any test, an it is SEAT.  At the minium you'll need EA even if the E is just a simple object instatiation. \n\n### Assertions \n\n`assert_equal` is the most common assertion, and we can get pretty far only using that. \n\nBut there are times when we need to make differnt types of assertions.  if you feel liker there should be an assertion for something, make sure to look up the [full list of assertions](http://docs.seattlerb.org/minitest/Minitest/Assertions.html)\n\n| **Assertion** | **Description** |\n|---|---|\n|assert(test) |  Fails unless `test` is truthy |\n|assert_equal(exp, act) | Fails unles `exp == act` |\n|assert_nil(obj)  |  Fails unless `obj` is `nil` |\n|assert_raises(*expression){ ... } | fails unless block raise one of `expression`|\n|assert_instance_of(cls, obj) | Fails unless `obj` is and instance of `cls`|\n|assert_includes(colleciton, obj) | Fails unless `collection includes` `obj`|\n\nlets look at using the above asertions with an example.\n\n```ruby\nclass Car\n  attr_accessor :wheels, :name\n  \n  def intialize\n    @wheels = 4\n  end\nend\n```\n\n1. `assert`\n\n```ruby\ndef test_car_ exists \n car = Car.new \n assert(car)\nend\n```\n2. `assert_equal`\n\ndef test_wheels\n  car = Car.new\n  assert_equal(4, car.wheels)\nend\n\n3. `assert_nil`\n\n```ruby\ndef test_name_is_nil\n  car = Car.new\n  assert_nil(car.name)\nend\n```\n\n4. `assert_raises`\n\n```ruby\ndef test_raise_initlize_with_arg\n  assert_raises(ArgumentError) do \n    car = Car.new(name: \"Joey\")  # this code raises ArgumentError, so this assertion passes\n```\n5.  `assert_instance_of`\n\n```ruby\ndef test_instance_of_car\n  car = Car.new\n  assert_instance_of(Car, car)\nend\n```\n\n6. `assert_includes`\n```ruby\ndef test_includes_car\n  car = Car.new\n  arr = [1, 2, 3]\n  arr << car\n  \n  assert_includes(arr, car)\nend\n\n# assert_includes calls assert_equal in its implemntaiton, and Minitest counts that callas a seperate asseriton.  FOr each assert_includes call, you will get 2 assertions, not 1. \n```\n#### Testing Equality\n\nWith `assert_equal` we are testing for value equality. specifically we're invoking the `==` method on the object. If we're looking for more strict **object equality** then we need to use the `assert_same` assertion. \n\n#####Equality with a custom class\n\nBecause the Ruby core library classes all implemtn sensible `==` to test for value equality, we can get away with using `assert_equal` on strings, arrays, hashes etc. But what happesn if we try to use `assert_equal` on our own custom classes?\n\nThe answer is we have to tell Minitest how to compare those objects by impolementing our own `==` mehtod.  This means that in our base code, for esample the code where we define the `Car` class we must provide an `==` method\n\n```ruby\nclass Car\n  attr_accessor :wheels, :name\n  \n  def initialize\n    @wheels = 4\n  end\n  \n  def ==(other)\n    other.is_a?(Car)  && name == other.name\n  end\nend \n```\n\n#### REfutations\n\nrefutations are the opposite of assertions. that is, they refute rather than assert. Every assertion has a corresponding refutation.  for example, `assert`'s opposite is `refute`.\n\n`refute` passes if the object you pass to it is falsey.  Refutations all take the same arguments, except it's dong a **refutation**.  examples:  `refute_equal`, `refute_nil`, `refute_includes` etc\n\n\n### code coverage\n\ncode coverage is one metric to gauge test quality \n\n`simplecov` gem is a tool for testing code coverage\n\nall you need to do to use it is `gem install simplecov`\n\nNext put this at the to of the test file\n\n```ruby\nrequire 'simplecov'\nSimpleCov.start\n```\n## Core Tools/Packaging Code\n\n#### purpose of core tools\n\nRuby tools\n##### rubygems: \nthese are packages of code that you can download, install an dyse in your ruby programs or from the command line.  there are thousands of gems, you may already be familar with some of them:\n -rubocop\n -pry\n -sequel\n -rails \nthese are all gems.\n\nrun `gem install GEM_NAME` to install a gem.  `gem` places the Gem on your local file system in a location where ruby and your system can find the files and command it needs.  This location is the local lihbrary. \n\n`gem env` will tell tell you where your gems are being saved\n\n### rvm and rbenv\n\n**RUby version managers** are programs that let you install, manage, and use mutliple verisons of Ruby.  Eventually you will write or use a RUby program that needs a different version of Ruby, that's whe you find taht you need a Ruby version mangaer.\n\nAnother reason to use to use Ruby version managers is when working on mutliple applicaitons, which require different versions of ruby. \n\nRVM and rbenv are both ruby version managers. RVM and rebenv are similar in function. By default RVM has more features but rbenv plugins provide much of the functionality not porvided by the base install of rbenv. RVM works by dynamically managing your environment, mostly by modifying your `PATH` Variable and replacing the built--in `cd` command with an RVM-aware shell function; rbenv works by just modifying your `PATH` and some other enviroment variables. \n\n####RVM\n\nRVM's core is a set of directoriews in which RVM stores all your Ruby verisons, its associated tools(such as `gem` and `irb`. each directory is specific to a given Ruby verions,.  If you need RUby 2.31. RVm uses th efiles iin the Ruby-2.3.1 directory.  If you need Ruy 2.2.2 it gets the files from the `ruby-2.2.2` directory.  Note that standard ruby executables are found in the `rubies` subdirectory of RVM's main directory, while Gems are found in the `gems` subdirectory.  Note also that Gem verion numbers can differ between Rubies. \n\n\n####rbenv\n\nat rbenv's heart is a set of directories very similar to the directories at RVM's core.  It sores and uses the rubies associated tools, and Gems from these directories.  There are subdirectories for each version of Ruby located in the `versions` directory.  If you need Ruby 2.3.1, rbenv uses the files in the 2.3.2 directory.\n\nDiffering form RVM, rbenv uses a set of small scripts called **shimes**.  The scripts have the  same names as the various ruby and Gem programs.   They live in the `shims` sub-directory of the main rbenv installation directory. rbenv installations invlude the `shims` directory in the `PATH`; RBENV PLACIES IT before any other directories that contain ruby or any related programs; this ensures that the system seraches the `shimes` directory first.  This way, when you run one of the ruby commads or Gems, the system exectures the proper shim script.  The shim script in turn executes `rbenv exec PROGRAM`; this command determines what version of Ruby it should use, and executes the apprpriate prgrame from the RUby version-specific direcotries. \n\n###  bundler\n\nsummary:\nbundler lets you describe exactly which RUby and Gems you want to use with your RUby apps.  Specifically it lets you install multopel versions of each Gem under a specific verion of RUby then us the proper version in your app. Bunlder is a RUBY GEm, so you must instlall it like anormal Gem: `gem install bundler`.\n\nto use bundler, you rpovde a file name `Gemfile` that describes the Ruby and Gem versions you want for your app.  You use a DSL descibed on the bundler wesite ot provide this information.  Bundler uses the `Gemfile` to gnerate a `Gemfil.lock` via the `bundle install` command. `Gemfile.lock` descirbes the actual versions of each Gem that our app needs, including any gems that the gems listed in `Gemfile` depdn on.  the `bundler/setup` package tells your ruby program to use `Gemfile.lock` to determine which Gem versions it should load. \n\nthe `bundle exec` cmmand ensures that eh executable programs installed by Gems dont' interfere with your app's requirements.  For instance if your app needs a specific version fo `rakw` but eh dfualt version of `rake` differs `bunlde exec` sneures that you can sitll run the specific `rake` version compatible with your app. \n\nDealing with dependencies -- mutliple verison of Ruby and multiple verison of Gems, is a significant issue in RUBY.  A project may need a Ruby version that differs from your default Ruby.  Even if it requires the same verions of Ruby, it may need a different verision of RubyGem.\n\nbundler relies on a `Gemfile` to tell which version of Ruby and its Gems it should use.  This file is a simple Ruby programe that uses a Domain Specific Langauge (DSL) to provide details about the Ruby and Gem versions. \n\nAfter you create `Gemfile`, the `bundle install` command scans it, downlaods and installs all the dependencies listed and proces a `Gemfile.lock` which shos all the dependcies for you program; this includes the Ges listed in the `Gemfile`, as well as thte Gesm they depend on which may not be explciitly listed in the `Gemfile`.\n\nonce Bundler creast your `Gemfile.lock` add:\n\n```ruby\nrequire 'bundler/setup'\n```\n\nto the beginning of your app before any other Gems.\n\n`bundler/setup` first removes all Gem directories from the Ruby's `$LOAD_PATH` global array. Ruby uses `$LOAD_PATH` to list the directories that it serches whe it needs to locate a required file.  When `bundler/setup` removes those directories form `$LOAD_PATH` ruby can no longer find Gems. \n\nTo fix this, `bundler/setup` reads `Gemfilel.lock`; for each Gem listed it adds the directory that contains the Gem back to `$LOAD_PATH`  when finished, `require` only finds the proper verions of each Gem.\n\nbunlder does not interfere with the original locaitojn of your RUbies nor their Gems. \n\n`bundle exec`.  Using `bundle exec` with `bundle exec rake`.  we use it to resolve dependency conflicts when issuring shell commands.  From time time you may encounter an error message like this:\n\n```ruby\nGem::LoadError: You have already activated rake 11.3.0, but your Gemfile requires rake 10.4.2. Prepending `bundle exec` to your command may solve this.\n```\n\nall you have to do to correct this is run `bundle exec rake`\n\n\n\n### rake \n\nrake is a rubygemt that automates many common functions required to build, test, package, and install programs;  it is part of every modern Ruby installation, so you don't need to install it yourself. \n\nhere are some comomon Rake tasks that you may encounter:\n\n- set up required environment by creating directories and files\n- set up and intiaalize databases\n- run tests\n- package your application and all of its files for distribution\n- install the applicaiton\n- perform common git taks\n- rubuild certian file sand directories (assets) based on changes to other files and directories\n\n\n####how to use rake\n\nRake uses a file named `Rakefile` that lives in your progject direcotyr;  This file describes the taks that Rake can perform for your project, and how to peform those taks. \n\n```ruby\ndesc 'Say hello'\ntask :hello do\n  puts \"Hello there. This is the `hello` task.\"\nend\n\ndesc 'Say goodbye'\ntask :bye do\n  puts 'Bye now!'\nend\n\ndesc 'Do everything'\ntask :default => [:hello, :bye]\n```\n\nRake runs the default taks if you do not provide a specific task name when you invoke Rake. \n\nthe first thing you should do with nay Rake file is find out what taks it can run.  Do this with `rake -T`\n\n```ruby\nbundle exec rake -T\nrake bye   # say goodbye\nrake default # Do everything\nrake hello # say hello\n\n````\n\nthis shows there are three taks defined by the `Rakefile`: `bye`, `default`, and `hello`. The output shows a short desciption of each task on the right: this information comes from the `desc` method calls in `Rakefile`. \n\n`Rakefile` is actually a ruby program.  You can put any RUby code you want in a `Rakefile` and run it as part of a task.  Commands like `desc` and `task` are just method calls to part of Rake;  These method calls comprise a DSL for writitng automated Rake tasks. \n\nyou can run Rake tasks like below\n\n```ruby\nbundle exec rake bye\nBye now!\n```\n\nyou can use rake to automate repetitive task such as.\n\n- run all tests associated with the program\n- increment the version number\n- create your release notes\n- make a complete backup of your local repo.\n\n#### Gemfiles\n\ngemfile looks like this\n\n```ruby\nsource 'https://rubygems.org'\n\nruby '2.3.1'\ngem 'sinatra'\ngem 'erubis'\ngem 'rack'\ngem 'rake', '~>10.4.0'\n\n```\n\n#### relationships of ruby tools \n\nyou ruby version managager is a top leve -- it controls mutliple installations of RUby and all the other tools\n\nwihtin each insstalllation of ruby you can have mutliple gems. each gem becomes accessible to the ruby version under which it is installed.  If you want to run a fewm in multiple verison of Runy, you need to install it in all of the versions you want to use it with.\n\neach Gem in a ruby installation can itself have multiple versions.  This frequietly occurs naturally as you install updated Gems, but can also be a reqiurment; somtimes you just need a specific version of  a Gem for one project, but want to use another version for your other projects. \n\nthe bundler prgogram is a gem that is used to manage the Gem dependencies of your projects.  that is it determines and controls the RUby version and Gems that your project uses, and attempts to ensure that the proper items are installed and used when you run the program.\n\nFinally, Rake is another Gem.  It isn't tied to any one RUby project, but is, instead a tool that you use to perform repetitive development tasks, such as running test, building databases packaging and releasing the software etc.  The taks that Rake performs are varied and frequently change form one project to anotherl you use the `Rakefile` fiel to control which taks your project needs. \n"
    }
  ]
}