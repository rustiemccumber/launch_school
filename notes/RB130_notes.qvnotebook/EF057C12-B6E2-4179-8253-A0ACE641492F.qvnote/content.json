{
  "title": "RB_130 Course Notes",
  "cells": [
    {
      "type": "markdown",
      "data": "\n<details><summary>Closures in Ruby</summary>\n\n\na **closure** is a general programming concept that allows programmers to save a \"chunk of code\" and execute it at a later time.  It's called \"closure\" because it's said to bind its surrounding artifacts (ie, variables, methods, objects, etc)  and build an \"enclosure\" around everything so that htey can be referenced when the closure is later executed.  It's sometimes useful to think of a closure as a method that you can pass around and execute,  but it's not defined with an explicit name. Different programming languages implement closures in different ways.  Some languages will have first class support for it, while other langauges won't deal with it at all.\n\nIn Ruby a closure is implemented through a `Proc` object, a lambda, or a block. That is we can pass around these items as a \"chunk of code\" and execute them later. \n\nThe only thing to remember is that this \"chunk of code\" retains references to its surrounding artifacts -- its binding.\n\nThere are three main ways to work with closure is Ruby:\n\n1. instantiating and object from the `Proc` class\n2. Using *lambdas*\n3. Using *blocks*\n\n</details>\n\n<details><summary> Calling Methods with Blocks</summary>\n\nBlocks are so pervasive in RUby that it's almost certain you've not only read code containing blocks, but you've probably writtten blocks youself.  For example:\n\n```ruby\n[1,2,3].each do |num|\n  puts num\nend\n```\nif you've ever written any code with a `do ... end` or `{ ... }`, then you've written blcoks before.  You probbaly didn't know or care to much about the details, only that when you invoked the `each` method on an array or collection, you have to include the magical `do ... end ` or `{ ... }` sequence after it.  Somehow, things just worked.  Let's take a closer look at that familiar code. \n\nThe object we're working with is the collection or `Array` object:\n\n```ruby\n[1, 2, 3]\n```\nThe metho dwe're calling on that object is the `Array#each`:\n\n```ruby\n.each \n```\n\nthe part that's a block is the `do ... end` part:\n\n```ruby\n              do |num|\n  puts num\nend \n```\nIt's important to be able to take aprat the simple code at the top of this assignment into the 3 pieces outlined above.  Sometimes the block of code is quite large.  Don't let that confuse you -- the method being called is still ```Array#each```  (in this case).  THe block is an argument to the method call.  In other words, our familiar method `[1,2,3].each { |num puts num}` is actually passing in the block of code to the `Array#each` method.  \n\n\nwhat can you do wihtin a blcok?\n\nFirst, let's take a look at a few places where blocks are commonly used.\n\n```ruby\n# Example 1: passing in a block to the `Integer#times`\n\n3.times do |num|\n  puts num\nend \n=>  3\n\n# Example 2:  passing in a block to the `Array#map` method.\n\n[1, 2, 3].map do |num|\n  num + 1\nend\n=.  [2, 3, 4]\n\n#  Example 3:  passing in a block to the `Hash#select` method.\n\n{ a: 1, b: 2, c: 3, d: 4, e: 5}.select do |_, value|\n  value > 2\nend\n\n=>  { c: 3, d: 4, e: 5}\n\n```\n\nThis is obviously not an exhaustive list, but look at the examples carefully, and specifically look at 1) the code written in the blocks, and 2) the return value of the mehtod invocaitons.  In the Example 1, invoking the `Integer#times` method returns the calling object (in this case, it's just `3`)  completely ignoring what we wrote in the block.  In example 2,  the treturn value of calling `Array#map` is a new array, with the values manipultaed according to our blcok code.  In Example 3, the return value is a new hash object `{c: 3, d: 4, e: 5}`.  Why is it that sometimes the code in the block affects the return value and sometimes ot?\n\nThe answer lies in how each of those methoddds are implemented.  Remember that the code we wrote in the block is not the method implementation -- in fact, that code has nothing to do with the method implemenation.  The entire block is **passed in** to the method like any other argument, and it's up to the method implemenation to decide what tod ow with the block, or chunk of code, that you passed in.  The method could take that block and execute it, or just as likely, it could competely ignore it -- it's up to the method implemenation to decide what to do with the block of code given to it \n\n</details>\n\n<details><summary> Writing Methods that take Blocks</summary>\n\nBelieve it or not, every mehtod you have ever written in Ruby already takes a block.  Let's implent a simple method.\n\n```ruby\ndef hello\n  \"hello!\"\nend\n\nhello   # \"hello!\"\n\n```\n\nLet's try to call it with some parameters\n\n```ruby\nhello(\"hi\")  # =>  ArgumentError:  wrong number of arguments (1 for 0)\n```\nThis doesn't work, because the `hello` method isn't expacting any parameters, what if we called it with a block?\n\n```ruby\nhello { puts 'hi'}   # => \"hello!\"\n```\n\nThat is unexpected!  ISn't passin gin a blcok to a method just like passin in any other parameter?  Not quite.  In Ruby, every mehtod can take an optional block  as an implicit parameter.  You can just tack it on at the end of the method invocation, just like we did above when calling the `hello` method.  Here are a couple more examples where the method definition takes parameters.\n\n```ruby\ndef ehco(str)\n  str\nend\n\necho           # => ArgumentError: wrong number of arguments (0 for 1)\n\necho(\"hello!\")   # => \"hello!\"\n\necho(\"hello\", \"world!\")  #=>  ArgumetnError: wrogn number of arugments (2 for 1)\n\n#  this time, called with an implicit block\n\necho {puts \"world\"}  # =>  ArgunmentError: wrong number of arguments (0 for 1)\necho(\"hello!\"){ puts \"world\"}   #=>  \"hello!\"\necho(\"hello\", \"world!\"){ puts \"world\"}  # => ArgumentError: wrong number of arguments (2 for 1)\n\n\n```\n\nIt's almost as if the block wasn't even being passed to the mehtod.  How can we be sure athat the method actually has acess to the blcok?\n\n###Yielding\n\nOne way that we can invoke the passed-in block argument from within the method is by using the `yield` keyword.  Let's modify our `echo` method implemenation and yield to the block.\n\n```ruby\ndef echo_with_yield(str)\n  yield\n  str\nend\n```\n\nLet's run the smae three examples from earlier on this new method, and see its behavior\n\n```ruby\necho_with_yield { puts \"world\" }   # => ArgumentError:  Wrong number of arguments (0 for 1)\n\necho_with_yield(\"hello!\") { puts \"world\"}     # => \"hello!\"\n\necho_with_yield(\"hello\", \"world!\") {puts \"world\"}   #=>  ArgumentError:  wrong number of arguments (2 for 1). \n```\nNotice the first method call and the last method call generated errors.  The second method call -- the one with a string parameter as well as a block  -- did what we expected.   That is, it printed out the string `\"world\"` and then returned the stirng `\"hello!\"`.  Seeing these results tells us two things:\n\n1.  The number of arguments at method invocation needs to match the method defiition, regardless of whether we are passing in a block.\n2.  The `yield` keyword executes the block.\n\nThe first point shouldn't be a surprise;  this is old news and noething new.  The second point should get you excited.  This means that when you read a methods's implemenation, that's no the end of the story.  If your method implementation contains a `yield`, a developer using your mehtod can come in after this method is fully implmented and inject additional code in the middle of this mehtod (without modifying the method implemenation), by passin gin a block of code.  This is indeed one of the major use cases of using blcks, which we'll talk more about later.\n\nBefore we play around with a few more examples, let's take a look at a common edge case.  Let's continue using out `echo_with_yield` method from above, but we're now calling it like this:\n\n```ruby\necho_with_yield(\"hello!\")  #=>  LocalJumpError: no block given (yield)\n\n```\n\nThis may be the frist time you've seen `LocalJumpError`.  It's an oddly named error, it's not obvious wha tthat means, but reading the error message makes it celar: no block given (yield).  If you ever see the error message, you should guess that the method implemenation has a `yield` in it somewhere, but we didn't include a block at mehtod invocation.  That's exactly the case here.\n\nIn order to allow calling the method with or without  block, we must somehow wrap the `yield` call in a conditional: only call `yield` when a block is passed to th emethod and don't call `yield` when there's no block.  We can achieve this with the `Kernel#block_given?` method.  And because it's in `Kernel`,  It's available everywhere.  Let's modify out `echo_with_yield` implementation:\n\n```ruby\ndef echo_with_yield(str)\n  yield if block_given?\n  str\nend\n```\nNow, we can call `echo_with_yield` with our without a block.  If a block is passed in the `block_given?`  will be ture, and out code will `yield` to the block (ie, execute the block of code).  If a block is not passed in, the `block_given?`  will be false, and the only thing the mehtod will do is return `str`.\n\n```ruby\necho_with_yield(\"hello!\")   # => \"hello!\"\necho_with_yield(\"hello!\") {Puts \"world\" }  # world\n# =>  \"hello!\"\n```\n\n###Passing exectuion to the block\n\nWe're now ready to exaimine more closly the sequence of code execution when yielding to a block.  Let's come up with a new example: \n\n```ruby\n# mehtod implementation\ndef say(words)\n  yield if block_given?\n  puts \"> \" + words\nend\n\n#method invocation\nsay(\"hi there\") do \n  system 'clear'\nend                 # clears screen first, then outpus \"> hi there\"\n```\n\nBefore we can trace the code execution, we have to be clear that the `def say...` code is the method implemenation, and the `say...` code is the method invocaiton.  There is only one method here: `say`.  Sometimes, when we're passing in a block of code, the method invocation can contain more code than the method ***implemenation***, wheich maks it easy to confuse the two -- don't get mixed up by this.\n\nOnce that's clear, we can start tracing the code execution:\n\n1.  Execution starts at method invocation, on line 8.  The `say` mehtod is invoked with two arguments: a string and a block (the block is an implicit parameter and not part of the method definition.   \n2.  Execution goes to line 2,  where the method local variable `words` is assigned to the string `\"hi there\"`.  The block is passed in implicitly, without being assigned to a variable. \n3.  Execution continues into the first line of the method implemnation, line 3, whcih immediately yields to the block.\n4.  The block, line 9, is now executed, which clears the screen.\n5. After the block is done executing, execution continues in th emethod implementation on line 4.  Executing line 4 results in output being displayed.  \n6. THe method ends which means the last expression's value is returned by this method.  The last epxression in the method invokes the `puts` method, so the return value for the method is `nil`.\n\njust to quickly retrace our steps, execution went like this:\n\n```ruby\nline 8 -> line 2 -> line 3 ->  line 9- > line 4 -> line 5\n```\n\nNotice the jump after line 3:  execution jumps to somwhere else, then comes back to finish the rest of the method.  this is very similar to calling a mehtod, except here we're calling a block.  This is why it's sometimes useful to think of a block ans and un-named or anonymous method.  If you had troule tracing the code executioj flow in the above example.  Makke sure to read through the steps carefully agin, and play with the example on your own. \n\n### Yielding with an argument\n\nsometimes, the block we pass in to a method requires an argument.  Note that the block itself is an argument into a method, so the fact that **the block** requires an arugment adds an additional layer of complexity.  But you've already been writing blcos that take and argument for a long time. for examp:\n\n```ruby\n3.times do |num|\n  puts num\nend\n```\n\nThis should be pretty familiar Ruby code by now.  We'll take it apart below.\n\n```ruby\n3\n```\n\nThe `3` is the calling object.\n\n```ruby\n.times\n```\n\nThe `times` is the method being called. \n\n```ruby\n              do |num|\n      puts num\n  end\n```\n\nAnd the `do ... end` is the block.  The `num` variable betwen the two `I`'s is a parameter for the block, or , more simply, a block parameter.  Within the block, `num` i sa **block local variable**.  This is a special type of local variable where the scope is constrained to the block. \n\nIt's important to make sure the blck parameter has a unique name and doesn't conflict with any local variables outside the scope of the block.  Otherwise, you'll encounter **variable shadowing**.  Shadowing makes it impossible to access the variable defined in the outer scope, which is usually not what you want. \n\n\nLet's write our own method that takes a block with an argument.  Suppose we want to write a method called `increment`  that takes a number as an argument, and returns the argumnet incremented by 1.  At implementation time, we don't want to output the incremented number, bcause we aren't sure how users will use this method.  The only thing we can be sure of is that the method should take and argument and return the argument plus 1. \n\n```ruby\n# method implementation\ndef increment(number)\n  number + 1\nend\n\n# method invocation\nincrement(5)   # => 6\n```\n\nsimple!  the method invocation returns `6`.  But we want to allow users to possibly take some action on the newly incremented number at method invocation time.  Fore example maybe some users want to prit it out or otherss want to log it to a file, or send it to Twitter.  We want to allow for some flexibility atthe mehtod uusage or invocaiton tie.  Blocaks are perfect for this. Let's update the implemenation to yield to a block, and pass in the incremented number into the block. \n\n```ruby\n# method implemnation \ndef increment(number)\n  if block_given?\n    yield(number + 1)\n  end\n  number + 1\nend\n\n# mehtod invocation\nincremetn(5) do |num|\n  puts num\nend\n```\n\nThe above method invocation outputs `6`.  Ntoice the use of `block_given?`, which allows us to continue to call th emethod without a block.  Let's trace the code execution in the above vode snippet. \n\n1.  Execution starts at method invocation on line 10.\n2.  Execution moves to the method implemenation on line 2, which sets `5` to the local variable `number` and the block is noot set to any variable; it's just implicitly available.\n3.  Execution continues on line 3, which is conditional\n4.  our method invocation has indded passed in a passed in a block, so the conidtional is ture, moving execution to line 4.\n5.  On line 4, execution is yieled to the block (or the block is called). and we're passing `number +1` to the block. this measn we're calling thhe block with `6` as the block argument.\n6.  execution jimps to line 10 where the block local variable `num` is assigned `6`.\n7.  Execution conintinues to line 11 wehre we ouput the block local variable `num`. \n8.  Execution continues to line 12, where the end of the blck is reached.\n9.  Execution no jumps back to th emethod implemeantion, where we just finished executing line 4.\n10.  Execution tontues to line #5, the end of the `if`.\n11.  Line 6 returns the value of the incremented argument to line 10.\n12.  The program ends (the return value of `#increment` is not used)\n\nThe squence of execution looks something like this:\n\n```ruby\nline 10 ->  line 2 -> line 3 -> line 4 -> line 10 -> line 11 -> line 12 -> line 5  -> line 6 -> linr 10 -> program ends\n```\n\nonce again, calling ablcok is almost like calling another mehtod.  In this case we're even passing and an argument to the block, just like we could aor any normal method. \n\nNow that you understand how passing an argument to a blcok works, mayb you're thinking \"what would happen if I passed in the wrong number of argument sto a block?\"  Would Ruby rais an `ArgumentErro`?\n\n```ruby\n# method implementation\ndef test\n  yield(1, 2)    # passing 2 block arguments at block invocation time\nend\n\n# method invocation \ntest {  |num| puts num }  # expecting 1 in block implementation parameter\n```\n\nsuprisingly the above code outpus `1`.  The extra block argument is ignored!  What if we pass in less block argument, instead of passing in 1 more?\n\n```ruby\n# method implemenation\ndef test\n  yield(1)     # passing 1 blcok argument at block invocation\nend\n\n#method invocaiton\ntest do |num1, num2|    # expecting 2 parameters in block implemnation\n  puts \"#{num1} #{num2}\"\nend\n```\n\neven more surpsigingly this also outputs `1`.  But this output is different form the previous one.  In this case, `num2` block local variable is `nil`, so the string interpolation converted that to an empty string, which is why we get `1`  (there's and extra space).\n\nThe rules regarding the number of arugments that you can pass to a block, `Proc`, or `lambda` in RUby is called its *arity*.  In Ruby, blocks have lenient arity rules, which is why it doesn't complain when you pass in different number of arguments; `Proc` objects and `lambda`s hae different arity rules.  For now, don't worry too much about this, but just realize that blocks don't enforce argument count, unlike normal methods in Ruby.  You'll forget this rule in a few minutes;  That's ok, just remember to open up `i`b or your eidtor and play around with it to refresh your memory\n\n### Retune value of yielding to th eblock \n\nsuppose we want to wrte a mehtod that outputs the before and after of mainpulating the argument to the method.  For example, we'd like to invoke a `compare` method that does this:\n\n```ruby\ncompare('hi') { |word|  word.upcase ]\n\n# OUTPUT:\n# BEFORE:  HI\n# AFTER: HI\n```\n\nLet's implement it. \n\n```ruby\n  def compare(str)\n    puts \"Before: #{str}\"\n    after = yield(str)\n    puts \"After:  #{after}\"\n  end\n  \n# method invocation\ncompare('hello') { |word|  word.upcase }\n```\nthe output from the method invocation is:\n\n```ruby\nBefore: hello\nAfter: HELLO\n=> nil\n```\n\nFrom the above example, you can see that the `after` local variable in the `compare` method implementation is assigned the **return value from the blcok**.  This is yet another behavior of blocks that's similar to normal methods:  They have a return value, and that return value is determined based on the last expression in the blcok.  This implies that just like normal methods, blocks can either mutate the argument with a destructive method call or the block can return a value.  Just like writing good normal methods, writing good blocks requires you to keep this distinction in mind.  Note that the last line, `=> nil`, is the return value of the `compare` method, and isn't related to what we're doing in th eblock.  The last expression in the `compare` method is a `puts`, and therefore the return value of calling `compare` is always `nil`.\n\nWe could further call this `compare` method with a variety of different implemenations.\n\n```ruby\ncompare('hello') { |word|  word.slice(1..2) }\n\n# Before: hello\n# After: el\n#  =>  nil\n```\n```ruby\ncompare('hello') { |word| \"nothing to do with anything\"}\n\n# Before: hello\n# After:  nothing to do with anything\n# => nil \n```\n\nIn the above two examples, pay attention to the return value from the block. That's what the `compare` method implemenation is relying on to display in the \"After\" scenario.  Once you understand the basic use case of our `compare` method, let's study a slightly trickier example.\n\n```ruby\ncompare('hello') { |word| puts \"hi\"}\n\n# Before: hello\n# hi\n# After:\n# =>  nil\n```\n\ncan you figure out why the output looks a  little different?  Hint: when you include `nil` in string interpolation, it evaluates to empty string.\n\n### when to use block in your own methods\n\nThere are many ways that blocks can be useful, but the two main use cases are:\n\n1. Defer some implementation code to method invoation decision.\n\n  There are two roles involced with any mehtod: the *method implementor* and the *method caller* (note that this could be the same person/developer).  There are times when the method implementor is not 100% certain of how th emethod will be called.  Maybe the method implementor is 89% certain, but wants to leave that 10% decision up to th emethod caller at method invocation time.\n  \n  Let's first talk about life without blocks.  Without blocks.  The method implentor can allow method callers to pass in some flag.  For example, take out `compare` mehtod above, Suppose we don't use blocks.  We can stil avhieve similar funcionality, like this:\n  \n  ```ruby\n    def compare(str, flag)\n      after = case flag\n              when :upcase\n                str.upcase\n              when :capitalize\n                str.capitalize\n              # etc, we could have alot of 'when' clauses\n              end\n      puts \"Before: #{str}\"\n      puts \"After: #{after}\"\n    end\n    \n    compare(\"hello\", :upcase)\n    \n    # Before: hello\n    # After:  HELLO\n    # =>  nil\n  ```\n  \n  But this isn't nearly as flexible as allowing method callers a way to **refine** the method implemenation, without actually modifying the method implementtion for every one else.  By using blocks,  the method implementor can defer the decision of which flags to support and let th emethod caller decide at method invocation time. The method implementor is syaing \"hey, I don't know what the specifics of your scenario are, so just pass thme in when you need to call this method.  I'll set it up so that you can refine it later, since you understnad your scenario better.:\n  \n  Many of the core library's most useful methods are usefule precisely because they are built in a generic sense, allowing us (the method callers) to refine the method through a block at invocation time.  For example,  tak the `Array#select` method.  We love the `select` method because we can pass in any expression that evaluates to a boolean in the block parameter.  Imagine that instead of a flexible `select` method, we had `select_odds` or `select_greater_than(num)`.  The latter methods would still work, but not be nearly as flexihble and we'd have t memorie all the method names for that specific scenario.  Instead, the `select` method is built in a generic way, allowing us (the method callers) to pass in the refinement to the method implementation.\n  \n  If you encounter a scenario wheer you're calling a method from mulitple places, with one little tweak in each case, it may be a good idea to try implementing the method in a generic way by yieldin to a block.\n  \n2.  Methods that need to perform some \"before\" and \"after\" actions - samdwich code.\n\n  Sandwich code is a good example of the previous point about deferring implmentation to method invocation.  There will be times when you want to write a generic method that performs some \"before\" and \"after\" action.  Before and after what?  That's exactly the point -- The mehtod implementor doesn't care: before and after **anything**.  \"et's explore and example.  Suppose we wasnt to write a method that outputs how long **something** takes.  OUr mehtod doesn't care what that something is; our method just cares about displaying how long it took.  The outline of our method could look like this:\n  \n  ```ruby\n    def time_it\n      time_before = Time.now\n      #do somehting\n      time_after = Time.now\n      \n      puts \" it  took #{time_after - time_before} seconds.\"\n    end\n  ```\n  \n  The question for the method implentor is:  what do we fill in for \"do something\"?  The answer is: nothing.  As the method implementor, we don't care waht code goes there.  The responsibiity for our mehtod starts and stops at timing the action.  Without regard to wha thte actual action is.  This is a good us case for blocks.  Using blocks, we can alllow mehtod callers to specify any action, and us our method to time that action.  Let's update the method implemantion to yield to the block\n  \n  ```ruby\n  def time_it\n    time_beofre = Time.now\n    yield       # execute the implicit block\n    time_after = Time.now\n    \n    puts \"It took #{time_after = time_before} seconds.\"\n  end\n  \n  time_it { sleep(3) }    # It took 3.003767 seconds                 # => nil\n  \n  time_it { \"hello wordl\"}    #It took 3.0e -06 seconds.\n  # => nil\n  ```\n  \n  THe `sleep` mehto there just pauses execution for however many seconds you pass in. You can see that our `time_it` method does exactly what we want:  it times the code passed in to it.  In order to time it, we need to capture the time bore execution, then compare it with the time after execution.  There are many useful use cases for \"sandwich code\".  Timing, loggin,g notification systems are all examples where before/after actions are important. \n  \n  Another area where beofre/aftre actions are importnat is in reosuce akajfame, or interfacing with theopeating system.  Many Os intefaces rquire you, the developer, to first allocate  aportion of a resource,  the peform some clean- up for free up that resource.  Foregetting do the clean-up can result in a dramatic buggs-- system crasheses, memory leaks, file system ocrruption.  Wouldn't i the great if can uautomate this clean - up?\n  \n  this is eaclty what the `Fiiel::opn` mehtod does for us.  For example, the typicl example for opening a file in Ruby is:\n  \n  ```ruby\n    my_file = File.open(\"some_fiie.txt\", \"w+\")\n    # write to this file using my_file.write\n    my_file.close\n  ```\n  \n  That last line closes the file and releases the `my_file` object orm hangin on to system resources --- specifcallly the blok \"some_file.txt\".  Since we always want to close files, `FILE.::OPEN` CAN ALSO TAKE  ABLOCK, AND WILL AUTOMATICALLY CLOSE THE FILE AFTER THE BLOCK IS EXECUTED USIN THE BLCOK SYNTAX, WE CAN DO THIS:\n  \n  ```ruby\n  File.open(\"some_file.txt\". \"w+\") do |file|\n     # write to this file using file.write\n  end\n  \n  ``` \n  \n  Why is it that we don't have to closd the file?  Without understnadinghow blocks work, it's not obvious what the magic is.  But  now that you understnad how yield workds, you can guess that the method implementor of `File::open` opens the file, yields to the block, and then closes the file.  This means the method caller only needs to pass in the relevant file maniplation code in  the block withou worrying about clossing the file. .\n  \n### Methods with an eplicit block parameter\n  \n  TH last topic we want to discuss is passing a block to a method explcitly.  UNtil now, we've passed blocks to methods implicity.   Everyt method, regardless of its definitio, taks an implicit block.  It mya ignore the implicity block, but it still accepts it.  Howeer, ther are timews when you want a method to take an explicit block; you do that by defining a parameter prefeix `&` character in the mehtod definiton:\n  \n  ```ruby\n    def test(&block)\n      puts \"what's &block? #{block}\"\n    end\n  ```\n  \n  Whoa, that looks a bit odd.  The `&block` is a special parameter that converts the block argument to what we call as \"simple\" `Proc` object (the exact definiton of a isimple `Proc` object isn't important at this time).  Notice that we drop the `&` when referring to the parameter inside the method.  Let's invoke the method to see what happens:\n  \n  ```ruby\n  test { sleep(1) }\n  \n  # what's &block? #<Proc:0x007f98e32b83c8@(irb):59>\n  # => nil\n  ```\n  \n  As you can see, the `block` local vriableis now a `Proc` object.  Note that we can name it whatever we please; it dosn't have to be `block` jus a long as we definie it wiht a leadding `&`.\n  \n  So, what's the point?  We were doing fine yielding to an implicit block.  Why do we now need an explicit block instead?  Chiefly, the answer is that it provides additional felxibility.  BEfore, we didn't have a handle (a variable) for the implicit block, so we couldn't do much with it except yield to it and test whether a block was provided.  Now we have a variable that represents the block, so we can **pass** the bloc to anoether method:\n  \n  ```ruby\n  def test2(block)\n    puts \"hello\"\n    block.call        # calls the block that was originally passed to test()\n    puts \"good-bye\"\n  end\n  \n  def test(&block)\n    puts \"1\"\n    test2(block)\n    puts \"2\"\n  end\n  \n  test {puts \"xyx\"}\n  # => 1\n  # => hellow\n  # => xyz\n  # => good-bye\n  # => 2\n  ```\n\nNote that you only need to use `&` fro the `block` paramter in `#test`.  Since `block` is already a `Proc` object when we call `test2` no converison is needed. \n\nNote that we also use `block.call` insdie `test2` to invoke the `Proc` instead of `yield`.  (if you wanted to invoke the `Proc` fom the `test`, you would do the same thing:  `block.call`.)\n\nIt's not often that you need to pass a block around like this, but th eneeed does arise.  While you don't need to spend a lot of time undestanding this, you hsould a least be familiar with the mechanisms; you will see it later.\n\n```\nThe above discussion of the explicit blocks is simplified from reality.  THing sget a bit more complicated if the caller passses in a `Proc` object, a `lambda` or some other object to a mehtod that takes an explicit block.  For now, you jst need to know that Ruby converts blocks passed in as explicit blocks to a simple `Proc` object (this is whey we need to us `#call` to invoke the `Proc` object). \n```\n\n###summary\n\nlets summarize the main points:\n\n- blocks are one way that Ruby implemnts closures. Closures are a way to pass around na unnamed \"chunk o coe\" to be executed later \n- blocks can take argumens, just like normal method.s bUt unlike methds, it won't caompain about wrong number of arguments passed to it\n- blocks return a value, just like normal methods.\n- blocks are a way to defer some implemnation decisions to method invocation time.  It allows method callers to refine a method at invocation time for a specific use case.  It allows method implementors to build generic methods that can be used in a variety of ways.\n- blocks are a good use case for \"sandwich code\" scenarios, like closing a `File` automatically.\n\n</details>\n\n\n<details><summary>Closures in Ruby</summary>\n\n### walk-through: Build a 'times' method\n\nLe't sput what wev'e learned thus far into practice.  Let's write our own `times` method that mimics the behavior of the `Integer#times` method.  First let's study the `Integer#times` method. \n\n```ruby\n5.times do |num|\n  put num\nend\n\n```\n\nInvoking the `Integer#times` method produces this output:\n\n```ruby\n0\n1\n2\n3\n4\n=> 5\n\n```\n\n\nNotice that the `Integer#times` method's first block argument is `0` and the las block argument is 1 less than the calling object.  Finally, the method returns the claling object `5`.\n\nOur `times` method will exhibit the same behavior, yiedling to th eblcok starting with `0` and going up to 1 less than the mehtod argument.  We don't have a calling object, but we do have a mehtod argument, so we'll return that.  In other words, we should be able to write the following code and get identical output as `Integer#times`:\n\n```ruby\ntimes(5) do |num|\n  puts num\nend\n```\n\nlet's give the implemnation a shot\n\n```ruby\n# method implementation\ndef times(number)\n  counter = 0\n  while couter < number do \n    yield(counter)\n    counter + =1\n  end\n  \n  number      #return the original method argument to match the behavior of `Integer#times`\nend \n\n# mehtod invocation\ntimes(5) do |num|\n  puts num\nend\n\n# Output:\n# 0\n# 1\n# 2\n# 3\n# 4\n# => 5\n```\n\nlet's trace code execution flow of the above code.\n\n1. method incoation starts at line 14, when the `times` method is called with an argument , `5`, and a block of code.\n2. Execution enters the first line fo the method implemention at line 3, where th elocal variable counter is initialized.\n3. Execution continues to line 4.  The `while` condidtional is evaluated.  The first time through, the condition is true.\n4. Execution contiues to line 5, which yields to the block.  This is the same as executing the block of code, and this time, we are executing the block of code with an argument.  The argument to the block is the `counter`, which is `0` the frist time through. \n5. Execution jumps to the block on line 13, setting `counter` to the block local variable `num`\n6. execution continues in the block to line 14, which outputs the block local variable `num`.\n7. Reaching the end of the block, execution continues back to the `times` method implementation o lin 6 where the `counter` is incremented.\n8. Reaching the end  of the  while loop, execution continues on line 4, essentially repating steps 3 - 7\n9. a some point the `while` conditionl should return false (otherwise, you have an infinite loop) allowing execution to flow to line 9, which doesn't do anything.\n10. reachign the end of the method at line 10, execution will return the last expression in this method, which is the `number` local variable.\n\nThis example is made a little bit more compplicated due to the `while` loop, but pay attnetion to the itnerplay betwen the method implementation and the block.  From within the mehtod, we are yielding execution to the block, and we are passing and argument to the block.  When we call the methd we know that e must inlucde a block that takes and argument. \n\nIn other words.  There are two separate roles here:  The `times` method implementer andthe user of the `times` method.  For example, let's call themethod implementer Isaac, and the user Uni (Isaace the implementer, and Uni the User).  Both are developers so the roles here are just in relation to the `times` method. \n\nIsaac wants to write a generic `times` method and he dosn't know if users of the method will be outputting values, or adding them together or whatever.  All he wants to do is write a generic method that iterates up to a certain number.  Using a block is a perfect use case;  he can allo users of his method to use blcos to perform some action.  But he doesn't know what that action is, so all he is responsible for is to yield to th eblcok and pass to  the block the current number.  This is the inspiration for our implemenation of our `times` method.\n\n\nOn the other hand, Uni has the need to iterate up to a certain number throughout her code. She finds Isaac's  `times` method and decideds to use it.  She reads the documentation adn finds some examples.  This fits her needs perfectly, as long as she passes in an argument to th emethod, and a blcok that taks an argument.  She can then be sure that the argument to her block is going to be a number starting from `0`, up to 1 lesss than the argument she passed to the method.   This is how Isaac implemented the method, and what he wrote in the documentation.\n\nUp to this point, you've been Uni, using `Integer#times` or `Array#each` by  by relying on documentation.  We're now starting to see how Isaac implements these methods, so you can start implementing these types of generic methods in your own code.\n</details>\n\n\n<details><summary>Walk-through: Build a 'each' method</summary>\n\nLet's now try to apply what we know about blocks and build our own `each` method.  By now, you shold be very familar with the `Array#each` method, and we'll be using that method as our inpiration.  One subtlety to note, though, is tha tthe `Array#each` method returns the calling object at the end.  Example:\n\n```ruby\n[1,2,3].each { |num|  \"do nothing\"}\n```\n\nSo what happens is that the `Array#each` method iterates through the array, yielding each element to the block, where the block can do whatever it needs to do to each element.  Then, the mehtod returns the calling object.  This is so developers can chain methods on afterwards, like this\n\n\n```ruby\n[1,2,3].each{|num| \"do nothing\"}.select{ |num| num.odd?}  # => [1, 3]\n```\n\nLet's write our own `each` method that takes and array, and exhibits the same behaviors as `Array#each`\n\n```ruby\ndef deach(array)\n  counter = 0\n  \n  while counter < array.size\n    yield(array[counter])         # yield to the block passing in hte current element to the block \n    counter += 1                  # returns the `array1 parameter, similar in spirit to how `Array#each` returns the caller\n  end\n  \n  array\nend\n\n```\n\nNote that we used a loop (specifically, a while loop) in the implemention of the `each` method.  We could have as well used the `Array#each` method, since we're passing in an `Array` object, but that somehow would have felt like cheating.  In any case, writing our own loop is easy enough\n\nLet's see houw our `each` method behaves:\n\n```ruby\neach([1, 2, 3, 4, 5])  do |num|\n  puts num\nend\n\n# 1\n# 2\n# 3\n# 4\n# 5\n# =>  [1, 2, 3, 4, 5]\n```\n\nNotic that our `each` method returns the argument at the end, so we can even chain it.\n\n```ruby\neach([1, 2, 3, 4, 5]) {|num| \"do nothing}.select{ |num| num.odd?}  # => [1, 3, 5]\n```\n\nIt looks like out `each` method behaves very similarly to `Array#each`1\n\nThe entire magic of our `each` method relies on the fact that our method does *not*  implemnt what action to perform when iterating through the array.  Do we increment every value by one?  Do we output the element?  None of that metters, beacaue our `each` method is solely focused on **iterating** and not on anything beyond that.  Writing a generic iterating method allows method callers to add additional implemenation details at method invocation time by passing in a block.  This is why when we implemented the method, we `yield` to the block.  Note that the trick here is to pass the current element we're working with to the block.  At each iteration within the `while` loop, execution then goes to the block (with the current element as the block argrument), and will return execution back to the `while` loop after executing the block.  Then,  `counter` is incremented and the `while` loop continues and the next element is yiedled to the block.  If this code flow is confusing, take time now to study that code. \n\n</details>\n\n\n<details><summary>Assignment: Build a 'select' method</summary>\n\nWrite a `select` method that mirros the behavior of `Array#selet`.  Note that the `Array#select` mehtod takes a block, then yields each elemetn to the block.  If the block evaulates to true, the current element will be included in the return array.  IF the block evaluates to false, the current element will not be included in the return array. \n\nHere are some exampls of `Array#slect`\n\n```ruby\narray = [1, 2, 3, 4, 5]\n\narray.select { |num|  num.odd? }  # =>  [1, 3, 5]\narray.select { |num| puts num }   # => [] because \"puts num\" returns nil and evaluates to false \narray.select { |num| num + 1}  # =>  [1 , 2, 3, 4, 5], because \"num + 1\"  evaluates to true\n```\n\nTherefore, youre assingment is to write a `select` method with the above behavior, and you should be able to call it like this \n\n```ruby\narray = [1, 2, 3, 4, 5]\n\nselect(array) { |num| num.oddd? }\n```\n</details>\n\n<details><summary> Assignment: TodoList </summary>\n\nin this assignment, we're going to create a `Todolist` which contains \na colleciton of `Todo` objects.  Internally to `TodoList`, we'll use \nan `Array` to back th ecollection of `Todo` objects.\n\n\nwe'll first take a look at the `Todo` class\n\nthis class represents a todo item and its associated\ndata: name and description.  There's also a \"done\"\nflag to show whether this todo item is done. \n\n```ruby\n\nclass Todo\n  DONE_MARKER = 'X'\n  UNDONE_MARKER = ' '\n\n  attr_accessor :title, :description, :done \n\n  def initialize(title, description='')\n    @title = title\n    @description = description\n    @done = false \n  end\n\n  def done!\n    self.done = true\n  end \n\n  def done?\n    done\n  end\n\n  def undone!\n    self.don = false\n  end\n\n  def to_s \n    \"[#{done? ? DONE_MARKER : UNDONE_MARKER}] #{TITLE}\"\n  end\n\n  def ==(otherTodo)\n    title == otherTOdo.tittle &&\n       description == otherTodo.description && \n       done == otherTodo.done\n  end \nend\n```\n\nThe above is a simple `Todo` class that contains 3 attributes each `Todo` \nobject can have: a title, a description, and a boolean flag to designate\nwhether the todo item is \"done\".  We have 3 helper methods to set, unset, and\ninterrogate the `@done` attribue;  these aren't strictly necessary, but give\na better interface when working with `Todo` objects.  Finally, we provide\na `to_s` method for representing `Todo` objects as strings, and an `==` method\nthat lets us compare two `Todo` objects for equality.  We can us this class in\nout `TodoList` class below to encapsulate todo items.\n\n# Examples with `Todo` class:\n\n```ruby\n\ntodo1 = Todo.new(\"Buy milk\")\ntodo2 = Todo.new(\"Clean room\")\ntodo3 = Todo.new(\"Go to gym\")\n\nputs todo1\nputs todo2\nputs todo3\n\n# [ ] Buy milk\n# [ ] Clean room\n# [ ] Go to gym\n```\n\nThe `puts` methods automatically calls the argument's `to_s` method\nwhich in this case leads to the `Todo#to_s` method.  the return value\nof any `puts` call is `nil`.  Let's say we bought some milk, so we want\nto update the todos.\n\n```ruby\ntodo1.done!\n\nputs todo1\nputs todo2\nputs todo3\n\n# [X]  Buy milk\n# [ ]  Clean room\n# [ ]  Go to gum \n```\n\npretty neat!  There's not too much beyond this functionality for `Todo` objects.\nWe create them, we can mark them done or undone, then we can display them.\n\nLet's now turn out attention to the **collection** class,  `TodoList`. Why\nbuild our own?  Coan't we just use `Array` and work with an array of `Todo` objects?\nWe could, but using our own cutsom collection class allows us to add additional\n attributes to the collection and also allows us to add additional behaviors\n to specific to **todo lits**.  For example, our collection of `Todo` objects \nshould have a tile, or perhaps a due date.  Using `Array` doesn't allow us\nto add these collection level attributes.  We could also append two `TodoList1 objects\ntogeter to get a new `TodoList`, be we can'd do that with `Array` (we'd get a new\n`Array`).  We could further define specific requiremtns about what types of objects\nthis list should have.  For example, our `TodoList` should only work with `Todo` objects,\nand using our own custom collection class, we can enforce this requirement.  We can't\nuse an `Array`.  Someimtes, using Ruby's basic collections is enough, other times\nwe need something more. \n\nTake a look at the initial implemantion of the `TodoList1 class below.  Note that\n we are using `Array` as the bakcing mechanism internally to keep track of our\n`Todo` objects.  We can easily change it to a hash or linked list or whatever\nin the future, as long as our `TodoList1 public interface (ie, public methods) doesn't change\n\n```ruby\n#this class respresnts a collection of Todo objects.\n# you can perform typical collection-oriented actions\n# on a TodoList object, including iteration and seleciton\n\nclass TodoList\n  attr_accessor :title\n  \n  def initialize(title)\n    @title = title\n    @todos = []\n  end\n  \n  # rest of class needs implentation\n```\n\nThe assignment for you is to figure out hte rest of the implemenation in order of the bleow code to work.  Note that this assignment doesn' have anything to do with blcoks yet  -- it's just basci Ruby at thsi point\n\nImplemen the rest of `TodoList` so that we can writ this code:\n\n```ruby\n\n#given\ntodo1 = Todo.new(\"Buy milk\")\ntodo2 = Todo.new(\"Clean room\")\ntodo3 = Todo.new(\"GO to gym\")\nlist = TodoList.new(\"Today's todos\")\n\n# ---- Adding to the list ---\n\n# add\nlist.add\n\n```\n\n</details>\n\n<summary><details> Blocks and variable scope </summary>\n\nnow that we undertsand what blocks are, let's revisit local variable scope.\n\n### A Refersher \n\nRecall that previously we asked you to emorize loca variable scope in terms of **iner** and **souter** scope, as determined by where the local variable was initialized.  A block creates a new scope fore local variablse, and only outer local variables are acessible to inner blocks. \n\n```ruby\nlevel_1 = \"outer-most variable\"\n\n[1, 2, 3].each do |n|           # block creates a new scope \n  level_2 = \"inner variable\"    \n  \n  [ 'a', 'b', 'c'].each do |n2|     # nested block \n    level_3 = \"inner-most variable\"\n    \n    # all three level_x variables are accessible here\n  end\n  \n  # level_1 is accessible here\n  # level_2 is accessible here\n  # level_3 is not accessible here\n  \nend\n\n# level_1 is accessible here \n# level_2 is not accessible here\n# level_3 is not acessible here\n```\n\nRemember that this is only for **local Variables**.  It's even more confusing because sometimes we're invoking methods, but they look just like local variables if you omit the parenthese.  Always look at where the local variables are initialized to determine its scope, and to verify that it's indeed a local variable we're dealing with and not a method.  If its a method, it doesn't follow this rule.\n\n###closure and binding\n\nAs we talked about before, a block is how Ruby implemetns the idea of a **closure** which is a general computing concept of a \"chunk of code\"  That you can pass around and execute at some later time.  Think about that: an unnamed \"chunk of code\" being passed aroudn in your codebase.  In order for this \"chunk of code\" to be executed later, it must understand the surrounding context from when it was initialized.  In Ruby, this \"chunk of code\" or closure is represented by a Prob object, a lambda, or a block.  Remember that blcoks are a from of Proc.  Let's take a look at an example:\n\n```ruby\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name}\"}\n```\n\nIf you try to run the code, nothing will happen.  that's because we've created a Proc and saved it to `chunk_of_code` , but haven't executed it yet.  We can now pass aroudn this local variable, `chunk_of_code` and execute it at any time later.  Suppose we have a completely different method, adn we pass in this `chunk_of_code` into that method, then the method executes that `chunk_of_code`.  Think it through and take a guess at what would happen.\n\n```ruby\ndef call_me(some_code)\n  some_code.call                  # call will execute the \"chunk of code\" that gts pass in \nend\n\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name}\"}\n\ncall_met(chunk_of_code)\n```\n\nRead the above, think about what you know about variable scoping rules and try to guess the output.\n\nthe output of the above is:\n\n```ruby\nhi Robert\n=> nil\n```\n\nNote that the `chunk_of_code` knew how to handle `puts #{name}` and specifically that it knew how to process the `name` variable.  How did it do that?  The `name` variable was initialized **outside** the mehtod definition, and we know that in Ruby local variables initialized outside the method aren't accessible inside the method, unless it's explicityly passed in as an argument.  So again, how did that code we pass in know how to process the `name` variable?\n\nMaybe that Proc was pre-processed somehow?  Let's run an experiment to test that theory.  We'll use the same code, except we'll re-assign the `name` variable **after** the Proc has been initialized.  Let's see if the chunk of code reatins its old value of `\"Robert\"` or our new value of `\"Griffin III\"`.\n\n```ruby\ndef call_me(some_code)\n  some_code.call\nend\n\nname = \"Robert\"\nchunk_of_code = Proc.new {puts \"hi #{name}\"}\nname = \"Griffin III\"  # re-assign name after Proc initialization\n\ncall_(chunk_of_code)\n\n# hi Griffin III\n#=> nil\n\n```\n\nso even re-assignign the variable after the Proc is initialized updates the `chunk_of_code`.  This implies that the Proc keeps track of its surrounding context, and drags it around wherever the chunk of code is passed in. In RUby, we call this *binding*, or surrounding enviroment/context.  A closure must keep track of its surrounding context in order to have all the information it needs in order to be executed later.  This not only includes local variables, but aslo method references, constants and other artifacts in your code -- whatever it needs to execute correctly, it will draw all of it around.  It's why code like the above will work fine, seemingly violating the variable scoping rules we learned earler.\n\nThis is at the core of variable socping rules in Ruby, and it's why \"inner scopes can access outer scopes\". It'll be hard to remember the details of bindings and closures as you code, so it may still be usefule to remember the rule, but the point of this assignment is to show that how Ruby implments closures is at the core of how vriable scope works, and hterfore, it's at the core of how ruby itself works. \n\n</details>\n\n<summary><details>Symbol to proc</summary>\n\nWhen woring with collections, we often want to transform all items in that collection.  For example, suppose we have an array of integers and we want to transform every element in th earry into strings. We can do so like this:\n\n```ruby\n[1, 2, 3, 4, 5].map do |num|\n  num.to_s\nend\n\n# => [\"1\", \"2\", \"3\", \"4\", \"5\"]\n```\n\nyou can see that the return value for the above is a new array, where every element is now a string.  This type of code is so common that there's a shortcut for it.  We could write the above likt this:\n\n```ruby\n\n[1, 2, 3, 4, 5].map(&:to_s)     # => [\"1\", \"2\", \"3\", \"4\", \"5\"]\n\n```\n\nThe above code iterates through every element in the array and calls `to_s` on it, then saves the result into a new array.  After it's done iterating, the new array is returned.  And because it returns another array, you could chain another transformation.\n\n```ruby\n[1, 2, 3, 4, 5].map(&:to_s).map(&:to_i)  # => [1, 2, 3, 4, 5]\n```\n\nThe above code transforms all elemetns to strings, and then back to integers.  Not that the `&` must be followed by a symbol name for a method that can be invoked on each element.   int he last example, we ust the `:to_s` and `:to_i` to represent the `#to_s` and `#to_i` methods.\n\nsuppose you want to use `String#prepend` to prepend each value with `The number is:`.  Unfortunatley, we can't use the shorcut to do that; it doesn't work for methods that take arguments.\n\nFinally, this shortcut will work with any collection method that takes a block, not only `map`.  For example: \n\n```ruby\n[\"hello\", \"world\"].eahc(&:upcase!)         # => [\"HELLO\", \"WoRLD\"]\n[1, 2, 3, 4, 5].select(&:odd?)             # => [1, 3, 5]\n[1, 2, 3, 4, 5].select(&:odd?).any?(&:even?)   # => false \n```\n\n### Symbol#to_proc\n\nIf you look closely, somehow this code:\n\n```ruby\n(&:to_s)\n```\n\n... gets conveted to this code:\n\n```ruby\n  { |n|  n.to_s }\n```\n\nWhat's the mehcnaism at work here?  It's related to the use of `&` with expelicit blocks, but wince it isn't applied to a method parameter, ti's also different.  Let's break down the code:  `(&:to_s)`.  First, when we add a `&` in front of an object, it tells Ruby to try to convert this object into a block.  To do so, it's expecting a Proc object.  If this object is not a Proc object, it ill call `#to_proc` on the object.  So tow thing sare happening:\n\n - Ruby checks whether the object after `&` is a `Proc`.  If it is, it uses the object as-is.  Otheriwse it tires to calll `#to_proc` on the object, which sould return a `Proc` objet.  An error will occur if the `#to_proc`  fails to return a `Proc` object\n - If all is well, the `&` turns the `Proc` into a block.\n \nLet's puase here and look again at `(&:to_s)`.  This means that Ruby is tyring to turn `:to_s` into a block.  However, it's not a Proc; it's a Symbol.  Ruby will then try to call the `Symbol#to_proc` method --- and therre is one!  This method will return a `Proc` object, which will execute the method based on the name of the symbol.  In other words, `Symbol#to_proc` returns a `Proc`,  which `&` turns into a block, which turns our shortcut into the long form block usage. \n\nHere are some more examples of this mechanism at work.  The first examplebelow will do the 2 steps above in one line.\n\n```ruby\n  def my_method\n    yield(2)\n  end\n  \n# tursn the symbol into a Proc, the & turns the Proc into a block \nmy_method(&:to_s)\n```\n\nthe code example below will try to break up the 2 steps\n\n```ruby\ndef my_method\n  yield(2)\nend\n\na_proc = :to_s.to_proc               # explicitly call to_proc on the symbol\nmy_method(&a_proc)                  # convert Proc into block, then pass block in.  Returns \"2\n```\n\n###summary\n\nWhew! that was a little in depth.  It's probablhy a little too much informatio, so the main concept you have to know is that you can use a shortcut when calling methods with blocks by using the symbol-to-proc trick. But understand that there's some dpeth behind the syntax and try to your head around it.  Understanindg `Symbol#to_proc` is not on the critical paht, buts it's important to be aware to look this up agian in the futuer. \n\n</details>\n\n\n<summary><details> Summary Lesson 1: Blocks </summary>\n\nClosures as a whole is at the core of many programming languages, so start to get comfortable with the idea of unnamed \"chunks of code\" you can pass around and execute later.\n\n\nSpecifically, we saw:\n\n- blocks are just one way Ruby implemetns closures.  Procs and lambdas are others\n- closures drag their surrounding context/environment around, an this is at the core of how variable scope works.\n- blocks are great for pushing some decisions to method invocation time.\n- blocks are great fro wrapping logic, where you need to perform some before/aftter actions.\n- we can write out own methods that take a block with the `yield` keyword.\n- when we `yield`, we can also pass arguments to the block.\n- when we `yield`, we have to be aware of the block's return alue.\n- once we understand blocks, we can re-implemnt many of the common methods in the Ruby core library in our own classes.\n- The `Symbol#to_proc` is a nice shortcut when working with collections.\n\nThis is probably a lot, but you'll get plenty of opportunity to pracie these concepts throughout the program. \n\n</details>\n\n#Lesson 2: Introduction to testing\n\n<summary><details> Introduction </summary>\nThis lesson will be a quick overview of how to do basic testing in Ruby.  Testing can be a very confusing topic because it's a combination of a lot different tools and workflows.  Add in the context of framworks and it's nearly impossible to understand what's going on.\n\nThis lesson will *Not* talk about*:\n\n- Test DRiven Development\n- Test Driven Design\n- Behavrioual Driven Development\n- Acceptance Test Driven Development\n- Rspec\n- Testing with a web framework, like Rails\n- Test-first vs test-after\n- How testing helps influence design choices\n\n* If you've never head of any of th eabove terms, don't worrry.  It's completely ok to ignore them right now.  In fact, you may even be at an advantage by not having your head luttered with such terms early on.\n\nInstead, we'll focus on bare essentials of testing syntax by working with command line programs.  We'll us teh deaulft Ruby testing library.  Minitest\n\n###Why Write Tests\n\nit's surprisingly difficult to find a clear answer to why we need to write tests.  If you search online for why we should write tests, you'll likely come across a variety of answers that relate to a discovery process fo the **design** of your program.  This is not incorrect, but it's not helpful for beggineers.\n\nFor beginners, write test to prevent regression -- that's it!  That's the only beneift of testing we'll focus on for now.  We want to write test so that when we make changes in our code, we don't have to maually verify everything still works.  You can Write tests first if you like, or you can write your tess after implemnation.  Most liklye, you'll need to take some mixture of both, jumping back and forth between implementatio adn testing code.\n\nAs you move along in your journy of becoming a professional programmer, you'll discover far more powerful and fascinating benefits of testing.  But again, let's not wander into that territor yet.\n\n###Testing Jarogn\n\n- \"Did the Pr pas continuous integeration tests?\"\n- \"i feel our functional tests are getting redundant given our integration tests\"\n- \"what atdd tool do you like?\"\n- Does you team practice TDD?\n- WHAT'S THE NEW MATCHER SYNTAX in the latest Rspec?\"\n- I write unit tests, but not controller test\"\n\nsometimes, if feels like we speak a different language while testing.  This jargon can make beginners feel completely lost and out of the loop.  IN thi slesson, we are going to ignore them all.  We won't talk about any of these things, and instead focus on just testing simple classes.  If you must give a name to wehat we're goin to cover, you can think of this as learning **unit testing**.\n\nAll advnaced testing tools and methodologies build upon this knowledge \n\n\n</details>\n\n<summary><details> Lecture: Minitest </summary>\nThough many people us RSpec, Minitest is the default testing library that comes with RUby.  From a pure functionality standpoint, Minitest can do evertyhing RSpec can, except Minitest uses a more straight forward syntax.  RSpec bends over backwards to allow developers to write code that reads like natural English, but at the cost of simplcity.  RSpec is what we call a *Domain Specific Language*; it's a DSL for writing tests.\n\nWe use Minitest because it reads just like normal Ruby code, without a lot of magical syntax.  It's not a DSL, it's just Ruby.\n\n### Vocabulary\n\nin the work of testing, a whole new vocabulary is necessary to talk about the new concepts.  THere is **a lot** of jargon when working with tests, but for now, we'll just focus on a few terms below.\n\n- *Test Suite:*  This is the entire set of tests that accomapnies your program or application.  You can think of this as all the test for a project.\n- *Test:*  This describes s situation or context in which tests are run.  FOr example, this test is about making sure you get an error message after tyring to log in with the wrong password.  A test can contain multiple assertions.\n- *Assertion:*  This is the actual verification step to confirm that the data returned by your program or applicaiton is indeed what is expected.  YOu make one or more assertions within a test.\n\nFor now, we'll just use the above 3 terms, so you shold know \n\n### You First Test\n\nLe'ts start with a simple `Car` class.  Create a file called `car.rb` on your file system, and include the following code.\n\n```ruby\nclass Car\n  attr_accessor :wheels\n  \n  def initialize\n   @wheels = 4\n  end\nend\n\n```\n\nNow, in the same directory, create another file called `car_test.rb` with the following code.\n\n```ruby\nrequire 'minitest/autorun'\n\nrequire_relative 'car'\n\nclass CarTest < MiniTest::Test\n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end\nend\n```\n\nif you run the test file with `ruby car_test.rb` you should see this output:\n\n```ruby\nruby car_test.rb\n\nRun options: --seed 62238\n\n# Running:\n\nCarTest .\n\nFinished in 0.001097s, 911.3428 runs/s, 911.3428 assertions/s.\n\n1 runs, 1 assertions, 0 failures, 0 errors, 0 skips\n```\n\n\nthough it's not extremely obvious, this output means our test passed.  Look at the last line: 1 assertions, 0 failures, 0 errors.  That means the assertion was executed, and there weren't any problems.  That's really the core of using Minitest!\n\n##What's in the test file\n\nLet's take a closer look at what's in the actual test file, `car_test.rb` and break it down line by line.\n\n```ruby\nrequire 'minitest/autorun'\n\nrequire_relative 'car'\n\nclass CarTest < MiniTest::Test\n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end\nend\n```\nOn line 1 is `require minitest/autorun`, which loads all the necessary files from the `minitest` gem.  That's all we need to use Minitest.  Next, on line 3 we require the file that we're testing, `car.rb` which contains the `Car` class.  We us `require_relative` to specify the file name from the current file's directory.  Now when we make references to the `Car` class,  Ruby knows where to look for it.\n\nFinally, line 5 is where we create out test class.  Note that this class must subclass `MiniTest::Test`.  This will allow our test class to inherit all the necessary methods for writing tests.\n\nWithin our test class, `CarTest`, we can write tests by creating an instance method that starts with *test_*.  Through this naming convention, Minitest will know that these methods are individual tests that need dto be run.  Within each test (or instance method that starts with \"test_\"), we will need to make some **assertions**.  these assertions are what we re trying to verify.  Before we make any assertions, however, we have to first set up the appropriate data or objects to make assertions against.  For example, on line 7, we first instantiate a `Car` object.  We thne us this car object in our assertion to verify that newly created `Car` objects indeed have 4 wheels. \n\nThere are many types of assertions, but for now, just focus on `assert_equal`.  Since we are inside an instance method, you can guess that `assert_equal` is an inherited instance method from somehwer up the hierarchy.  `assert_equal` takes two parameters: the first is the expected value, and the second is the test or avtual value.  If there's a discrepancy, `assert_equal` will save the error and Minitest will report that error to you at the end of the test run. \n\nIf there's a discrepancy, `assert_equal` will save the error and Minitest will report that error to you at the end of the test run.\n\nI'ts sometimes usful to have miutiple assertions within oune test(ie, instnace method that starts with \"test_\") but in th ebeginning, we'll only show one assertion within one test.\n\n### reading test output\n\nif everything goes well, you'll see output like this:\n\n```ruby\nRun options: --seed 62238\n\n# Running:\n\nCarTest .\n\nFinished in 0.001097s, 911.3428 runs/s, 911.3428 assertions/s.\n\n1 runs, 1 assertions, 0 failures, 0 errors, 0 skips\n\n```\n\nThere are many options in Minitest, including various formatting options, but by default the output looks like the above.  The first \"seed\" tells Minitest what order the tests were run in.  In our example, we only have 1 test, but most test suites have many tests that are run in random order.  The \"seed\" is how you tell Minitest to run the entire test suite in a particular order.  This is rarely used, but is sometimes helpful when you have an especially tricky bug that only comes up when certain specific situations come up.\n\nThe next important thing to notice is the dot.  There's only 1 here, so it looks like an inconsequential period, but it's very important.  That means the test was run and nothing went wrong.  If you skip a test wtih the \"skp keyword, i'ltt say \"S\".  if you have afialur it'll say \"F\".  Pay attention to thta to see if you have a failing test.\n\n\n###Failures\n\nLet's add another test, but purposefully make it fail.\n\n```ruby\n\nrequire 'minitest/autorun'\n\nrequire_relative 'car'\n\nclass CarTest < MiniTest::Test\n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end\n  \n  def test_bad_wheels\n    car = Car.new\n    assert_equal(3, car.wheels)\n  end\nend\n```\n\nNotice we added the `test_bad_wheels` test, and our assertion should fail.  Let's run it and see. \n\n```\n$ ruby car_test.rb\n\nRun options: --seed 8732\n\n# Running:\n\nCarTest F.\n\nFinished in 0.001222s, 1636.7965 runs/s, 1636.7965 assertions/s.\n\n  1) Failure:\nCarTest#test_bad_wheels [car_test.rb:13]:\nExpected: 3\n  Actual: 4\n\n2 runs, 2 assertions, 1 failures, 0 errors, 0 skips\n\n```\n\nNotice a couple of differences.  The last line gives us a quick summary, and we can see that there are now 2 assertions adn 1 failure.  Minitest further gives us the exact failing test, and also tells us the expected value vs the actual value.  Also notice at the top there's a \"F.\", which means there were 2 tests, one of which failed (that's the \"F\") and one of which paseed (that's the \".\")\n\n### A dash of color\n\nThe default Minitest output is quite bland, but you can easily add color to th eoutput with the `minitest-reporters` gem.  First install the gem\n\n```ruby\ngem install minitest-reporters\n```\nThen, at the top of your test file, include the following lines: \n\n```ruby\n\nrequire 'minitest/autorun'\nrequire \"minitest/reporters\"\nMinitest::Reporters.use!\n\nrequire_relative 'car'\n\nclass CarTest < MiniTest::Test\n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end\n\n  def test_bad_wheels\n    car = Car.new\n    assert_equal(3, car.wheels)\n  end\nend\n\n```\n### Skipping Tests\n\nSometimes you'll want to skip certain tests.  Perhaps you are in the middle of writing a test, and  do not want it run yet, or for any other reason.  Minitest allows for this via the `skip` keyword.  All you have to do is put `skip` at the beginning of the test, and Minitest will skip it.  It will also dutifully report that you have skipped tests in your suite, and output an \"S\" instead of a dot.  For example, let's skip our secon test that doesn't pass.\n\n```ruby\nrequire 'minitest/autorun'\nrequire 'minitest/reporters\"\nMinitest::Reporters.use!\n\nrequire_relative 'car'\n\nclass CarTest < MiniTest::Test\n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end\n  \n  def test_bad_wheels\n    skip\n    car = Car.new\n    assert_equal(3, car.wheels)\n  end\nend \n\n```\n\nyou could also pass a string into the `skip` if you want a more custom diplay message. \n\n### Expectation Syntax\n\nThus far, we've been using the **assertion** or **assert-style** syntax.  Minitest also has a completely different syntax called **expectation** or **spec-style** syntax. \n\nIn expectation styel, tests are grouped into `describe` blocks, and individual tests are written with the `it` method.  We no longer use assertions, and instead use **expecation matchers**.  That sounds crazy, but when written out, it reads very nice. Let's see an example of epxecation synstax test blow.  First creat a new file called `car_spec.rb`  with the below code.\n\n```ruby\nrequire 'minitest/autorun'\n\nrequire_realtive 'car'\n\ndescribe 'Car#wheels` do \n  it 'has 4 wheels' do \n    car = Car.new\n    car.wheels.must_equal 4    # this is the epectation\n  end \nend\n```\n\nThere's a lot of magic going on, and we won't spend too much time deciphering it.  Note that this DSL doesn't look like \"normal\" Ruby code, and where did that `must_equal` method come from?  Don't worry about all that for now. \n\nRunning that code will give us the following output. \n\n```\nRun options: --seed 51670\n\n# Running:\n\nCar#wheels .\n\nFinished in 0.001067s, 937.0051 runs/s, 937.0051 assertions/s.\n\n1 runs, 1 assertions, 0 failures, 0 errors, 0 skips\n\n```\n\nthat looks the same as using assertion style! And that's the point -- using either assertion or expectation syntax is a sytle choice.  Some people prefer the expectation syntax because it mimics RSpec's syntax, but in this course, wer'e going to stick with the more intuitive assertion style. \n\n### Summary\n\nGetting started with Minitest is very simple.  In this lesson, you hsould have gotten a quick taste of how to run your first test using Minitest.  Here are the other things you learned:\n\n- Minitest is an intutive test library that comes with Ruby.\n- Using Minitest is very easy, and you shouldn't be afarid to paly around with it\n- Creat a test file\n- Creat a test class by subclassing `MiniTest::Test`.\n- Create a test by creating and instance method that starts with `test_` \n- Creat assertions with `assert_equal`, and pass it the expected value and the actual value. \n- Colorize Minitest ouput with `minitest-reporters`\n- you can skip tests with `skip`.\n- Minitest comes in two syntax flavors: assertion style and expectation style.  The latter is to appease RSpec users, bu the former is far more intuitve for beginning Ruby developers.\n\nThere's a lot more depth to learning testijng, but this is enought to get started. \n\n</details>\n\n<summary><details>  Assertions </summary>\n\nIn the pervious assignment, we saw how to use `assert_equal` to make an assertion about the equality of two objects.  In the example, we wanted to assert that the number of wheels on `car` as equal to `4`, because we're expecting all new `Car` objects to have 4 wheels.  `assert_equal` is the most common assertion, and we can get pretty far only using that. \n\nBut there are times when we need to make different types of assertions.  For example, besides equaily, sometimes we want to assert that a specific error is raised, or that something is printed out to standard out, or an object must be an object of a specific class, or that something must be `nil`, or that it must bot be `nil`, etc.  Minitest can support virtually every kind of assertion you'd want to make.  We won't vover it all, but w'll list a few of the more popular ones.  If you ever feel like there should nbe an assertion for something, make sure to loop up the [full list of assertions](http://docs.seattlerb.org/minitest/Minitest/Assertions.html) to see if yours is in there \n\n\n|Assetion| Description |\n| ---| ---|\n| assert(test) | Fails unless `test` is truthy|\n|assert_equal(exp, act)| Fails unless `exp == act`|\n| assert_nil(obj) | Fails unles `obj` is `nil` |\n|`assert_raises(*exp){ ...}`| Failes unless block raises one of `*exp`|\n|assert_instance_of(cls, obj)| Fails unless `obj` is an instance of `cls`.|\n|`assert_includes(collection, obj)` | Fails unless `collection` includes `obj`|\n\nThe full list of assertions is much longer than this, but hopefully you can start to get and idea of wha'ts at your disposal.\n\n### Examples\n\nLet's take a look at using the above assertions with an example.  we'll continue wiht out simple `Car` class, with a few modifications (notice we added an `attr_accesor` for `:name`).  In the examples we'll onlhy include the test to save on space. \n\n```ruby\nclass Car\n  attr_accessor :wheels, :name\n  \n  def initialize\n    @wheels = 4\n  end\nend \n```\n\n1.  `assert`\n\n```ruby\ndef test_car_exists\n  car = Car.new \n  assert(car)\nend\n```\n\n2. `assert_equal`\n\n```ruby\ndef test_wheels\n  car = Car.new\n  assert_equal(4, car.wheels)\nend \n```\n\n3. `assert_nil`\n\n```ruby\ndef test_name_is_nil\n  car = Car.new\n  assert_nil(car.name)\nend\n```\n4. `assert_raises`\n\n```ruby\ndef test_raise_initialize_with_arg\n  assert_raises(ArgumentError) do \n    car = Car.new(name: \"Joey\")     # this code raises ArgumentError, so this assertion passes\n  end\nend \n\n```\n\n5. `assert_instance_of`\n\n```ruby\ndef test_instnce_of_car\n  car = Car.new\n  assert_instance_of(Car, car)\n```\nThis test is more useful when dealing with inheritance.  this example is a little contrived. \n\n6. `assert_includes`\n\n```def \ndef test_includes_car\n  car = Car.new \n  arr = [1, 2, 3]\n  arr << car\n  \n  assert_includes(arr, car)\n  \n# assert_includes calls assert_equal in its implemntation, and Minitest coutns that call\n# as a seprate assertion.  For each assert_includes call, you will get 2 assertions, not 1.\nend\n```\n\n###Refutations\n\nWe won't spend too much talking about refutations, except to say that they are the opposite of assertions.  That is, they refute rather than assert.  Every assertion has a corresponding refutation.  FOr example. `assert`'s opposite is `refute`.  `refute` passes if the object you pass to it is falsey.  Refutations all take the same arguments, except it's doing a **refutation**.  and yes, ethere is a `refute_equal`, `refute_nil`, `refute_includes`, etc.\n\nAgain, we won't get inot refutations because they're rarely used, except for rare circumstances (or if you're on a project where the team lead has chosen this tyle). \n###Summary\n\nwhile `assert_equal` is the do-it-all assertion, there are many types of assertions available to you.  Learn the most popular ones, and you should be good. if you ever come across a sistuation where you feel like there should be an assertion for it, there probably is.  Be aware of the existence of refutations.\n\n**Optional Reading:**  [introduction to minitest](https://launchschool.com/blog/assert-yourself-an-introduction-to-minitest) blog post can help you learn more about using Minitest assertions to test your software. \n\n\n</details> \n\n\n<summary><details> SEAT APPROACH </summary>\n\nAs you read the tests from previous lessons, you might have noticed that we have to set up the `car` object within each test in order to perform some assetion on it.  This seems a little redundant; it would be more optimal to do some set up once outside of each test, then just run the assertions on it.  This may seem like a minor and unnecessary performance savings, but the savings really add up if you have a lot of tests and if the set up process is expensive (say you're retrieving some data from a database).\n\nIn the previous assignmeents, we've been quickly diving down into the tests and assertions, but in larger projects, there are usually 4 steps to writing a test:\n\n1. Set up the necessary objects.\n2. Execute the code against the object we're testing.\n3. Assert the results of the execution.\n4. Tear down and clean up any lingering artifacts.\n\nThis is the SEAT approach.  In our simple tests, we've been doing steps 2 and 3, and we haven't had the need to set up anything or perform any clean up or tear down.\n\nLet's take a look at out example.\n\n```ruby\nrequire 'minitest/autorun'\n\nrequire_relative 'car'\n\nclass CarTest< MiniTest::Test\n\n  def test_car_exists\n    car = Car.new\n    assert(car)\n  end\n  \n  def test_wheels\n    car = Car.new\n    assert_equal(4, car.wheels)\n  end\n  \n  def test_name_is_nil\n    car = Car.new\n    assert_nil(car.name)\n  end \n  \n  def test_raise_initialize_with_arg\n    assert_raises(ArgumentError) do\n      car = Car.new(name: \"Joey\")\n    end\n  end\n  \n  def test_instance_of_car\n    car = Car.new\n    asser_instance_of(Car, car)\n  end\n  \n  def test_includes_car\n    car = Car.new\n    arr = [1, 2, 3]\n    arr << car\n    \n    assert_includes(arr, car)\n  end\nend\n\n```\n\nAll the tests pass -- go ahead and run it to verify.  Now take a look at the tests, and ntoice that many of them have `car = Car.new`.  This is very redundant, and we should extract this to some set up step that gets executed before the running of very test.  In minitest, we can do this with a `setup` intance method.  Let's refactor to add a `setup` method.\n\n```ruby\nrequire 'minitest/autorun'\n\nclass CarTest < MiniTest::Test\n  def setup\n    @car = Car.new\n  end\n  \n  def test_car_exits\n    assert(@car)\n  end\n  \n  def test_wheels\n    assert_equal(4, @car.wheels)\n  end\n  \n  def test_name_is_nil\n    assert_nil(@car.name)\n  end\n  \n  def test_raise_initialize_with_arg\n    assert_raises(ArgumentError) do\n      Car.new(name: \"Joey\")\n    end\n  end\n  \n  def test_instance_of_car\n    assert_instance_of(Car, @car)\n  end\n```\n\nNote that in the `setup` method, we must now use and instance variable , `@car`.  We can't us a local variable in `setup`, becuase the ests, which are just instance methods, won't be able to access it.  But they can access an instance variable.  Because we changed `car` to `@car`, we also have to make the same update in the actual test.s  Finally, note that we do not use `@car` in the `test_raise_initialize_with_arg` test, becuase we're using `Car.new` with arguments in this test.\n\nThe `setup` method will be called before running every test, and the `teardown` method (which we don't have) will be called after running every test.  In our case, we don't have any tear down activity, so it's not necessary.  In some cases, we will need a tear down for cleaning up files or logging some information, or closing database connections.\n\nIn the simplests cases, we won't need either set up or tear down, but juts keep in mind that there are 4 steps to running any test, and it is SEAT, At the minium you'll need EA, even if the E is just a simple object instantiation. \n\n</details>\n\n\n<summary><details>  Testing Equality </summary>\n\nWe already said that `assert_equal` is one of the most useful assertions, but **how** is it testing for equality?  Recall from before that equality in Ruby (or any programming language) is not a straight forward affair.  Are we talking object equality?  or value equality? or both?\n\nWhen we use `assert_equal` , we are testing for **value equality**.  Specifically, we're invoking the `==` method on the object.  If we're looking for more strict **object equality**, then we need to us the `assert_same` assertion.\n\nLet's take a look at an example.  We'll just create a temporary test file to experiment with.\n\n```ruby\nrequire 'minitest/autorun'\n\nclass EqualityTest < Minitest::Test\n  def test_value_equality\n    str1 = \"hi there\"\n    str2 = \"hi there\"\n    \n    assert_equal(str1, str2)\n    assert_same(str1, str2)\n  end\nend\n```\n\nIf you run the above test, you'll see that the `assert_equal` assertion will pass.  This is because `str1 == str2` returns true.  However, the second assertion, `assert_same`, ill fail and output a message that loks lik this:\n\n```\n  1) Failure:\nEqualityTest#test_value_equality [temp.rb:9]:\nExpected \"hi there\" (oid=70321861410720) to be the same as \"hi there\" (oid=70321861410740).\n```\n\nThe failure message is interesting, as it's showing the object id for the wto `String` objects.  Notice they're not the same.  `assert_same` corresponds to object equality; they must be the same object. \n\n### Equality with a custom class\n\nBecause the Ruby core library classes all implement sensible `==` to test for value equality, we can get away with using `assert_equal` on strings, arrays, hashes, etc.  But what happens if we try to use `assert_equal` on our own custom classes?\n\nThe answer is we have to tell Minitest how to compare those objects by implenting our own `==`\nmethod.  Let's use our familiar `Car` class, except we'll add a `==` method.\n\nBut before we do that, let's take a lok at what would happen if we did not have a `==` method, and we tried to call `assert_equal`.\n\n```ruby\nclass Car\n  attr_accessor :wheels, :name\n  \n  def intialize\n    @wheels = 4\n  end\nend\n\nclass CarTest < MiniTest::Test\n  def test_value_equality\n    car1 = Car.new\n    car2 = Car.new\n    \n    car1.name = \"Kim\"\n    car2.name = \"Kim\"\n    \n    assert_equal(car1, car2)\n  end\nend\n\n```\n\nRunning the above test will yield this output:\n\n```ruby\n# Running:\n\nCarTest F\n\nFinished in 0.021080s, 47.4375 runs/s, 47.4375 assertions/s.\n\n  1) Failure:\nCarTest#test_value_equality [car_test.rb:48]:\nNo visible difference in the Car#inspect output.\nYou should look at the implementation of #== on Car or its members.\n#<Car:0xXXXXXX @wheels=4, @name=\"Kim\">\n\n1 runs, 1 assertions, 1 failures, 0 errors, 0 skips\n\n```\n\nNotice the helpful failure message!  It even tells you that you need to implement an instance method called `==` in `Car`.  Basically, Minitest is syaing it doesn't know how to assert value equality here.\n\nOk, let's follow the advice and implemtn `Car#==`\n\n```ruby\nclass Car\n  attr_accessor :wheels, :name\n  \n  def initialize\n    @wheels = 4\n  end\n  \n  def ==(other)   # assert_equal would fail wihtou this method\n    other.is_a?(Car) && name == other.name\n  end\nend\n```\n\nWe can now call `assert_equal` on `Car` objects\n\n```ruby\nclass CarTest < MiniTest::Test\n  def test_value_equality\n    car1 = Car.new\n    car2 = Car.new \n    \n    car1.name = \"Kim\"\n    car2.name = \"Kim\"\n    \n    assert_equal(car1, car2)  # this will pass\n    assert_same(car1, car2)  #this will fail\n  end\nend\n```\n\nNow that we told Ruby how to compare two `Car` objects, we can use `assert_equal`.  Notice that `assert_same` is unaffected, because it's still looking at wheter the tow arguments are the same actual object.\n\n</details>\n\n<summary><details>  Code Coverage </summary>\nWhen writing tests, we want to get and idea of **code coverage**, or how much of our actual program code is tested by a test suite.  YOu can see from our `Todolist` tests that all of our public methods are covered.  If we are measuring code coverage based on testing the public methods, we could say that we have achieved 100% code coverage.  Note that even though we are only testing public code, code coverage is based on all of your code, both public and private.  Alos, this doesn't mean every edge case is considered, or that even our program is working correctly.  It only means that we have some tests in place for every method.  There are other ways to measure code coverage too besides looking at public methods.  For example, more sophisticated tools can help with ensuring that all branching logic is tested.  While not foolproof, code coverage is one metric that you can use to gauge code quality.\n\nThere are many code coverage tools, but we'll use a very simpel to use one called `simplecov`\n\nto get started, install the `simplecov` gem.\n\n```ruby\ngem install simplecov\n```\nnext, put this at the top of the test file.\n\nnext time you run `todolist_test.rb` you should see a new directory in the file system called `coverage` Open up the `index.html` file in that directory, and you should see something like this:\n\n\"\"\"\"\n\nIt looks like `simplecov` is smarter than just looking at the public methods, and only considers our test suite to be at 92% coverage.\n\nThis should inform us to add more test so the code coverage should get closer to 100%.  It's not always necessary to get to 100% coverage, but the percentage should depend on the tyep of project you work on.  TH emore fault tolerant it has to be, the higher the test coverage.\n\n\n\n</details>\n\n<details><summary> Procs, blocks, and lambdas with examples </summary>\n\n```ruby\n\n# Group 1\nmy_proc = proc { |thing| puts \"This is a #{thing}.\" }\nputs my_proc\nputs my_proc.class\nmy_proc.call\nmy_proc.call('cat')\n\n# Group 2\nmy_lambda = lambda { |thing| puts \"This is a #{thing}.\" }\nmy_second_lambda = -> (thing) { puts \"This is a #{thing}.\" }\nputs my_lambda\nputs my_second_lambda\nputs my_lambda.class\nmy_lambda.call('dog')\nmy_lambda.call\nmy_third_lambda = Lambda.new { |thing| puts \"This is a #{thing}.\" }\n\n# Group 3\ndef block_method_1(animal)\n  yield\nend\n\nblock_method_1('seal') { |seal| puts \"This is a #{seal}.\"}\nblock_method_1('seal')\n\n# Group 4\ndef block_method_2(animal)\n  yield(animal)\nend\n\nblock_method_2('turtle') { |turtle| puts \"This is a #{turtle}.\"}\nblock_method_2('turtle') do |turtle, seal|\n  puts \"This is a #{turtle} and a #{seal}.\"\nend\nblock_method_2('turtle') { puts \"This is a #{animal}.\"}\nHide Solution & Discussion\nApproach/Algorithm\nIf you need a brief refresher on what arity is, you can find more information on this page\n\n```\n\nSolution\nGroup 1:\n\nA new Proc object can be created with a call of proc instead of Proc.new\nA Proc is an object of class Proc\nA Proc object does not require that the correct number of arguments are passed to it. If nothing is passed, then nil is assigned to the block variable.\nGroup 2\n\nA new Lambda object can be created with a call to lambda or ->. We cannot create a new Lambda object with Lambda.new\nA Lambda is actually a different variety of Proc.\nWhile a Lambda is a Proc, it maintains a separate identity from a plain Proc. This can be seen when displaying a Lambda: the string displayed contains an extra \"(lambda)\" that is not present for regular Procs.\nA lambda enforces the number of arguments. If the expected number of arguments are not passed to it, then an error is thrown.\nGroup 3\n\nA block passed to a method does not require the correct number of arguments. If a block variable is defined, and no value is passed to it, then nil will be assigned to that block variable.\nIf we have a yield and no block is passed, then an error is thrown.\nGroup 4\n\nIf we pass too few arguments to a block, then the remaining ones are assigned a nil value.\nBlocks will throw an error if a variable is referenced that doesn't exist in the block's scope.\nComparison\n\nLambdas are types of Proc's. Technically they are both Proc objects. An implicit block is a grouping of code, a type of closure, it is not an Object.\nLambdas enforce the number of arguments passed to them. Implicit blocks and Procs do not enforce the number of arguments passed in.\n\n</details>\n"
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": ""
    },
    {
      "type": "text",
      "data": "<br>"
    }
  ]
}