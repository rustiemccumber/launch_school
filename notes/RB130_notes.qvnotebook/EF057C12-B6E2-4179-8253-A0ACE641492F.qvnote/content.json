{
  "title": "RB_130 Course Notes",
  "cells": [
    {
      "type": "markdown",
      "data": "\n<details><summary>Closures in Ruby</summary>\n\n\na **closure** is a general programming concept that allows programmers to save a \"chunk of code\" and execute it at a later time.  It's called \"closure\" because it's said to bind its surrounding artifacts (ie, variables, methods, objects, etc)  and build an \"enclosure\" around everything so that htey can be referenced when the closure is later executed.  It's sometimes useful to think of a closure as a method that you can pass around and execute,  but it's not defined with an explicit name. Different programming languages implement closures in different ways.  Some languages will have first class support for it, while other langauges won't deal with it at all.\n\nIn Ruby a closure is implemented through a `Proc` object, a lambda, or a block. That is we can pass around these items as a \"chunk of code\" and execute them later. \n\nThe only thing to remember is that this \"chunk of code\" retains references to its surrounding artifacts -- its binding.\n\nThere are three main ways to work with closure is Ruby:\n\n1. instantiating and object from the `Proc` class\n2. Using *lambdas*\n3. Using *blocks*\n\n</details><summary> Calling Methods with Blocks</summary>\n\nBlocks are so pervasive in RUby that it's almost certain you've not only read code containing blocks, but you've probably writtten blocks youself.  For example:\n\n```ruby\n[1,2,3].each do |num|\n  puts num\nend\n```\nif you've ever written any code with a `do ... end` or `{ ... }`, then you've written blcoks before.  You probbaly didn't know or care to much about the details, only that when you invoked the `each` method on an array or collection, you have to include the magical `do ... end ` or `{ ... }` sequence after it.  Somehow, things just worked.  Let's take a closer look at that familiar code. \n\nThe object we're working with is the collection or `Array` object:\n\n```ruby\n[1, 2, 3]\n```\nThe metho dwe're calling on that object is the `Array#each`:\n\n```ruby\n.each \n```\n\nthe part that's a block is the `do ... end` part:\n\n```ruby\n              do |num|\n  puts num\nend \n```\nIt's important to be able to take aprat the simple code at the top of this assignment into the 3 pieces outlined above.  Sometimes the block of code is quite large.  Don't let that confuse you -- the method being called is still ```Array#each```  (in this case).  THe block is an argument to the method call.  In other words, our familiar method `[1,2,3].each { |num puts num}` is actually passing in the block of code to the `Array#each` method.  \n\n\nwhat can you do wihtin a blcok?\n\nFirst, let's take a look at a few places where blocks are commonly used.\n\n```ruby\n# Example 1: passing in a block to the `Integer#times`\n\n3.times do |num|\n  puts num\nend \n=>  3\n\n# Example 2:  passing in a block to the `Array#map` method.\n\n[1, 2, 3].map do |num|\n  num + 1\nend\n=.  [2, 3, 4]\n\n#  Example 3:  passing in a block to the `Hash#select` method.\n\n{ a: 1, b: 2, c: 3, d: 4, e: 5}.select do |_, value|\n  value > 2\nend\n\n=>  { c: 3, d: 4, e: 5}\n\n```\n\nThis is obviously not an exhaustive list, but look at the examples carefully, and specifically look at 1) the code written in the blocks, and 2) the return value of the mehtod invocaitons.  In the Example 1, invoking the `Integer#times` method returns the calling object (in this case, it's just `3`)  completely ignoring what we wrote in the block.  In example 2,  the treturn value of calling `Array#map` is a new array, with the values manipultaed according to our blcok code.  In Example 3, the return value is a new hash object `{c: 3, d: 4, e: 5}`.  Why is it that sometimes the code in the block affects the return value and sometimes ot?\n\nThe answer lies in how each of those methoddds are implemented.  Remember that the code we wrote in the block is not the method implementation -- in fact, that code has nothing to do with the method implemenation.  The entire block is **passed in** to the method like any other argument, and it's up to the method implemenation to decide what tod ow with the block, or chunk of code, that you passed in.  The method could take that block and execute it, or just as likely, it could competely ignore it -- it's up to the method implemenation to decide what to do with the block of code given to it \n\n</details>\n\n<details><summary> Writing Methods that take Blocks</summary>\n\nBelieve it or not, every mehtod you have ever written in Ruby already takes a block.  Let's implent a simple method.\n\n```ruby\ndef hello\n  \"hello!\"\nend\n\nhello   # \"hello!\"\n\n```\n\nLet's try to call it with some parameters\n\n```ruby\nhello(\"hi\")  # =>  ArgumentError:  wrong number of arguments (1 for 0)\n```\nThis doesn't work, because the `hello` method isn't expacting any parameters, what if we called it with a block?\n\n```ruby\nhello { puts 'hi'}   # => \"hello!\"\n```\n\nThat is unexpected!  ISn't passin gin a blcok to a method just like passin in any other parameter?  Not quite.  In Ruby, every mehtod can take an optional block  as an implicit parameter.  You can just tack it on at the end of the method invocation, just like we did above when calling the `hello` method.  Here are a couple more examples where the method definition takes parameters.\n\n```ruby\ndef ehco(str)\n  str\nend\n\necho           # => ArgumentError: wrong number of arguments (0 for 1)\n\necho(\"hello!\")   # => \"hello!\"\n\necho(\"hello\", \"world!\")  #=>  ArgumetnError: wrogn number of arugments (2 for 1)\n\n#  this time, called with an implicit block\n\necho {puts \"world\"}  # =>  ArgunmentError: wrong number of arguments (0 for 1)\necho(\"hello!\"){ puts \"world\"}   #=>  \"hello!\"\necho(\"hello\", \"world!\"){ puts \"world\"}  # => ArgumentError: wrong number of arguments (2 for 1)\n\n\n```\n\nIt's almost as if the block wasn't even being passed to the mehtod.  How can we be sure athat the method actually has acess to the blcok?\n\n###Yielding\n\nOne way that we can invoke the passed-in block argument from within the method is by using the `yield` keyword.  Let's modify our `echo` method implemenation and yield to the block.\n\n```ruby\ndef echo_with_yield(str)\n  yield\n  str\nend\n```\n\nLet's run the smae three examples from earlier on this new method, and see its behavior\n\n```ruby\necho_with_yield { puts \"world\" }   # => ArgumentError:  Wrong number of arguments (0 for 1)\n\necho_with_yield(\"hello!\") { puts \"world\"}     # => \"hello!\"\n\necho_with_yield(\"hello\", \"world!\") {puts \"world\"}   #=>  ArgumentError:  wrong number of arguments (2 for 1). \n```\nNotice the first method call and the last method call generated errors.  The second method call -- the one with a string parameter as well as a block  -- did what we expected.   That is, it printed out the string `\"world\"` and then returned the stirng `\"hello!\"`.  Seeing these results tells us two things:\n\n1.  The number of arguments at method invocation needs to match the method defiition, regardless of whether we are passing in a block.\n2.  The `yield` keyword executes the block.\n\nThe first point shouldn't be a surprise;  this is old news and noething new.  The second point should get you excited.  This means that when you read a methods's implemenation, that's no the end of the story.  If your method implementation contains a `yield`, a developer using your mehtod can come in after this method is fully implmented and inject additional code in the middle of this mehtod (without modifying the method implemenation), by passin gin a block of code.  This is indeed one of the major use cases of using blcks, which we'll talk more about later.\n\nBefore we play around with a few more examples, let's take a look at a common edge case.  Let's continue using out `echo_with_yield` method from above, but we're now calling it like this:\n\n```ruby\necho_with_yield(\"hello!\")  #=>  LocalJumpError: no block given (yield)\n\n```\n\nThis may be the frist time you've seen `LocalJumpError`.  It's an oddly named error, it's not obvious wha tthat means, but reading the error message makes it celar: no block given (yield).  If you ever see the error message, you should guess that the method implemenation has a `yield` in it somewhere, but we didn't include a block at mehtod invocation.  That's exactly the case here.\n\nIn order to allow calling the method with or without  block, we must somehow wrap the `yield` call in a conditional: only call `yield` when a block is passed to th emethod and don't call `yield` when there's no block.  We can achieve this with the `Kernel#block_given?` method.  And because it's in `Kernel`,  It's available everywhere.  Let's modify out `echo_with_yield` implementation:\n\n```ruby\ndef echo_with_yield(str)\n  yield if block_given?\n  str\nend\n```\nNow, we can call `echo_with_yield` with our without a block.  If a block is passed in the `block_given?`  will be ture, and out code will `yield` to the block (ie, execute the block of code).  If a block is not passed in, the `block_given?`  will be false, and the only thing the mehtod will do is return `str`.\n\n```ruby\necho_with_yield(\"hello!\")   # => \"hello!\"\necho_with_yield(\"hello!\") {Puts \"world\" }  # world\n# =>  \"hello!\"\n```\n\n###Passing exectuion to the block\n\nWe're now ready to exaimine more closly the sequence of code execution when yielding to a block.  Let's come up with a new example: \n\n```ruby\n# mehtod implementation\ndef say(words)\n  yield if block_given?\n  puts \"> \" + words\nend\n\n#method invocation\nsay(\"hi there\") do \n  system 'clear'\nend                 # clears screen first, then outpus \"> hi there\"\n```\n\nBefore we can trace the code execution, we have to be clear that the `def say...` code is the method implemenation, and the `say...` code is the method invocaiton.  There is only one method here: `say`.  Sometimes, when we're passing in a block of code, the method invocation can contain more code than the method ***implemenation***, wheich maks it easy to confuse the two -- don't get mixed up by this.\n\nOnce that's clear, we can start tracing the code execution:\n\n1.  Execution starts at method invocation, on line 8.  The `say` mehtod is invoked with two arguments: a string and a block (the block is an implicit parameter and not part of the method definition.   \n2.  Execution goes to line 2,  where the method local variable `words` is assigned to the string `\"hi there\"`.  The block is passed in implicitly, without being assigned to a variable. \n3.  Execution continues into the first line of the method implemnation, line 3, whcih immediately yields to the block.\n4.  The block, line 9, is now executed, which clears the screen.\n5. After the block is done executing, execution continues in th emethod implementation on line 4.  Executing line 4 results in output being displayed.  \n6. THe method ends which means the last expression's value is returned by this method.  The last epxression in the method invokes the `puts` method, so the return value for the method is `nil`.\n\njust to quickly retrace our steps, execution went like this:\n\n```ruby\nline 8 -> line 2 -> line 3 ->  line 9- > line 4 -> line 5\n```\n\nNotice the jump after line 3:  execution jumps to somwhere else, then comes back to finish the rest of the method.  this is very similar to calling a mehtod, except here we're calling a block.  This is why it's sometimes useful to think of a block ans and un-named or anonymous method.  If you had troule tracing the code executioj flow in the above example.  Makke sure to read through the steps carefully agin, and play with the example on your own. \n\n### Yielding with an argument\n\nsometimes, the block we pass in to a method requires an argument.  Note that the block itself is an argument into a method, so the fact that **the block** requires an arugment adds an additional layer of complexity.  But you've already been writing blcos that take and argument for a long time. for examp:\n\n```ruby\n3.times do |num|\n  puts num\nend\n```\n\nThis should be pretty familiar Ruby code by now.  We'll take it apart below.\n\n```ruby\n3\n```\n\nThe `3` is the calling object.\n\n```ruby\n.times\n```\n\nThe `times` is the method being called. \n\n```ruby\n              do |num|\n      puts num\n  end\n```\n\nAnd the `do ... end` is the block.  The `num` variable betwen the two `I`'s is a parameter for the block, or , more simply, a block parameter.  Within the block, `num` i sa **block local variable**.  This is a special type of local variable where the scope is constrained to the block. \n\nIt's important to make sure the blck parameter has a unique name and doesn't conflict with any local variables outside the scope of the block.  Otherwise, you'll encounter **variable shadowing**.  Shadowing makes it impossible to access the variable defined in the outer scope, which is usually not what you want. \n\n\nLet's write our own method that takes a block with an argument.  Suppose we want to write a method called `increment`  that takes a number as an argument, and returns the argumnet incremented by 1.  At implementation time, we don't want to output the incremented number, bcause we aren't sure how users will use this method.  The only thing we can be sure of is that the method should take and argument and return the argument plus 1. \n\n```ruby\n# method implementation\ndef increment(number)\n  number + 1\nend\n\n# method invocation\nincrement(5)   # => 6\n```\n\nsimple!  the method invocation returns `6`.  But we want to allow users to possibly take some action on the newly incremented number at method invocation time.  Fore example maybe some users want to prit it out or otherss want to log it to a file, or send it to Twitter.  We want to allow for some flexibility atthe mehtod uusage or invocaiton tie.  Blocaks are perfect for this. Let's update the implemenation to yield to a block, and pass in the incremented number into the block. \n\n```ruby\n# method implemnation \ndef increment(number)\n  if block_given?\n    yield(number + 1)\n  end\n  number + 1\nend\n\n# mehtod invocation\nincremetn(5) do |num|\n  puts num\nend\n```\n\nThe above method invocation outputs `6`.  Ntoice the use of `block_given?`, which allows us to continue to call th emethod without a block.  Let's trace the code execution in the above vode snippet. \n\n1.  Execution starts at method invocation on line 10.\n2.  Execution moves to the method implemenation on line 2, which sets `5` to the local variable `number` and the block is noot set to any variable; it's just implicitly available.\n3.  Execution continues on line 3, which is conditional\n4.  our method invocation has indded passed in a passed in a block, so the conidtional is ture, moving execution to line 4.\n5.  On line 4, execution is yieled to the block (or the block is called). and we're passing `number +1` to the block. this measn we're calling thhe block with `6` as the block argument.\n6.  execution jimps to line 10 where the block local variable `num` is assigned `6`.\n7.  Execution conintinues to line 11 wehre we ouput the block local variable `num`. \n8.  Execution continues to line 12, where the end of the blck is reached.\n9.  Execution no jumps back to th emethod implemeantion, where we just finished executing line 4.\n10.  Execution tontues to line #5, the end of the `if`.\n11.  Line 6 returns the value of the incremented argument to line 10.\n12.  The program ends (the return value of `#increment` is not used)\n\nThe squence of execution looks something like this:\n\n```ruby\nline 10 ->  line 2 -> line 3 -> line 4 -> line 10 -> line 11 -> line 12 -> line 5  -> line 6 -> linr 10 -> program ends\n```\n\nonce again, calling ablcok is almost like calling another mehtod.  In this case we're even passing and an argument to the block, just like we could aor any normal method. \n\nNow that you understand how passing an argument to a blcok works, mayb you're thinking \"what would happen if I passed in the wrong number of argument sto a block?\"  Would Ruby rais an `ArgumentErro`?\n\n```ruby\n# method implementation\ndef test\n  yield(1, 2)    # passing 2 block arguments at block invocation time\nend\n\n# method invocation \ntest {  |num| puts num }  # expecting 1 in block implementation parameter\n```\n\nsuprisingly the above code outpus `1`.  The extra block argument is ignored!  What if we pass in less block argument, instead of passing in 1 more?\n\n```ruby\n# method implemenation\ndef test\n  yield(1)     # passing 1 blcok argument at block invocation\nend\n\n#method invocaiton\ntest do |num1, num2|    # expecting 2 parameters in block implemnation\n  puts \"#{num1} #{num2}\"\nend\n```\n\neven more surpsigingly this also outputs `1`.  But this output is different form the previous one.  In this case, `num2` block local variable is `nil`, so the string interpolation converted that to an empty string, which is why we get `1`  (there's and extra space).\n\nThe rules regarding the number of arugments that you can pass to a block, `Proc`, or `lambda` in RUby is called its *arity*.  In Ruby, blocks have lenient arity rules, which is why it doesn't complain when you pass in different number of arguments; `Proc` objects and `lambda`s hae different arity rules.  For now, don't worry too much about this, but just realize that blocks don't enforce argument count, unlike normal methods in Ruby.  You'll forget this rule in a few minutes;  That's ok, just remember to open up `i`b or your eidtor and play around with it to refresh your memory\n\n### Retune vale of yielding to th eblock \n\nsuppose we want to wrte a mehtod that outputs the before and after of mainpulating the argument to the method.  For example, we'd like to invoke a `compare` method that does this:\n\n```ruby\ncompare('hi') { |word|  word.upcase ]\n\n# OUTPUT:\n# BEFORE:  HI\n# AFTER: HI\n```\n\nLet's implement it. \n\n```ruby\n  def compare(str)\n    puts \"Before: #{str}\"\n    after = yield(str)\n    puts \"After:  #{after}\"\n  end\n  \n# method invocation\ncompare('hello') { |word|  word.upcase }\n```\nthe output from the method invocation is:\n\n```ruby\nBefore: hello\nAfter: HELLO\n=> nil\n```\n\nFrom the above example, you can see that the `after` local variable in the `compare` method implementation is assigned the **return value from the blcok**.  This is yet another behavior of blocks that's similar to normal methods:  They have a return value, and that return value is determined based on the last expression in the blcok.  This implies that just like normal methods, blocks can either mutate the argument with a destructive method call or the block can return a value.  Just like writing good normal methods, writing good blocks requires you to keep this distinction in mind.  Note that the last line, `=> nil`, is the return value of the `compare` method, and isn't related to what we're doing in th eblock.  The last expression in the `compare` method is a `puts`, and therefore the return value of calling `compare` is always `nil`.\n\nWe could further call this `compare` method with a variety of different implemenations.\n\n```ruby\ncompare('hello') { |word|  word.slice(1..2) }\n\n# Before: hello\n# After: el\n#  =>  nil\n```\n```ruby\ncompare('hello') { |word| \"nothing to do with anything\"}\n\n# Before: hello\n# After:  nothing to do with anything\n# => nil \n```\n\nIn the above two examples, pay attention to the return value from the block. That's what the `compare` method implemenation is relying on to display in the \"After\" scenario.  Once you understand the basic use case of our `compare` method, let's study a slightly trickier example.\n\n```ruby\ncompare('hello') { |word| puts \"hi\"}\n\n# Before: hello\n# hi\n# After:\n# =>  nil\n```\n\ncan you figure out why the output looks a  little different?  Hint: when you include `nil` in string interpolation, it evaluates to empty string.\n\n### when to use block in your own methods\n\nThere are many ways that blocks can be useful, but the two main use cases are:\n\n1. Defer some implementation code to method invoation decision.\n\n  There are two roles involced with any mehtod: the *method implementor* and the *method caller* (note that this could be the same person/developer).  There are times when the method implementor is not 100% certain of how th emethod will be called.  Maybe the method implementor is 89% certain, but wants to leave that 10% decision up to th emethod caller at method invocation time.\n  \n  Let's first talk about life without blocks.  Without blocks.  The method implentor can allow method callers to pass in some flag.  For example, take out `compare` mehtod above, Suppose we don't use blocks.  We can stil avhieve similar funcionality, like this:\n  \n  ```ruby\n    def compare(str, flag)\n      after = case flag\n              when :upcase\n                str.upcase\n              when :capitalize\n                str.capitalize\n              # etc, we could have alot of 'when' clauses\n              end\n      puts \"Before: #{str}\"\n      puts \"After: #{after}\"\n    end\n    \n    compare(\"hello\", :upcase)\n    \n    # Before: hello\n    # After:  HELLO\n    # =>  nil\n  ```\n  \n  But this isn't nearly as flexible as allowing method callers a way to **refine** the method implemenation, without actually modifying the method implementtion for every one else.  By using blocks,  the method implementor can defer the decision of which flags to support and let th emethod caller decide at method invocation time. The method implementor is syaing \"hey, I don't know what the specifics of your scenario are, so just pass thme in when you need to call this method.  I'll set it up so that you can refine it later, since you understnad your scenario better.:\n  \n  Many of the core library's most useful methods are usefule precisely because they are built in a generic sense, allowing us (the method callers) to refine the method through a block at invocation time.  For example,  tak the `Array#select` method.  We love the `select` method because we can pass in any expression that evaluates to a boolean in the block parameter.  Imagine that instead of a flexible `select` method, we had `select_odds` or `select_greater_than(num)`.  The latter methods would still work, but not be nearly as flexihble and we'd have t memorie all the method names for that specific scenario.  Instead, the `select` method is built in a generic way, allowing us (the method callers) to pass in the refinement to the method implementation.\n  \n  If you encounter a scenario wheer you're calling a method from mulitple places, with one little tweak in each case, it may be a good idea to try implementing the method in a generic way by yieldin to a block.\n  \n2.  Methods that need to perform some \"before\" and \"after\" actions - samdwich code.\n\n  Sandwich code is a good example of the previous point about deferring implmentation to method invocation.  There will be times when you want to write a generic method that performs some \"before\" and \"after\" action.  Before and after what?  That's exactly the point -- The mehtod implementor doesn't care: before and after **anything**.  \"et's explore and example.  Suppose we wasnt to write a method that outputs how long **something** takes.  OUr mehtod doesn't care what that something is; our method just cares about displaying how long it took.  The outline of our method could look like this:\n  \n  ```ruby\n    def time_it\n      time_before = Time.now\n      #do somehting\n      time_after = Time.now\n      \n      puts \" it  took #{time_after - time_before} seconds.\"\n    end\n  ```\n  \n  The question for the method implentor is:  what do we fill in for \"do something\"?  The answer is: nothing.  As the method implementor, we don't care waht code goes there.  The responsibiity for our mehtod starts and stops at timing the action.  Without regard to wha thte actual action is.  This is a good us case for blocks.  Using blocks, we can alllow mehtod callers to specify any action, and us our method to time that action.  Let's update the method implemantion to yield to the block\n  \n  ```ruby\n  def time_it\n    time_beofre = Time.now\n    yield       # execute the implicit block\n    time_after = Time.now\n    \n    puts \"It took #{time_after = time_before} seconds.\"\n  end\n  \n  time_it { sleep(3) }    # It took 3.003767 seconds                 # => nil\n  \n  time_it { \"hello wordl\"}    #It took 3.0e -06 seconds.\n  # => nil\n  ```\n  \n  THe `sleep` mehto there just pauses execution for however many seconds you pass in. You can see that our `time_it` method does exactly what we want:  it times the code passed in to it.  In order to time it, we need to capture the time bore execution, then compare it with the time after execution.  There are many useful use cases for \"sandwich code\".  Timing, loggin,g notification systems are all examples where before/after actions are important. \n  \n  Another area where beofre/aftre actions are importnat is in reosuce akajfame, or interfacing with theopeating system.  Many Os intefaces rquire you, the developer, to first allocate  aportion of a resource,  the peform some clean- up for free up that resource.  Foregetting do the clean-up can result in a dramatic buggs-- system crasheses, memory leaks, file system ocrruption.  Wouldn't i the great if can uautomate this clean - up?\n  \n  this is eaclty what the `Fiiel::opn` mehtod does for us.  For example, the typicl example for opening a file in Ruby is:\n  \n  ```ruby\n    my_file = File.open(\"some_fiie.txt\", \"w+\")\n    # write to this file using my_file.write\n    my_file.close\n  ```\n  \n  That last line closes the file and releases the `my_file` object orm hangin on to system resources --- specifcallly the blok \"some_file.txt\".  Since we always want to close files, `FILE.::OPEN` CAN ALSO TAKE  ABLOCK, AND WILL AUTOMATICALLY CLOSE THE FILE AFTER THE BLOCK IS EXECUTED USIN THE BLCOK SYNTAX, WE CAN DO THIS:\n  \n  ```ruby\n  File.open(\"some_file.txt\". \"w+\") do |file|\n     # write to this file using file.write\n  end\n  \n  ``` \n  \n  Why is it that we don't have to closd the file?  Without understnadinghow blocks work, it's not obvious what the magic is.  But  now that you understnad how yield workds, you can guess that the method implementor of `File::open` opens the file, yields to the block, and then closes the file.  This means the method caller only needs to pass in the relevant file maniplation code in  the block withou worrying about clossing the file. .\n  \n### Methods with an eplicit block parameter\n  \n  TH last topic we want to discuss is passing a block to a method explcitly.  UNtil now, we've passed blocks to methods implicity.   Everyt method, regardless of its definitio, taks an implicit block.  It mya ignore the implicity block, but it still accepts it.  Howeer, ther are timews when you want a method to take an explicit block; you do that by defining a parameter prefeix `&` character in the mehtod definiton:\n  \n  ```ruby\n    def test(&block)\n      puts \"what's &block? #{block}\"\n    end\n  ```\n  \n  Whoa, that looks a bit odd.  The `&block` is a special parameter that converts the block argument to what we call as \"simple\" `Proc` object (the exact definiton of a isimple `Proc` object isn't important at this time).  Notice that we drop the `&` when referring to the parameter inside the method.  Let's invoke the method to see what happens:\n  \n  ```ruby\n  test { sleep(1) }\n  \n  # what's &block? #<Proc:0x007f98e32b83c8@(irb):59>\n  # => nil\n  ```\n  \n  As you can see, the `block` local vriableis now a `Proc` object.  Note that we can name it whatever we please; it dosn't have to be `block` jus a long as we definie it wiht a leadding `&`.\n  \n  So, what's the point?  We were doing fine yielding to an implicit block.  Why do we now need an explicit block instead?  Chiefly, the answer is that it provides additional felxibility.  BEfore, we didn't have a handle (a variable) for the implicit block, so we couldn't do much with it except yield to it and test whether a block was provided.  Now we have a variable that represents the block, so we can **pass** the bloc to anoether method:\n  \n  ```ruby\n  def test2(block)\n    puts \"hello\"\n    block.call        # calls the block that was originally passed to test()\n    puts \"good-bye\"\n  end\n  \n  def test(&block)\n    puts \"1\"\n    test2(block)\n    puts \"2\"\n  end\n  \n  test {puts \"xyx\"}\n  # => 1\n  # => hellow\n  # => xyz\n  # => good-bye\n  # => 2\n  ```\n\nNote that you only need to use `&` fro the `block` paramter in `#test`.  Since `block` is already a `Proc` object when we call `test2` no converison is needed. \n\nNote that we also use `block.call` insdie `test2` to invoke the `Proc` instead of `yield`.  (if you wanted to invoke the `Proc` fom the `test`, you would do the same thing:  `block.call`.)\n\nIt's not often that you need to pass a block around like this, but th eneeed does arise.  While you don't need to spend a lot of time undestanding this, you hsould a least be familiar with the mechanisms; you will see it later.\n\n```\nThe above discussion of the explicit blocks is simplified from reality.  THing sget a bit more complicated if the caller passses in a `Proc` object, a `lambda` or some other object to a mehtod that takes an explicit block.  For now, you jst need to know that Ruby converts blocks passed in as explicit blocks to a simple `Proc` object (this is whey we need to us `#call` to invoke the `Proc` object). \n```\n\n###summary\n\nlets summarize the main points:\n\n- blocks are one way that Ruby implemnts closures. Closures are a way to pass around na unnamed \"chunk o coe\" to be executed later \n- blocks can take argumens, just like normal method.s bUt unlike methds, it won't caompain about wrong number of arguments passed to it\n- blocks return a value, just like normal methods.\n- blocks are a way to defer some implemnation decisions to method invocation time.  It allows method callers to refine a method at invocation time for a specific use case.  It allows method implementors to build generic methods that can be used in a variety of ways.\n- blocks are a good use case for \"sandwich code\" scenarios, like closing a `File` automatically.\n\n</details>\n\n\n<details><summary>Closures in Ruby</summary>\n\n### walk-through: Build a 'times' method\n\nLe't sput what wev'e learned thus far into practice.  Let's write our own `times` method that mimics the behavior of the `Integer#times` method.  First let's study the `Integer#times` method. \n\n```ruby\n5.times do |num|\n  put num\nend\n\n```\n\nInvoking the `Integer#times` method produces this output:\n\n```ruby\n0\n1\n2\n3\n4\n=> 5\n\n```\n\n\nNotice that the `Integer#times` method's first block argument is `0` and the las block argument is 1 less than the calling object.  Finally, the method returns the claling object `5`.\n\nOur `times` method will exhibit the same behavior, yiedling to th eblcok starting with `0` and going up to 1 less than the mehtod argument.  We don't have a calling object, but we do have a mehtod argument, so we'll return that.  In other words, we should be able to write the following code and get identical output as `Integer#times`:\n\n```ruby\ntimes(5) do |num|\n  puts num\nend\n```\n\nlet's give the implemnation a shot\n\n```ruby\n# method implementation\ndef times(number)\n  counter = 0\n  while couter < number do \n    yield(counter)\n    counter + =1\n  end\n  \n  number      #return the original method argument to match the behavior of `Integer#times`\nend \n\n# mehtod invocation\ntimes(5) do |num|\n  puts num\nend\n\n# Output:\n# 0\n# 1\n# 2\n# 3\n# 4\n# => 5\n```\n\nlet's trace code execution flow of the above code.\n\n1. method incoation starts at line 14, when the `times` method is called with an argument , `5`, and a block of code.\n2. Execution enters the first line fo the method implemention at line 3, where th elocal variable counter is initialized.\n3. Execution continues to line 4.  The `while` condidtional is evaluated.  The first time through, the condition is true.\n4. Execution contiues to line 5, which yields to the block.  This is the same as executing the block of code, and this time, we are executing the block of code with an argument.  The argument to the block is the `counter`, which is `0` the frist time through. \n5. Execution jumps to the block on line 13, setting `counter` to the block local variable `num`\n6. execution continues in the block to line 14, which outputs the block local variable `num`.\n7. Reaching the end of the block, execution continues back to the `times` method implementation o lin 6 where the `counter` is incremented.\n8. Reaching the end  of the  while loop, execution continues on line 4, essentially repating steps 3 - 7\n9. a some point the `while` conditionl should return false (otherwise, you have an infinite loop) allowing execution to flow to line 9, which doesn't do anything.\n10. reachign the end of the method at line 10, execution will return the last expression in this method, which is the `number` local variable.\n\nThis example is made a little bit more compplicated due to the `while` loop, but pay attnetion to the itnerplay betwen the method implementation and the block.  From within the mehtod, we are yielding execution to the block, and we are passing and argument to the block.  When we call the methd we know that e must inlucde a block that takes and argument. \n\nIn other words.  There are two separate roles here:  The `times` method implementer andthe user of the `times` method.  For example, let's call themethod implementer Isaac, and the user Uni (Isaace the implementer, and Uni the User).  Both are developers so the roles here are just in relation to the `times` method. \n\nIsaac wants to write a generic `times` method and he dosn't know if users of the method will be outputting values, or adding them together or whatever.  All he wants to do is write a generic method that iterates up to a certain number.  Using a block is a perfect use case;  he can allo users of his method to use blcos to perform some action.  But he doesn't know what that action is, so all he is responsible for is to yield to th eblcok and pass to  the block the current number.  This is the inspiration for our implemenation of our `times` method.\n\n\nOn the other hand, Uni has the need to iterate up to a certain number throughout her code. She finds Isaac's  `times` method and decideds to use it.  She reads the documentation adn finds some examples.  This fits her needs perfectly, as long as she passes in an argument to th emethod, and a blcok that taks an argument.  She can then be sure that the argument to her block is going to be a number starting from `0`, up to 1 lesss than the argument she passed to the method.   This is how Isaac implemented the method, and what he wrote in the documentation.\n\nUp to this point, you've been Uni, using `Integer#times` or `Array#each` by  by relying on documentation.  We're now starting to see how Isaac implements these methods, so you can start implementing these types of generic methods in your own code.\n</details>\n\n\n<details><summary>Walk-through: Build a 'each' method</summary>\n\nLet's now try to apply what we know about blocks and build our own `each` method.  By now, you shold be very familar with the `Array#each` method, and we'll be using that method as our inpiration.  One subtlety to note, though, is tha tthe `Array#each` method returns the calling object at the end.  Example:\n\n```ruby\n[1,2,3].each { |num|  \"do nothing\"}\n```\n\nSo what happens is that the `Array#each` method iterates through the array, yielding each element to the block, where the block can do whatever it needs to do to each element.  Then, the mehtod returns the calling object.  This is so developers can chain methods on afterwards, like this\n\n\n```ruby\n[1,2,3].each{|num| \"do nothing\"}.select{ |num| num.odd?}  # => [1, 3]\n```\n\nLet's write our own `each` method that takes and array, and exhibits the same behaviors as `Array#each`\n\n```ruby\ndef deach(array)\n  counter = 0\n  \n  while counter < array.size\n    yield(array[counter])         # yield to the block passing in hte current element to the block \n    counter += 1                  # returns the `array1 parameter, similar in spirit to how `Array#each` returns the caller\n  end\n  \n  array\nend\n\n```\n\nNote that we used a loop (specifically, a while loop) in the implemention of the `each` method.  We could have as well used the `Array#each` method, since we're passing in an `Array` object, but that somehow would have felt like cheating.  In any case, writing our own loop is easy enough\n\nLet's see houw our `each` method behaves:\n\n```ruby\neach([1, 2, 3, 4, 5])  do |num|\n  puts num\nend\n\n# 1\n# 2\n# 3\n# 4\n# 5\n# =>  [1, 2, 3, 4, 5]\n```\n\nNotic that our `each` method returns the argument at the end, so we can even chain it.\n\n```ruby\neach([1, 2, 3, 4, 5]) {|num| \"do nothing}.select{ |num| num.odd?}  # => [1, 3, 5]\n```\n\nIt looks like out `each` method behaves very similarly to `Array#each`1\n\nThe entire magic of our `each` method relies on the fact that our method does *not*  implemnt what action to perform when iterating through the array.  Do we increment every value by one?  Do we output the element?  None of that metters, beacaue our `each` method is solely focused on **iterating** and not on anything beyond that.  Writing a generic iterating method allows method callers to add additional implemenation details at method invocation time by passing in a block.  This is why when we implemented the method, we `yield` to the block.  Note that the trick here is to pass the current element we're working with to the block.  At each iteration within the `while` loop, execution then goes to the block (with the current element as the block argrument), and will return execution back to the `while` loop after executing the block.  Then,  `counter` is incremented and the `while` loop continues and the next element is yiedled to the block.  If this code flow is confusing, take time now to study that code. \n\n</details>\n\n\n<details><summary>Assignment: Build a 'select' method</summary>\n\nWrite a `select` method that mirros the behavior of `Array#selet`.  Note that the `Array#select` mehtod takes a block, then yields each elemetn to the block.  If the block evaulates to true, the current element will be included in the return array.  IF the block evaluates to false, the current element will not be included in the return array. \n\nHere are some exampls of `Array#slect`\n\n```ruby\narray = [1, 2, 3, 4, 5]\n\narray.select { |num|  num.odd? }  # =>  [1, 3, 5]\narray.select { |num| puts num }   # => [] because \"puts num\" returns nil and evaluates to false \narray.select { |num| num + 1}  # =>  [1 , 2, 3, 4, 5], because \"num + 1\"  evaluates to true\n```\n\nTherefore, youre assingment is to write a `select` method with the above behavior, and you should be able to call it like this \n\n```ruby\narray = [1, 2, 3, 4, 5]\n\nselect(array) { |num| num.oddd? }\n```\n</details>\n\n<details><summary> Assignment: TodoList </summary>\n\nin this assignment, we're going to create a `Todolist` which contains \na colleciton of `Todo` objects.  Internally to `TodoList`, we'll use \nan `Array` to back th ecollection of `Todo` objects.\n\n\nwe'll first take a look at the `Todo` class\n\nthis class represents a todo item and its associated\ndata: name and description.  There's also a \"done\"\nflag to show whether this todo item is done. \n\n```ruby\n\nclass Todo\n  DONE_MARKER = 'X'\n  UNDONE_MARKER = ' '\n\n  attr_accessor :title, :description, :done \n\n  def initialize(title, description='')\n    @title = title\n    @description = description\n    @done = false \n  end\n\n  def done!\n    self.done = true\n  end \n\n  def done?\n    done\n  end\n\n  def undone!\n    self.don = false\n  end\n\n  def to_s \n    \"[#{done? ? DONE_MARKER : UNDONE_MARKER}] #{TITLE}\"\n  end\n\n  def ==(otherTodo)\n    title == otherTOdo.tittle &&\n       description == otherTodo.description && \n       done == otherTodo.done\n  end \nend\n```\n\nThe above is a simple `Todo` class that contains 3 attributes each `Todo` \nobject can have: a title, a description, and a boolean flag to designate\nwhether the todo item is \"done\".  We have 3 helper methods to set, unset, and\ninterrogate the `@done` attribue;  these aren't strictly necessary, but give\na better interface when working with `Todo` objects.  Finally, we provide\na `to_s` method for representing `Todo` objects as strings, and an `==` method\nthat lets us compare two `Todo` objects for equality.  We can us this class in\nout `TodoList` class below to encapsulate todo items.\n\n# Examples with `Todo` class:\n\n```ruby\n\ntodo1 = Todo.new(\"Buy milk\")\ntodo2 = Todo.new(\"Clean room\")\ntodo3 = Todo.new(\"Go to gym\")\n\nputs todo1\nputs todo2\nputs todo3\n\n# [ ] Buy milk\n# [ ] Clean room\n# [ ] Go to gym\n```\n\nThe `puts` methods automatically calls the argument's `to_s` method\nwhich in this case leads to the `Todo#to_s` method.  the return value\nof any `puts` call is `nil`.  Let's say we bought some milk, so we want\nto update the todos.\n\n```ruby\ntodo1.done!\n\nputs todo1\nputs todo2\nputs todo3\n\n# [X]  Buy milk\n# [ ]  Clean room\n# [ ]  Go to gum \n```\n\npretty neat!  There's not too much beyond this functionality for `Todo` objects.\nWe create them, we can mark them done or undone, then we can display them.\n\nLet's now turn out attention to the **collection** class,  `TodoList`. Why\nbuild our own?  Coan't we just use `Array` and work with an array of `Todo` objects?\nWe could, but using our own cutsom collection class allows us to add additional\n attributes to the collection and also allows us to add additional behaviors\n to specific to **todo lits**.  For example, our collection of `Todo` objects \nshould have a tile, or perhaps a due date.  Using `Array` doesn't allow us\nto add these collection level attributes.  We could also append two `TodoList1 objects\ntogeter to get a new `TodoList`, be we can'd do that with `Array` (we'd get a new\n`Array`).  We could further define specific requiremtns about what types of objects\nthis list should have.  For example, our `TodoList` should only work with `Todo` objects,\nand using our own custom collection class, we can enforce this requirement.  We can't\nuse an `Array`.  Someimtes, using Ruby's basic collections is enough, other times\nwe need something more. \n\nTake a look at the initial implemantion of the `TodoList1 class below.  Note that\n we are using `Array` as the bakcing mechanism internally to keep track of our\n`Todo` objects.  We can easily change it to a hash or linked list or whatever\nin the future, as long as our `TodoList1 public interface (ie, public methods) doesn't change\n\n```ruby\n#this class respresnts a collection of Todo objects.\n# you can perform typical collection-oriented actions\n# on a TodoList object, including iteration and seleciton\n\nclass TodoList\n  attr_accessor :title\n  \n  def initialize(title)\n    @title = title\n    @todos = []\n  end\n  \n  # rest of class needs implentation\n```\n\nThe assignment for you is to figure out hte rest of the implemenation in order of the bleow code to work.  Note that this assignment doesn' have anything to do with blcoks yet  -- it's just basci Ruby at thsi point\n\nImplemen the rest of `TodoList` so that we can writ this code:\n\n```ruby\n\n#given\ntodo1 = Todo.new(\"Buy milk\")\ntodo2 = Todo.new(\"Clean room\")\ntodo3 = Todo.new(\"GO to gym\")\nlist = TodoList.new(\"Today's todos\")\n\n# ---- Adding to the list ---\n\n# add\nlist.add\n\n```\n\n</details>\n"
    },
    {
      "type": "text",
      "data": "<br>"
    }
  ]
}